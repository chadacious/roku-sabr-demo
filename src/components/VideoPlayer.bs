import "pkg:/source/logger.bs"
import "pkg:/source/utils.bs"

const TAG = "VideoPlayer"

sub init()
    m.logs = logger()
    m.videoNode = m.top.findNode("videoNode")
    m.titleBackground = m.top.findNode("titleBackground")
    m.titleLabel = m.top.findNode("titleLabel")
    m.timeLabel = m.top.findNode("timeLabel")
    m.top.focusable = true

    if m.videoNode <> invalid
        m.videoNode.observeField("errorCode", "onVideoNodeFieldChanged")
        m.videoNode.observeField("warningCode", "onVideoNodeFieldChanged")
        m.videoNode.observeField("state", "onVideoNodeFieldChanged")
        m.videoNode.observeField("position", "onVideoNodeFieldChanged")
        ' Decode stats help root-cause finishes/errors without extra probes.
        m.videoNode.enableDecoderStats = true
        m.videoNode.notificationInterval = 0.5
    end if
end sub

function getVideoNodeRef() as object
    return m.videoNode
end function

sub setVideo(data as object)
    title = data.title
    manifestPath = data.manifestPath
    manifestType = data.manifestType
    playbackPositionMs = data.playbackPositionMs ?? 0

    showTitleOverlay(title)

    if m.videoNode = invalid then return

    m.logs.printl(log_level_Type.INFO, `[${TAG}] setVideo title='${title}' manifestPath='${manifestPath}'`)

    ' base64 the manifest path to create a mediaId
    mediaId = toBase64(manifestPath)

    content = createObject("roSGNode", "ContentNode")
    content.title = title
    content.url = `http://0.0.0.0:7010/manifest/${mediaId}`
    content.streamFormat = manifestType = "DASH" ? "dash" : "hls"
    content.playStart = playbackPositionMs / 1000

    m.videoNode.content = content
    updateTimeLabel(int(playbackPositionMs), int(m.videoNode.duration * 1000), m.videoNode.state)
    m.videoNode.control = "play"
    m.videoNode.setFocus(true)

end sub

sub onVideoNodeFieldChanged(event as object)
    if event = invalid then return
    field = event.GetField()
    if field = invalid then return
    if m.videoNode = invalid then return

    posMs = int(m.videoNode.position * 1000)
    state = m.videoNode.state
    warningCode = m.videoNode.warningCode
    errorCode = m.videoNode.errorCode
    errorMsg = m.videoNode.errorMsg
    durationMs = int(m.videoNode.duration * 1000)

    if field = "errorCode" and errorCode <> 0
        m.logs.printl(log_level_Type.FATAL, `[${TAG}] VideoNode error code=${errorCode} msg='${errorMsg}' state=${state} positionMs=${posMs}`)
        streamInfo = m.videoNode.streamInfo
        if streamInfo <> invalid
            try
                m.logs.printl(log_level_Type.DEBUG, `[${TAG}] VideoNode streamInfo on error: ${FormatJson(streamInfo)}`)
            catch e
            end try
        end if
        return
    end if

    if field = "warningCode" and warningCode <> 0
        m.logs.printl(log_level_Type.WARN, `[${TAG}] VideoNode warning code=${warningCode} state=${state} positionMs=${posMs}`)
        return
    end if

    if field = "state"
        m.logs.printl(log_level_Type.DEBUG, `[${TAG}] VideoNode state=${state} positionMs=${posMs}`)
        if state = "finished" or state = "error"
            logVideoSnapshot(state)
        end if
    end if

    if field = "position" or field = "state"
        updateTimeLabel(posMs, durationMs, state)
    end if
end sub

sub logVideoSnapshot(reason as string)
    if m.videoNode = invalid then return
    snapshot = {
        "reason": reason
        "state": m.videoNode.state
        "positionMs": int(m.videoNode.position * 1000)
        "durationMs": int(m.videoNode.duration * 1000)
        "contentIndex": m.videoNode.contentIndex
        "isPlaylist": m.videoNode.contentIsPlaylist
        "playStartMs": int((m.videoNode?.content?.playStart ?? 0) * 1000)
        "seekRequest": m.videoNode.seek
    }
    try
        snapshot["streamingSegment"] = m.videoNode.streamingSegment
    catch e
    end try
    try
        snapshot["downloadedSegment"] = m.videoNode.downloadedSegment
    catch e
    end try
    try
        snapshot["completedStreamInfo"] = m.videoNode.completedStreamInfo
    catch e
    end try
    try
        snapshot["decoderStats"] = m.videoNode.decoderStats
    catch e
    end try
    try
        snapshot["positionInfo"] = m.videoNode.positionInfo
    catch e
    end try
    try
        m.logs.printl(log_level_Type.INFO, `[${TAG}] Video snapshot: ${FormatJson(snapshot)}`)
    catch e
        m.logs.printl(log_level_Type.INFO, `[${TAG}] Video snapshot failed to serialize`)
    end try
end sub

sub showTitleOverlay(title as string)
    if m.titleLabel <> invalid then
        m.titleLabel.text = title
        m.titleLabel.visible = title <> ""
    end if
    if m.titleBackground <> invalid then
        m.titleBackground.visible = title <> ""
    end if
end sub

sub updateTimeLabel(posMs as integer, durationMs as integer, state as string)
    if m.timeLabel = invalid then return
    posLabel = formatMs(posMs)
    durLabel = durationMs > 0 ? formatMs(durationMs) : "??:??"
    stateLabel = state <> "" ? state : "unknown"
    m.timeLabel.text = `${posLabel} / ${durLabel} (${stateLabel})`
end sub

function formatMs(totalMs as integer) as string
    if totalMs < 0 then totalMs = 0
    secs = int(totalMs / 1000)
    msRemainder = totalMs mod 1000
    hours = int(secs / 3600)
    mins = int((secs mod 3600) / 60)
    seconds = secs mod 60
    if hours > 0
        return `${hours}:${pad2(mins)}:${pad2(seconds)}.${pad3(msRemainder)}`
    end if
    return `${mins}:${pad2(seconds)}.${pad3(msRemainder)}`
end function

function pad2(value as integer) as string
    if value < 10 then return `0${value}`
    return value.toStr()
end function

function pad3(value as integer) as string
    if value < 10 then return `00${value}`
    if value < 100 then return `0${value}`
    return value.toStr()
end function
