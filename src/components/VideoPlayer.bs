import "pkg:/source/logger.bs"
import "pkg:/source/utils.bs"

const TAG = "VideoPlayer"

sub init()
    m.logs = logger()
    m.videoNode = m.top.findNode("videoNode")
    m.titleBackground = m.top.findNode("titleBackground")
    m.titleLabel = m.top.findNode("titleLabel")
    m.timeLabel = m.top.findNode("timeLabel")
    m.debugTimer = m.top.createChild("Timer")
    if m.debugTimer <> invalid
        m.debugTimer.duration = 2.0
        m.debugTimer.repeat = true
        m.debugTimer.observeField("fire", "onDebugTimerFired")
    end if
    m.top.focusable = true

    if m.videoNode <> invalid
        m.videoNode.observeField("errorCode", "onVideoNodeFieldChanged")
        m.videoNode.observeField("warningCode", "onVideoNodeFieldChanged")
        m.videoNode.observeField("state", "onVideoNodeFieldChanged")
        m.videoNode.observeField("position", "onVideoNodeFieldChanged")
        m.videoNode.observeField("streamingSegment", "onVideoNodeFieldChanged")
        ' Decode stats help root-cause finishes/errors without extra probes.
        m.videoNode.enableDecoderStats = true
        m.videoNode.notificationInterval = 0.5
    end if
end sub

function getVideoNodeRef() as object
    return m.videoNode
end function

sub setVideo(data as object)
    title = data.title
    manifestPath = data.manifestPath
    manifestType = data.manifestType
    playbackPositionMs = data.playbackPositionMs ?? 0

    showTitleOverlay(title)

    if m.videoNode = invalid then return

    m.logs.printl(log_level_Type.INFO, `[${TAG}] setVideo title='${title}' manifestPath='${manifestPath}'`)

    ' base64 the manifest path to create a mediaId
    mediaId = toBase64(manifestPath)

    content = createObject("roSGNode", "ContentNode")
    content.title = title
    content.url = `http://0.0.0.0:7010/manifest/${mediaId}`
    content.streamFormat = manifestType = "DASH" ? "dash" : "hls"
    content.playStart = playbackPositionMs / 1000

    m.videoNode.content = content
    m.videoNode.seekMode = "accurate"
    updateTimeLabel(int(playbackPositionMs), int(m.videoNode.duration * 1000), m.videoNode.state)
    m.videoNode.control = "play"
    m.videoNode.setFocus(true)
    startDebugTimer()

end sub

sub onVideoNodeFieldChanged(event as object)
    if event = invalid then return
    field = event.GetField()
    if field = invalid then return
    if m.videoNode = invalid then return

    posMs = int(m.videoNode.position * 1000)
    state = m.videoNode.state
    warningCode = m.videoNode.warningCode
    errorCode = m.videoNode.errorCode
    errorMsg = m.videoNode.errorMsg
    durationMs = int(m.videoNode.duration * 1000)

    if field = "errorCode" and errorCode <> 0
        m.logs.printl(log_level_Type.FATAL, `[${TAG}] VideoNode error code=${errorCode} msg='${errorMsg}' state=${state} positionMs=${posMs}`)
        streamInfo = m.videoNode.streamInfo
        if streamInfo <> invalid
            try
                m.logs.printl(log_level_Type.DEBUG, `[${TAG}] VideoNode streamInfo on error: ${FormatJson(streamInfo)}`)
            catch e
            end try
        end if
        return
    end if

    if field = "warningCode" and warningCode <> 0
        m.logs.printl(log_level_Type.WARN, `[${TAG}] VideoNode warning code=${warningCode} state=${state} positionMs=${posMs}`)
        return
    end if

    if field = "state"
        m.logs.printl(log_level_Type.DEBUG, `[${TAG}] VideoNode state=${state} positionMs=${posMs}`)
        if state = "finished" or state = "error"
            logVideoSnapshot(state)
        end if
        if state = "finished"
            detectPrematureFinish(posMs, durationMs)
        end if
        if state = "stopped"
            m.logs.printl(log_level_Type.INFO, `[${TAG}] VideoNode stopped for recovery, re-initializing content`)
            if isValid(m.reinitializeVideoContent)
                content = m.reinitializeVideoContent
                m.reinitializeVideoContent = invalid
                m.videoNode.content = content
                m.videoNode.control = "play"
            end if
        end if
    end if

    if field = "position" or field = "state"
        updateTimeLabel(posMs, durationMs, state)
    end if

    if field = "streamingSegment"
        seg = invalid
        try
            seg = m.videoNode.streamingSegment
        catch e
        end try
        if IsAssociativeArray(seg)
            m.logs.printl(log_level_Type.INFO, `[${TAG}] streamingSegment: ${FormatJson(seg)}`)
        end if
    end if
end sub

sub logVideoSnapshot(reason as string)
    if m.videoNode = invalid then return
    snapshot = {
        "reason": reason
        "state": m.videoNode.state
        "positionMs": int(m.videoNode.position * 1000)
        "durationMs": int(m.videoNode.duration * 1000)
        "contentIndex": m.videoNode.contentIndex
        "isPlaylist": m.videoNode.contentIsPlaylist
        "playStartMs": int((m.videoNode?.content?.playStart ?? 0) * 1000)
        "seekRequest": m.videoNode.seek
    }
    try
        snapshot["streamingSegment"] = m.videoNode.streamingSegment
    catch e
    end try
    try
        snapshot["downloadedSegment"] = m.videoNode.downloadedSegment
    catch e
    end try
    try
        snapshot["completedStreamInfo"] = m.videoNode.completedStreamInfo
    catch e
    end try
    try
        snapshot["decoderStats"] = m.videoNode.decoderStats
    catch e
    end try
    try
        snapshot["positionInfo"] = m.videoNode.positionInfo
    catch e
    end try
    try
        m.logs.printl(log_level_Type.INFO, `[${TAG}] Video snapshot: ${FormatJson(snapshot)}`)
    catch e
        m.logs.printl(log_level_Type.INFO, `[${TAG}] Video snapshot failed to serialize`)
    end try
end sub

sub showTitleOverlay(title as string)
    if m.titleLabel <> invalid then
        m.titleLabel.text = title
        m.titleLabel.visible = title <> ""
    end if
    if m.titleBackground <> invalid then
        m.titleBackground.visible = title <> ""
    end if
end sub

sub updateTimeLabel(posMs as integer, durationMs as integer, state as string)
    if m.timeLabel = invalid then return
    posLabel = formatMs(posMs)
    durLabel = durationMs > 0 ? formatMs(durationMs) : "??:??"
    stateLabel = state <> "" ? state : "unknown"
    m.timeLabel.text = `${posLabel} / ${durLabel} (${stateLabel})`
end sub

function formatMs(totalMs as integer) as string
    if totalMs < 0 then totalMs = 0
    secs = int(totalMs / 1000)
    msRemainder = totalMs mod 1000
    hours = int(secs / 3600)
    mins = int((secs mod 3600) / 60)
    seconds = secs mod 60
    if hours > 0
        return `${hours}:${pad2(mins)}:${pad2(seconds)}.${pad3(msRemainder)}`
    end if
    return `${mins}:${pad2(seconds)}.${pad3(msRemainder)}`
end function

function pad2(value as integer) as string
    if value < 10 then return `0${value}`
    return value.toStr()
end function

function pad3(value as integer) as string
    if value < 10 then return `00${value}`
    if value < 100 then return `0${value}`
    return value.toStr()
end function

sub startDebugTimer()
    if m.debugTimer <> invalid
        m.debugTimer.control = "start"
    end if
end sub

sub onDebugTimerFired()
    if m.videoNode = invalid then return
    state = m.videoNode.state
    posMs = int(m.videoNode.position * 1000)
    durMs = int(m.videoNode.duration * 1000)
    m.logs.printl(log_level_Type.DEBUG, `[${TAG}] heartbeat state=${state} posMs=${posMs} durMs=${durMs}`)
end sub

sub detectPrematureFinish(posMs as integer, durationMs as integer)
    ' Heuristic: finished far before duration -> likely boundary/bug.
    ' Basically in a multi-period dash manifest Roku's video node when seek/skip crossing period boundaries is
    ' much too agressive in finishing playback and putting the player into a unusable state. Once it is marked
    ' finished in this way it cannot be recovered except by tearing down the video node and re-initializing it. 
    if durationMs <= 0 then return
    remaining = durationMs - posMs
    if remaining > 10000 ' more than 10 seconds left
        m.logs.printl(log_level_Type.WARN, `[${TAG}] Premature finish? posMs=${posMs} durationMs=${durationMs} remainingMs=${remaining}`)
        m.logs.printl(log_level_Type.WARN, `[${TAG}] positionInfo: ${FormatJson(m.videoNode.positionInfo)}`)
        ' perform a tear down and restart of the video node to recover
        m.videoNode.asyncStopSemantics = true
        m.reinitializeVideoContent = m.videoNode.content
        m.videoNode.content = invalid
        m.reinitializeVideoContent.playStart = m.videoNode.pauseBufferPosition
        m.videoNode.control = "stop" ' await video node stopping
    end if
end sub
