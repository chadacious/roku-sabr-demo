import "pkg:/source/isItem.bs"
import "pkg:/source/logger.bs"
import "pkg:/source/utils.bs"
import "pkg:/source/SabrUtils.bs"

const TAG = "MainScene"

sub init()
    m.logs = logger()
    m.videoPlayer = m.top.findNode("videoPlayer")
    m.logs.printl(log_level_Type.INFO, `[${TAG}] MainScene:init ready`)

    m.utilsTask = CreateObject("roSGNode", "utilsTask")
    m.utilsTask.id = "utilsTask"
    m.utilsTask.control = "RUN"
    m.utilsTask.observeField("uiMessage", "onUtilsTaskMessage")

    m.videoConfig = { "title": "Sample YouTube SABR Video", "playbackPositionMs": 0 }
    ' loadManifest("pkg:/assets/mpds/angel-multiperiod-segbase.mpd")
    ' loadManifest("pkg:/assets/mpds/vanilla-dash.mpd")
    loadManifest("pkg:/assets/mpds/yt-sabr-dash.mpd")
    ' loadManifest("pkg:/assets/hls/angel-multiperiod.m3u8")
    ' loadManifest("pkg:/assets/hls/angel-singleperiod.m3u8")
    ' loadManifest("pkg:/assets/hls/sintel-master.m3u8")
    ' loadManifest("pkg:/assets/hls/angel-sintel.m3u8")

end sub

sub loadManifest(manifestPath as string)
    ' send to utilsTask to load the manifest content
    m.utilsTask.LOAD_FILE_TO_STRING = manifestPath
end sub

function onKeyEvent(key as string, press as boolean, ctrl as boolean, shift as boolean) as boolean
    if key = "back" and press then
        return false
    end if
    return false
end function

sub onUtilsTaskMessage(msg)
    m.logs.printl(log_level_Type.VERBOSE, `[${TAG}] onUtilsTaskMessage: ${msg.GetField()}`)
    message = msg.getData()
    if message.type = "FILE_LOADED_TO_STRING"
        fileData = message.fileData
        prepareManifest(fileData)
    ' else if message.type = "CACHED_STRING_TO_FILE"
    '     result = message.result
    '     m.logs.printl(log_level_Type.INFO, `[${TAG}] Cached string to file result: ${FormatJson(result)}`)
    '     if result.uri = m.videoConfig.manifestPath
    '         m.logs.printl(log_level_Type.INFO, `[${TAG}] Manifest stored to file: ${result.uri}`)
    '         loadVideo()
    '     end if
    end if
end sub

sub prepareManifest(manifest as string)

    manifestType = "DASH"
    manifestPath = ""
    if manifest.Instr("#EXTM3U") > -1
        m.logs.printl(log_level_Type.INFO, `[${TAG}] Detected HLS manifest`)
        manifestType = "HLS"
        manifestPath = `tmp:/currentManifest.m3u8`
    else
        m.logs.printl(log_level_Type.INFO, `[${TAG}] Detected DASH manifest`)
        manifestPath = `tmp:/currentManifest.mpd`
    end if

    manifest = extractPlaybackContext(m.top, m.videoPlayer.callFunc("getVideoNodeRef"), { "manifest": manifest, "manifestType": manifestType, "mediaId": "sample-media-id", "playbackPositionMs": 0 })

    m.videoConfig["manifestPath"] = manifestPath
    m.videoConfig["manifestType"] = manifestType

    ' store the manifest
    ' m.utilsTask.CACHE_STRING_TO_FILE = { "content": manifest, "path": m.videoConfig.manifestPath }
    cacheStringToFile(m.videoConfig.manifestPath, manifest)
    ' if manifestType = "HLS"
    '     ' we need to also store the media playlists referenced in the master playlist
    '     ' parse the master playlist to find the media playlist URIs
    '     lines = manifest.Split(chr(10))
    '     for each line in lines
    '         line = line.Trim()
    '         if line.Len() = 0 then continue for
    '         if line.Left(1) = "#" then continue for
    '         ' this is a media playlist URI
    '         mediaPlaylistUri = line
    '         ' for simplicity, assume it's a relative URI and load from pkg:/assets/hls/
    '         sourcePath = `pkg:/assets/hls/${mediaPlaylistUri}`
    '         ' copy the media playlist to the storage root
    '         copyFile(sourcePath, `${sabr_storageRoot()}/${mediaPlaylistUri}`)
    '         m.logs.printl(log_level_Type.INFO, `[${TAG}] Copied media playlist: ${sourcePath} to ${sabr_storageRoot()}/${mediaPlaylistUri}`)
    '     end for
    ' end if
    m.logs.printl(log_level_Type.INFO, `[${TAG}] Manifest stored to file: ${m.videoConfig.manifestPath}`)
    loadVideo()
end sub

sub loadVideo()
    if m.videoPlayer <> invalid then
        m.videoPlayer.visible = true
        m.videoPlayer.setFocus(true)
        m.videoPlayer.callFunc("setVideo", m.videoConfig)
    end if
end sub

function extractPlaybackContext(scene as object, video as object, mediaSource as object)
    playbackContext = invalid
    manifest = mediaSource.manifest
    manifestType = mediaSource.manifestType
    mediaId = mediaSource.mediaId
    playbackPositionMs = mediaSource.playbackPositionMs
    ' check also for any SupplementalProperty at the root level of the MPD xml and if it's schemeIdUri includes ":urn:youtube:sabr" extract
    ' it as base64, decode it and add it to the playbackContext of the ytsabrServerTask
    if manifestType = "DASH"
        try
            sabrExtraction = sabr_extractScopedSabrPayloads(manifest, m.logs)
            manifest = sabrExtraction.manifest
            sabrPayloadsByScope = sabrExtraction.payloads
            periodBoundaries = sabr_extractPeriodBoundaries(manifest, m.logs)
            if IsAssociativeArray(sabrPayloadsByScope) and sabrPayloadsByScope.Count() > 0
                m.logs.printl(log_level_Type.INFO, `[${TAG}] SDUIPlayer: Found SABR payload scopes: ${sabr_joinWithPipe(sabrPayloadsByScope.Keys())}`)
                if isValid(mediaId) and mediaId <> ""
                    mediaIdHash = hashStringEVP(mediaId, "md5")
                    ' replace sabr:// base URLs with the scoped local servers
                    res = replaceSabrBaseUrlsByContentType(manifest, "video", `http://0.0.0.0:7011/sabr/${mediaIdHash}/`)
                    manifest = res.manifest
                    res = replaceSabrBaseUrlsByContentType(manifest, "audio", `http://0.0.0.0:7012/sabr/${mediaIdHash}/`)
                    manifest = res.manifest

                    ' debug log the BaseURLs after rewrite to confirm scopes
                    sabr_debugLogBaseUrls(manifest, m.logs)

                    ' Store the scoped SABR payload map to disk for the server task to load.
                    payloadMapPath = `${sabr_mediaDir(mediaIdHash)}/sabrPayloadMap.json`
                    ' m.utilsTask.CACHE_STRING_TO_FILE = { "content": FormatJson(sabrPayloadsByScope), "path": payloadMapPath }
                    cacheStringToFile(payloadMapPath, FormatJson(sabrPayloadsByScope))
                    if IsArray(periodBoundaries) and periodBoundaries.Count() > 0
                        periodsPath = `${sabr_mediaDir(mediaIdHash)}/periodBoundaries.json`
                        cacheStringToFile(periodsPath, FormatJson(periodBoundaries))
                        m.logs.printl(log_level_Type.INFO, `[${TAG}] SDUIPlayer: Stored period boundaries to ${periodsPath}`)
                    end if
                    ' Create SABR server tasks for audio/video if needed.
                    if not isValid(scene.ytsabrServerTaskVideo)
                        scene.ytsabrServerTaskVideo = CreateObject("roSGNode", "ytsabrServerTask")
                        scene.ytsabrServerTaskVideo.control = "RUN"
                        scene.ytsabrServerTaskVideo.contentType = "VIDEO"
                        scene.ytsabrServerTaskVideo.videoNode = video
                        scene.ytsabrServerTaskVideo.utilsTask = m.utilsTask
                        if isValid(scene.debugUploadUrl) and scene.debugUploadUrl <> ""
                            scene.ytsabrServerTaskVideo.debugUploadUrl = scene.debugUploadUrl
                        end if
                    end if
                    if not isValid(scene.ytsabrServerTaskAudio)
                        scene.ytsabrServerTaskAudio = CreateObject("roSGNode", "ytsabrServerTask")
                        scene.ytsabrServerTaskAudio.control = "RUN"
                        scene.ytsabrServerTaskAudio.contentType = "AUDIO"
                        scene.ytsabrServerTaskAudio.videoNode = video
                        scene.ytsabrServerTaskAudio.utilsTask = m.utilsTask
                        if isValid(scene.debugUploadUrl) and scene.debugUploadUrl <> ""
                            scene.ytsabrServerTaskAudio.debugUploadUrl = scene.debugUploadUrl
                        end if
                    end if
                else
                    m.logs.printl(log_level_Type.WARN, `[${TAG}] SDUIPlayer: Cannot store SABR payload map as mediaId is missing or invalid`)
                end if
            end if
        catch e
            m.logs.printl(log_level_Type.WARN, `[${TAG}] SDUIPlayer: Error parsing SupplementalProperty from MPD manifest: ${e.message}`)
        end try
    end if
    m.logs.printl(log_level_Type.DEBUG, `[${TAG}] SDUIPlayer manifest: ${manifest}`)
    return manifest
end function

function replaceSabrBaseUrlsByContentType(manifest as string, contentType as string, replacementUrl as string) as object
    if not isValid(manifest) then return manifest
    if Len(manifest) = 0 then return manifest

    regexSabr = CreateObject("roRegex", "sabr://", "i")
    lowerContentType = LCase(contentType)
    searchIndex = 0
    closingTag = "</AdaptationSet>"
    closingTagLength = Len(closingTag)

    while true
        startIndex = Instr(searchIndex, manifest, "<AdaptationSet")
        if startIndex = 0 then exit while

        endIndex = Instr(startIndex, manifest, closingTag)
        if endIndex = 0 then exit while

        blockEnd = endIndex + closingTagLength
        blockLength = blockEnd - startIndex
        adaptationBlock = Mid(manifest, startIndex, blockLength)
        blockLower = LCase(adaptationBlock)

        hasContentTypeAttribute = Instr(blockLower, `contenttype="${lowerContentType}"`) > 0 or Instr(blockLower, `contenttype='${lowerContentType}'`) > 0
        hasMimeTypeAttribute = Instr(blockLower, `mimetype="${lowerContentType}`) > 0 or Instr(blockLower, `mimetype='${lowerContentType}`) > 0

        if (hasContentTypeAttribute or hasMimeTypeAttribute) and regexSabr.isMatch(adaptationBlock)
            prefix = Left(manifest, startIndex - 1)
            suffix = Mid(manifest, blockEnd)
            updatedBlock = regexSabr.replaceAll(adaptationBlock, replacementUrl)
            manifest = prefix + updatedBlock + suffix
            searchIndex = startIndex + Len(updatedBlock)
        else
            searchIndex = blockEnd
        end if
    end while

    return { "manifest": manifest, "replaced": searchIndex > 0 }
end function
