import "pkg:/source/logger.bs"
import "pkg:/source/http.bs"
import "pkg:/source/utils.bs"
import "pkg:/source/taskUtils.bs"

const TAG = "HttpServerTask"

sub init()
    m.logs = logger()
    m.top.functionName = "HttpServer"
    m.connections = {}
    m.sockets = {}
    m.ut = CreateObject("roUrlTransfer")
    m.ut.RetainBodyOnError(true)
    m.ut.enableEncodings(true)
    m.ut.setRequest("GET")
    m.ut.SetCertificatesFile("common:/certs/ca-bundle.crt")
    m.ut.initClientCertificates()
end sub

sub HttpServer()
    port = CreateObject("roMessagePort")
    tcp = CreateObject("roStreamSocket")
    tcp.setMessagePort(port)
    tcpBindAddr = CreateObject("roSocketAddress")
    tcpBindAddr.setPort(7010)
    tcp.setAddress(tcpBindAddr)
    tcp.notifyReadable(true)
    tcp.listen(4)
    if not tcp.eOK()
        m.logs.printl(log_level_Type.WARN, `[${TAG}] Could not create TCP socket`)
        ' stop
    end if
    m.logs.printl(log_level_Type.INFO, `[${TAG}] address is ${tcpBindAddr.getAddress()}`)

    while(true)
        msg = wait(0, port)
        msgType = type(msg)
        if msgType <> "Invalid" then m.logs.printl(log_level_Type.INFO, `[${TAG}] got event ${msgType}`)
        if msgType = "roSocketEvent"
            try
                socketId = msg.getSocketID()
                if socketId = tcp.getID()
                    client = tcp.accept()
                    if client = invalid
                        m.logs.printl(log_level_Type.WARN, `[${TAG}] Accept failed on listen socket ${tcp.getID()}`)
                    else
                        client.notifyReadable(true)
                        client.setMessagePort(port)
                        m.sockets[Stri(client.getID())] = client
                    end if
                else
                    ' Must be a client connection!
                    connection = m.sockets[Stri(socketId)]
                    ' If connection is invalid, what does that mean?
                    if connection <> invalid
                        ' FIXME: Do we actually correctly close sockets?
                        if connection.isReadable() and connection.getCountRcvBuf() = 0 then
                            ' Apparently this means the connection has been closed
                            ' What a terrible way to indicate it
                            m.logs.printl(log_level_Type.INFO, `[${TAG}] Connection ${connection.getID()} is closed`)
                            connection.close()
                            m.sockets[Stri(socketId)] = invalid
                        else
                            logSocketStatus(connection, msg)
                            'print "tcp " ; msg.getSocketID() ; connection.eOK() ; connection.status() ; connection.isConnected() ; connection.isReadable() ; connection.getCountRcvBuf() = 0
                            handleTcp(connection, port)
                        end if
                    else
                        m.logs.printl(log_level_Type.WARN, `[${TAG}] Socket event for unknown connection id=${socketId}`)
                        ' stop
                    end if
                end if
            catch e
                m.logs.printl(log_level_Type.WARN, `[${TAG}] emergency abort roSocket handling`)
                m.logs.printl(log_level_Type.WARN, FormatJson(e))
            end try
        end if
    end while
end sub

sub handleTcp(connection as object, port as object)
    request = m.connections[Stri(connection.getID())]
    if request = invalid then
        ' An unsolicited request. Create an http handler for it
        request = create_new_request()
        m.connections[Stri(connection.getID())] = request
    end if
    status = request.read_data(request, connection)
    if status = false then ' More data is required
        m.logs.printl(log_level_Type.INFO, `[${TAG}] Not yet finished`)
        return
    else if status = true then 'Data is complete. Execute handler
        ' body = request.body
        request.b64Body = request.body.ToBase64String()
        ' ' print "  body: "request.body
        m.logs.printl(log_level_Type.VERBOSE, `[${TAG}] Examining Request: {${chr(10)}  state: ${request.state},${chr(10)}  path: ${request.path},${chr(10)}  headers: ${FormatJson(request.headers)},${chr(10)}  method: ${request.method},${chr(10)}  body_size: ${request.body_size},${chr(10)}  search: ${FormatJson(request.search)},${chr(10)}  body: ${request.b64Body}${chr(10)}`)
        ' Regardless of whether the socket is to be closed, the HTTP request has finished. We have to invalidate it here
        ' since the process_data() call might set up something else
        m.connections[Stri(connection.getID())] = invalid
        should_close = processRequest(request, connection, port)
        if should_close then
            m.sockets[Stri(connection.getID())] = invalid
            connection.close()
            m.logs.printl(log_level_Type.INFO, `[${TAG}] finalizing connection close: ${connection.getID()}`)
        end if
    else ' Error condition. Not handled (FIXME! Need to return ints instead of booleans so we have a third case. Or invalid?)
        m.logs.printl(log_level_Type.WARN, `[${TAG}] unrecognized status: ${status}`)
        ' stop
    end if
end sub

function processRequest(request as object, connection as object, port as object)
    m.logs.printl(log_level_Type.INFO, `[${TAG}] Processing request: ${request?.path}`)
    ' port = CreateObject("roMessagePort")
    status = invalid
    if request.path.inStr("/manifest") > -1 then
        m.logs.printl(log_level_Type.INFO, `[${TAG}] Intercepted manifest request: ${request.path}`)
        ' get the file name from the path and read the file
        mediaId = request.path.replace("/manifest/", "")
        fileName = fromBase64(mediaId)
        ' m.logs.printl(log_level_Type.INFO, `fileName: ${fileName}`)
        manifestData = getFile(fileName)
        contentType = manifestData.inStr("#EXTM3U") = 0 ? "application/x-mpegurl" : "application/dash+xml"
        status = send_http_reply(connection, "200", contentType, manifestData)
    else
        m.logs.printl(log_level_Type.WARN, `[${TAG}] Unexpected URI: ${request.path} on ${connection.getID()}`)
    end if


    m.logs.printl(log_level_Type.INFO, `[${TAG}] Status: ${status}`)
    return true ' false = Keep-alive
end function

sub logSocketStatus(connection as object, msg as object)
    if connection = invalid then return
    if msg = invalid then return
    info = {
        "socketId": connection.getID()
        "readable": connection.isReadable()
        "connected": connection.isConnected()
        "recvBufBytes": connection.getCountRcvBuf()
        "status": connection.status()
        "eConnAborted": connection.eConnAborted()
        "eConnRefused": connection.eConnRefused()
        "eConnReset": connection.eConnReset()
        "eIsConn": connection.eIsConn()
        "eNotConn": connection.eNotConn()
    }
    m.logs.printl(log_level_Type.VERBOSE, `[${TAG}] roSocketEvent detail: ${FormatJson(info)}`)
end sub
