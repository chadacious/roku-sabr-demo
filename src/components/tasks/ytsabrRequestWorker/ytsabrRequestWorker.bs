import "pkg:/source/SabrStreamingAdapter.bs"
import "pkg:/source/SabrUtils.bs"
import "pkg:/source/logger.bs"

sub init()
    m.logs = logger()
    m.top.functionName = "runWorker"
end sub

sub runWorker()
    reqId = sabr_toSafeString(m.top.requestId)
    result = {
        "id": reqId
        "response": invalid
        "fatalReason": ""
    }
    try
        seq = sabr_toInt(m.top.requestSeq)
        if seq <> invalid and seq > 0
            globalAA = GetGlobalAA()
            globalAA["sabrGlobalRequestSequence"] = seq - 1
        end if
        response = sabr_handleRequest(m.top.request, m.top.contentType, m.top.mediaIdHash, m.top.sabrPayload, m.top.videoNode, invalid, 0, m.top.scopeKey, m.top.sabrUtilsTask, m.top.sharedState)
        response = ytsabr_normalizeInitResponse(response, m.top.mediaIdHash, m.top.contentType, m.top.request)
        result["response"] = response
    catch e
        result["fatalReason"] = sabr_formatExceptionDetail(e)
    end try
    m.top.result = result
end sub

function ytsabr_normalizeInitResponse(response as dynamic, mediaIdHash as string, contentType as string, request as object) as dynamic
    if not IsAssociativeArray(response) then return response
    if response?.isInitSeg <> true and not response.DoesExist("data") then return response
    dataBlob = response.Lookup("data")
    if GetInterface(dataBlob, "ifByteArray") = invalid then return response

    ' Persist init/index bytearray to deterministic path and convert to chunk plan.
    keyParam = sabr_toSafeString(request?.search?.key)
    scopeKey = sabr_parseScopedKey(keyParam)?.scope
    if scopeKey = invalid or scopeKey = "" then scopeKey = "root"
    initPath = sabr_computeInitSegmentPath(mediaIdHash, contentType, keyParam, scopeKey)
    fs = CreateObject("roFileSystem")
    if fs.Exists(initPath) <> true
        dataBlob.WriteFile(initPath)
    end if
    totalBytes = dataBlob.count()
    ' Prefer coverage we already calculated when serving from cache; fall back to the incoming header.
    rangeStart = sabr_toInt(response?.coverage?.rangeStart)
    rangeEnd = sabr_toInt(response?.coverage?.rangeEnd)
    if rangeStart = invalid or rangeEnd = invalid
        rangeStart = sabr_toInt(rangeStart)
        rangeEnd = sabr_toInt(rangeEnd)
        if IsAssociativeArray(request?.headers)
            rangeHeader = sabr_getHeaderByteRange(request)
            if rangeStart = invalid then rangeStart = sabr_toInt(rangeHeader?.startRange)
            if rangeEnd = invalid then rangeEnd = sabr_toInt(rangeHeader?.endRange)
        end if
    end if
    if rangeStart = invalid or rangeStart < 0 then rangeStart = 0
    if rangeEnd < rangeStart then rangeEnd = rangeStart
    sliceLength = (rangeEnd - rangeStart) + 1
    chunk = {
        "offset": rangeStart
        "length": sliceLength
    }
    normalized = {}
    for each key in response
        normalized[key] = response[key]
    end for
    normalized.Delete("data")
    normalized["path"] = initPath
    normalized["cleanupPath"] = ""
    normalized["totalBytes"] = sliceLength
    normalized["chunks"] = [chunk]
    normalized["coverage"] = {
        "rangeStart": rangeStart
        "rangeEnd": rangeEnd
    }
    normalized["isInitSeg"] = true
    sabr_log(m.logs, log_level_Type.INFO, `[YTSABR-RequestWorker] normalized init response: path=${initPath} totalBytes=${sliceLength} range=${rangeStart}-${rangeEnd}`)
    if rangeEnd - rangeStart < 10
        stop
    end if
    return normalized
end function
