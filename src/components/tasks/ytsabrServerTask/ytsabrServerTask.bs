import "pkg:/source/logger.bs"
import "pkg:/source/http.bs"
import "pkg:/source/SabrStreamingAdapter.bs"
import "pkg:/source/SabrDebug.bs"

sub init()
    m.logs = logger()
    m.top.functionName = "YtsabrServer"
    m.connections = {}
    m.sockets = {}
    m.ut = CreateObject("roUrlTransfer")
    m.ut.RetainBodyOnError(true)
    m.ut.enableEncodings(true)
    m.ut.setRequest("GET")
    m.ut.SetCertificatesFile("common:/certs/ca-bundle.crt")
    m.ut.initClientCertificates()
    sabr_log(m.logs, log_level_Type.DEBUG, "[YTSABR-Server] Initializing YtsabrServer...")
    m.sabrPayloads = {}
    m.contentType = invalid
end sub

' Task entry point for the SABR HTTP server (video or audio). Accepts
' incoming TCP connections, delegates to the HTTP parser, and feeds requests
' into the SABR streaming adapter.
sub YtsabrServer()
    port = CreateObject("roMessagePort")
    tcp = createobject("roStreamSocket")
    tcp.setMessagePort(port)
    tcp_bind_addr = CreateObject("roSocketAddress")
    tcp_bind_addr.setPort(m.top.contentType = "AUDIO" ? 7012 : 7011)
    m.contentType = m.top.contentType
    sabr_log(m.logs, log_level_Type.INFO, `[YTSABR-Server] Starting YtsabrServer: ${m.top.contentType} on port ${tcp_bind_addr.getPort()}`)
    tcp.setAddress(tcp_bind_addr)
    tcp.notifyReadable(true)
    tcp.listen(4)
    if not tcp.eOK()
        sabr_log(m.logs, log_level_Type.WARN, "[YTSABR-Server] Could not create TCP socket", false)
        ' stop
    end if
    sabr_log(m.logs, log_level_Type.INFO, `[YTSABR-Server] address is ${tcp_bind_addr.getAddress()}`)

    while(true)
        msg = wait(0, port)
        msgType = type(msg)
        ' if msgType <> "Invalid" then sabr_log(m.logs, log_level_Type.INFO, `[YTSABR-Server] got something ${msgType}`)
        if msgType = "roSocketEvent"
            try
                if msg.getSocketID() = tcp.getID()
                    client = tcp.accept()
                    if client = invalid
                        sabr_log(m.logs, log_level_Type.WARN, "[YTSABR-Server] Accept failed", false)
                    else
                        client.notifyReadable(true)
                        client.setMessagePort(port)
                        m.sockets[Stri(client.getID())] = client
                    end if
                else
                    ' Must be a client connection!
                    connection = m.sockets[Stri(msg.getSocketID())]
                    ' If connection is invalid, what does that mean?
                    if isValid(connection)
                        ' FIXME: Do we actually correctly close sockets?
                        if connection.isReadable() and connection.getCountRcvBuf() = 0 and connection.isListening() = false then
                            ' Apparently this means the connection has been closed
                            ' What a terrible way to indicate it
                            sabr_log(m.logs, log_level_Type.INFO, `[YTSABR-Server] Connection ${connection.getID()} is closed`)
                            connection.close()
                            m.sockets[Stri(msg.getSocketID())] = invalid
                        else
                            'print "tcp " ; msg.getSocketID() ; connection.eOK() ; connection.status() ; connection.isConnected() ; connection.isReadable() ; connection.getCountRcvBuf() = 0
                            handle_tcp(connection, port)
                        end if
                    ' else
                    '     sabr_log(m.logs, log_level_Type.WARN, `[YTSABR-Server] Invalid connection: ${msg.getSocketID()}`)
                        ' stop
                    end if
                end if
            catch e
                sabr_log(m.logs, log_level_Type.WARN, "[YTSABR-Server] emergency abort roSocket handling", false)
                sabr_log(m.logs, log_level_Type.WARN, FormatJson(e), false)
            end try
        end if
    end while
end sub

' Reads data from a client socket until an HTTP request is complete, then
' dispatches it to `process_request`. Manages connection lifetime bookkeeping.
sub handle_tcp(connection as object, port as object)
    request = m.connections[Stri(connection.getID())]
    if request = invalid then
        ' An unsolicited request. Create an http handler for it
        request = create_new_request()
        m.connections[Stri(connection.getID())] = request
    end if
    status = request.read_data(request, connection)
    if status = false then ' More data is required
        sabr_log(m.logs, log_level_Type.INFO, "[YTSABR-Server] Not yet finished")
        return
    else if status = true then 'Data is complete. Execute handler
        ' body = request.body
        request.b64Body = request.body.ToBase64String()
        ' ' print "  body: "request.body
        sabr_log(m.logs, log_level_Type.VERBOSE, `[YTSABR-Server] Examining Request: {${chr(10)}  state: ${request.state},${chr(10)}  path: ${request.path},${chr(10)}  headers: ${FormatJson(request.headers)},${chr(10)}  method: ${request.method},${chr(10)}  body_size: ${request.body_size},${chr(10)}  search: ${FormatJson(request.search)},${chr(10)}  body: ${request.b64Body}${chr(10)}}`)
        ' Regardless of whether the socket is to be closed, the HTTP request has finished. We have to invalidate it here
        ' since the process_data() call might set up something else
        m.connections[Stri(connection.getID())] = invalid
        should_close = process_request(request, connection, port)
        if should_close then
            m.sockets[Stri(connection.getID())] = invalid
            connection.close()
            sabr_log(m.logs, log_level_Type.INFO, `[YTSABR-Server] finalizing connection close: ${connection.getID()}`)
        end if
    else ' Error condition. Not handled (FIXME! Need to return ints instead of booleans so we have a third case. Or invalid?)
        sabr_log(m.logs, log_level_Type.WARN, `[YTSABR-Server] unrecognized status: ${status}`, false)
        ' stop
    end if
end sub

' Handles a fully parsed HTTP request for the SABR server. Intercepts SABR
' segment URLs, loads the cached payload metadata, and forwards the request
' to `sabr_handleRequest`, returning `true` when the socket should close.
function process_request(request as object, connection as object, port as object)
    sabr_log(m.logs, log_level_Type.INFO, `[YTSABR-Server] Processing request: ${request?.path}`)
    ' port = CreateObject("roMessagePort")
    status = invalid
    if request.path.inStr("/sabr/") > -1 then
        sabr_log(m.logs, log_level_Type.INFO, `[YTSABR-Server] Intercepted SABR request: ${request.path}`)

        mediaIdHash = sabr_extractMediaIdHash(request.path)
        if mediaIdHash = invalid then
            sabr_log(m.logs, log_level_Type.WARN, `[YTSABR-Server] Could not extract mediaIdHash from URL: ${request.path} on ${connection.getID()}`, false)
            status = send_http_reply(connection, "400", "text/plain", "Bad Request - could not extract mediaIdHash")
            return true
        end if

        ' check if we already have this mediaIdHash sabrPayload.json file loaded
        if m.sabrPayloads[mediaIdHash] = invalid then
            ' Load the sabrPayload.json file from tmp:/{mediaIdHash}/sabrPayload.json
            filePath = `tmp:/${mediaIdHash}/sabrPayload.json`
            fileContent = getFile(filePath)
            if fileContent = invalid or fileContent = "" then
                sabr_log(m.logs, log_level_Type.WARN, `[YTSABR-Server] Could not load sabrPayload.json file: ${filePath} on ${connection.getID()}`, false)
                status = send_http_reply(connection, "500", "text/plain", "Internal Server Error - could not load sabrPayload.json")
                return true
            end if
            ' Parse the JSON content
            sabrPayload = ParseJson(fileContent)
            if sabrPayload = invalid then
                sabr_log(m.logs, log_level_Type.WARN, `[YTSABR-Server] sabrPayload.json file is not valid JSON: ${filePath} on ${connection.getID()}`, false)
                status = send_http_reply(connection, "500", "text/plain", "Internal Server Error - sabrPayload.json is not valid JSON")
                return true
            end if
            m.sabrPayloads[mediaIdHash] = sabrPayload
            sabr_log(m.logs, log_level_Type.INFO, `[YTSABR-Server-${m.contentType}] Loaded sabrPayload for mediaIdHash: ${mediaIdHash} from ${filePath}`)
        else
            sabrPayload = m.sabrPayloads[mediaIdHash]
            sabr_log(m.logs, log_level_Type.INFO, `[YTSABR-Server-${m.contentType}] Using cached sabrPayload for mediaIdHash: ${mediaIdHash}`)
        end if
        sabrResponse = invalid
        sabrResponse = sabr_handleRequest(request, m.contentType, mediaIdHash, sabrPayload, m.top.videoNode)

        if isValid(sabrResponse)
            responseBody = sabrResponse.body
            responseBodyPath = sabrResponse?.bodyPath
            responseBodyOffset = sabr_toInt(sabrResponse?.bodyOffset)
            responseBodyLength = sabr_toInt(sabrResponse?.bodyLength)
            responseHeaders = sabrResponse.headers
            if not isValid(responseHeaders)
                responseHeaders = CreateObject("roAssociativeArray")
            end if
            statusCode = sabrResponse.status
            if not isValid(statusCode)
                statusCode = 204
            end if
            if responseHeaders.DoesExist("Content-Length") = false
                if responseBodyLength <> invalid and responseBodyLength >= 0
                    responseHeaders["Content-Length"] = responseBodyLength.toStr()
                else if GetInterface(responseBody, "ifByteArray") <> invalid
                    responseHeaders["Content-Length"] = responseBody.count().toStr()
                else
                    responseHeaders["Content-Length"] = "0"
                end if
            end if
            if responseHeaders.DoesExist("Content-Type") = false
                responseHeaders["Content-Type"] = "text/plain"
            end if
            if responseHeaders.DoesExist("Connection") = false
                responseHeaders["Connection"] = "close"
            end if
            status = send_http_reply_raw(connection, statusCode, responseHeaders, responseBody, invalid, responseBodyPath, responseBodyOffset, responseBodyLength)
        else
            status = send_http_reply(connection, "204", "text/plain", "")
        end if
    else
        sabr_log(m.logs, log_level_Type.WARN, `[YTSABR-Server] Unexpected URI: ${request.path} on ${connection.getID()}`, false)
    end if

    sabr_log(m.logs, log_level_Type.INFO, `[YTSABR-Server] Status: ${status}`)
    return false ' false = Keep-alive
end function
