import "pkg:/source/logger.bs"
import "pkg:/source/http.bs"
import "pkg:/source/SabrStreamingAdapter.bs"
import "pkg:/source/SabrDebug.bs"
import "pkg:/source/SabrUtils.bs"
import "pkg:/source/SabrShared.bs"
import "pkg:/source/taskUtils.bs"

sub init()
    m.logs = logger()
    m.top.functionName = "YtsabrServer"
    m.connections = {}
    m.sockets = {}
    m.ut = CreateObject("roUrlTransfer")
    m.ut.RetainBodyOnError(true)
    m.ut.enableEncodings(true)
    m.ut.setRequest("GET")
    m.ut.SetCertificatesFile("common:/certs/ca-bundle.crt")
    m.ut.initClientCertificates()
    sabr_log(m.logs, log_level_Type.DEBUG, "[YTSABR-Server] Initializing YtsabrServer...")
    m.sabrPayloads = {}
    m.periodBoundaries = {}
    m.periodBoundaries = {}
    m.contentType = invalid
    m.segmentCache = {}
    m.segmentCacheSeq = 0
    m.segmentCacheLimit = sabr_toInt(m.top?.segmentCacheCount)
    if m.segmentCacheLimit = invalid or m.segmentCacheLimit < 0
        m.segmentCacheLimit = 1
    end if
    m.localRequestSeq = 0
    m.pendingRequests = {}
end sub

' Task entry point for the SABR HTTP server (video or audio). Accepts
' incoming TCP connections, delegates to the HTTP parser, and feeds requests
' into the SABR streaming adapter.
sub YtsabrServer()
    port = CreateObject("roMessagePort")
    m.serverPort = port
    tcp = createobject("roStreamSocket")
    tcp.setMessagePort(port)
    tcp_bind_addr = CreateObject("roSocketAddress")
    tcp_bind_addr.setPort(m.top.contentType = "AUDIO" ? 7012 : 7011)
    m.contentType = m.top.contentType
    sabr_log(m.logs, log_level_Type.INFO, `[YTSABR-Server] Starting YtsabrServer: ${m.top.contentType} on port ${tcp_bind_addr.getPort()}`)
    tcp.setAddress(tcp_bind_addr)
    tcp.notifyReadable(true)
    tcp.listen(4)
    if not tcp.eOK()
        sabr_log(m.logs, log_level_Type.WARN, "[YTSABR-Server] Could not create TCP socket", false)
        ' stop
    end if
    sabr_log(m.logs, log_level_Type.INFO, `[YTSABR-Server] address is ${tcp_bind_addr.getAddress()}`)

    while(true)
        msg = wait(0, port)
        msgType = type(msg)
        ' if msgType <> "Invalid"
        '     sabr_log(m.logs, log_level_Type.VERBOSE, `[YTSABR-Server] Event received type=${msgType}`)
        ' end if
        if msgType = "roSocketEvent"
            try
                socketId = msg.getSocketID()
                if socketId = tcp.getID()
                    client = tcp.accept()
                    if client = invalid
                        ' sabr_log(m.logs, log_level_Type.WARN, `[YTSABR-Server] Accept failed on listen socket ${tcp.getID()}`, false)
                    else
                        client.notifyReadable(true)
                        client.setMessagePort(port)
                        m.sockets[Stri(client.getID())] = client
                    end if
                else
                    ' Must be a client connection!
                    connection = m.sockets[Stri(socketId)]
                    ' If connection is invalid, what does that mean?
                    if isValid(connection)
                        ' FIXME: Do we actually correctly close sockets?
                        safeCountRcv = invalid
                        errOnCount = false
                        if connection.isReadable()
                            try
                                safeCountRcv = connection.getCountRcvBuf()
                            catch e
                                errOnCount = true
                                safeCountRcv = -1
                            end try
                        end if

                        if connection.isReadable() and (safeCountRcv = 0 or errOnCount) and connection.isListening() = false then
                            ' Apparently this means the connection has been closed
                            ' What a terrible way to indicate it
                            sabr_log(m.logs, log_level_Type.INFO, `[YTSABR-Server] Connection ${connection.getID()} is closed`)
                            connection.close()
                            m.sockets[Stri(msg.getSocketID())] = invalid
                        else
                            logSocketStatus(connection)
                            ' print "tcp " ; socketId ; connection.eOK() ; connection.status() ; connection.isConnected() ; connection.isReadable() ; connection.getCountRcvBuf() = 0
                            handle_tcp(connection, port)
                        end if
                    ' else
                    '     ' Stale event for a connection we already closed; ignore instead of spamming WARNs.
                    '     sabr_log(m.logs, log_level_Type.DEBUG, `[YTSABR-Server] Ignoring socket event for closed id=${socketId}`)
                    end if
                end if
            catch e
                sabr_log(m.logs, log_level_Type.WARN, "[YTSABR-Server] emergency abort roSocket handling", false)
                sabr_log(m.logs, log_level_Type.WARN, FormatJson(e), false)
            end try
        else if msgType = "roSGNodeEvent"
            onWorkerEvent(msg)
        end if
    end while
end sub

'------------------------------------------------------------------------------
' Function : sabr_streamUMPPayload
' Purpose  : Stream a SABR spool response back to the Roku player, supporting
'            both cached byte arrays and on-disk chunk lists.
'------------------------------------------------------------------------------
function sabr_streamUMPPayload(connection as object, sabrResponse as dynamic, requestLogTag as string) as integer
    path = sabrResponse.path
    chunks = sabrResponse?.chunks
    totalBytes = sabr_toInt(sabrResponse?.totalBytes)
    payloadStart = sabrResponse.payloadStart
    payloadSize = sabrResponse.payloadSize
    streamStatus = 0
    responseHeaders = sabrResponse.headers
    skipCleanup = sabrResponse?.skipCleanup = true or sabrResponse?.servedFromCache = true
    if not isValid(responseHeaders)
        responseHeaders = CreateObject("roAssociativeArray")
    end if
    statusCode = sabrResponse.status
    if not isValid(statusCode)
        statusCode = 206
    end if

    ' We only stream from disk/chunk plans; bytearrays do not marshal across worker tasks.

    if totalBytes = invalid
        totalBytes = 0
        if IsArray(chunks)
            for each chunk in chunks
                chunkLen = sabr_toInt(chunk?.length)
                if chunkLen <> invalid then totalBytes = totalBytes + chunkLen
            end for
        end if
    end if
    if totalBytes = invalid then totalBytes = 0
    responseHeaders["Content-Length"] = totalBytes.toStr()
    coverageLabel = ""
    coverage = sabrResponse?.coverage
    if IsAssociativeArray(coverage)
        startLabel = sabr_valueToLabel(coverage.Lookup("rangeStart"))
        endLabel = sabr_valueToLabel(coverage.Lookup("rangeEnd"))
        if startLabel <> "" and endLabel <> ""
            coverageLabel = `bytes ${startLabel}-${endLabel}`
        end if
    end if
    if coverageLabel = "" then coverageLabel = "bytes ?-?"
    sourceLabel = sabrResponse?.servedFromInitCache = true ? "init_cache" : "sabr_stream"
    chunkCount = IsArray(chunks) ? chunks.count() : 0
    sabr_log(m.logs, log_level_Type.INFO, `${requestLogTag} Streaming ${sourceLabel} path=${path} range=${coverageLabel} chunks=${chunkCount} totalBytes=${totalBytes}`)
    if not IsArray(chunks) or chunkCount = 0
        sabr_log(m.logs, log_level_Type.WARN, `${requestLogTag} Missing chunk plan path=${path} chunks=${chunkCount} totalBytes=${totalBytes}`, false)
        return send_http_reply(connection, "500", "text/plain", "Internal Server Error - missing chunks")
    end if
    streamStatus = send_http_reply_stream_chunks(connection, statusCode, responseHeaders, path, chunks, totalBytes)
    if streamStatus <= 0
        sabr_log(m.logs, log_level_Type.DEBUG, `${requestLogTag} Streaming reply ended early status=${streamStatus}`, false)
    end if
    cleanupPath = sabr_toSafeString(sabrResponse?.cleanupPath)
    if cleanupPath = "" and sabrResponse?.isInitSeg <> true
        cleanupPath = sabr_toSafeString(path)
    end if
    if skipCleanup <> true and cleanupPath <> ""
        sabr_deleteFileIfExists(cleanupPath)
    end if
    return streamStatus
end function

function ytsabr_segmentCacheEnabled() as boolean
    limit = sabr_toInt(m.segmentCacheLimit)
    if limit = invalid then return false
    return limit > 0
end function

function ytsabr_loadSabrPayloadMap(mediaIdHash as string, connectionId as dynamic) as dynamic
    if m.sabrPayloads[mediaIdHash] = invalid
        filePath = `${sabr_mediaDir(mediaIdHash)}/sabrPayloadMap.json`
        fileContent = getFile(filePath)
        if fileContent = invalid or fileContent = ""
            sabr_log(m.logs, log_level_Type.WARN, `[YTSABR-Server] Could not load sabrPayloadMap.json file: ${filePath} on ${connectionId}`, false)
            return invalid
        end if
        sabrPayloadMap = ParseJson(fileContent)
        if not IsAssociativeArray(sabrPayloadMap)
            sabr_log(m.logs, log_level_Type.WARN, `[YTSABR-Server] sabrPayloadMap.json file is not valid JSON: ${filePath} on ${connectionId}`, false)
            return invalid
        end if
        m.sabrPayloads[mediaIdHash] = sabrPayloadMap
        sabr_log(m.logs, log_level_Type.INFO, `[YTSABR-Server-${m.contentType}] Loaded sabrPayloadMap for mediaIdHash: ${mediaIdHash} from ${filePath}`)
    else
        sabrPayloadMap = m.sabrPayloads[mediaIdHash]
        sabr_log(m.logs, log_level_Type.INFO, `[YTSABR-Server-${m.contentType}] Using cached sabrPayloadMap for mediaIdHash: ${mediaIdHash}`)
    end if
    return m.sabrPayloads[mediaIdHash]
end function

function ytsabr_loadPeriodBoundaries(mediaIdHash as string, connectionId as dynamic) as dynamic
    if m.periodBoundaries[mediaIdHash] = invalid
        filePath = `${sabr_mediaDir(mediaIdHash)}/periodBoundaries.json`
        fileContent = getFile(filePath)
        if fileContent = invalid or fileContent = ""
            return invalid
        end if
        boundaries = ParseJson(fileContent)
        if not IsArray(boundaries)
            sabr_log(m.logs, log_level_Type.WARN, `[YTSABR-Server] periodBoundaries.json is not valid JSON array: ${filePath} on ${connectionId}`, false)
            return invalid
        end if
        m.periodBoundaries[mediaIdHash] = boundaries
        sabr_log(m.logs, log_level_Type.INFO, `[YTSABR-Server-${m.contentType}] Loaded period boundaries for mediaIdHash: ${mediaIdHash} from ${filePath}`)
    else
        boundaries = m.periodBoundaries[mediaIdHash]
    end if
    return boundaries
end function

' sub ytsabr_flagBoundaryRequest(periods as object, requestByteRange as object, requestLogTag as string)
'     if not IsArray(periods) or periods.count() = 0 then return
'     reqStart = sabr_toInt(requestByteRange?.startRange)
'     if reqStart = invalid then return
'     ' We lack direct time/range mapping here; log that a boundary-aware list exists.
'     sabr_log(m.logs, log_level_Type.DEBUG, `${requestLogTag} Period info loaded count=${periods.count()} reqStart=${reqStart}`)
' end sub

function ytsabr_nextLocalRequestId() as string
    m.localRequestSeq = sabr_toInt(m.localRequestSeq) + 1
    return m.localRequestSeq.toStr()
end function

function ytsabr_isSocketPending(connection as object) as boolean
    if connection = invalid then return false
    socketId = Stri(connection.getID())
    for each key in m.pendingRequests
        entry = m.pendingRequests[key]
        if Stri(entry?.socketId) = socketId
            return true
        end if
    end for
    return false
end function

function ytsabr_nextCacheSeq() as integer
    m.segmentCacheSeq = sabr_toInt(m.segmentCacheSeq) + 1
    return m.segmentCacheSeq
end function

function ytsabr_segmentCacheCount() as integer
    total = 0
    if IsAssociativeArray(m.segmentCache)
        for each _ in m.segmentCache
            total = total + 1
        end for
    end if
    return total
end function

function ytsabr_cloneResponse(res as object) as dynamic
    if not IsAssociativeArray(res) then return invalid
    clone = {}
    for each key in res
        clone[key] = res[key]
    end for
    chunks = res.Lookup("chunks")
    if IsArray(chunks)
        chunkCopy = []
        for each ch in chunks
            if IsAssociativeArray(ch)
                copyCh = {}
                for each ck in ch
                    copyCh[ck] = ch[ck]
                end for
                chunkCopy.push(copyCh)
            else
                chunkCopy.push(ch)
            end if
        end for
        clone["chunks"] = chunkCopy
    end if
    return clone
end function

function ytsabr_buildSegmentCacheKey(mediaIdHash as string, scopeKey as string, contentType as string, keyParam as string, requestByteRange as object) as object
    if ytsabr_segmentCacheEnabled() <> true then return invalid
    parsedKey = sabr_parseScopedKey(keyParam)
    cacheScope = sabr_toSafeString(scopeKey)
    formatForKey = invalid
    if IsAssociativeArray(parsedKey)
        if sabr_toSafeString(parsedKey?.scope) <> ""
            cacheScope = parsedKey.scope
        end if
        formatForKey = {
            "itag": parsedKey.itag
            "xTags": parsedKey.xtags
            "xtags": parsedKey.xtags
        }
    end if
    if cacheScope = "" then cacheScope = "root"
    cacheLabel = sabr_sidxIndexKey(contentType, formatForKey, "", cacheScope, mediaIdHash)
    rangeLabel = sabr_formatRequestedRangeForPath(requestByteRange)
    if cacheLabel = "" or rangeLabel = "" then return invalid
    key = `${cacheLabel}|${rangeLabel}`
    dirPath = `${sabr_mediaDir(mediaIdHash)}/segment-cache`
    safeLabel = sabr_sanitizeForFilename(cacheLabel)
    safeRange = sabr_sanitizeForFilename(rangeLabel)
    if safeLabel = "" then safeLabel = "segment"
    if safeRange = "" then safeRange = "range"
    return {
        "key": key
        "dir": dirPath
        "path": `${dirPath}/${safeLabel}_${safeRange}.bin`
        "scope": cacheScope
    }
end function

function ytsabr_canCacheResponse(cacheInfo as object, sabrResponse as object) as boolean
    if ytsabr_segmentCacheEnabled() <> true then return false
    if not IsAssociativeArray(cacheInfo) then return false
    if not IsAssociativeArray(sabrResponse) then return false
    if sabrResponse?.isInitSeg = true then return false
    path = sabr_toSafeString(sabrResponse?.path)
    if path = "" then return false
    chunks = sabrResponse?.chunks
    if not IsArray(chunks) or chunks.count() = 0 then return false
    return true
end function

function ytsabr_segmentCacheLookup(cacheInfo as object, requestLogTag as string) as dynamic
    if ytsabr_segmentCacheEnabled() <> true then return invalid
    if not IsAssociativeArray(cacheInfo) then return invalid
    key = sabr_toSafeString(cacheInfo?.key)
    if key = "" then return invalid
    entry = m.segmentCache.Lookup(key)
    if not IsAssociativeArray(entry) then return invalid
    cachePath = sabr_toSafeString(entry?.path)
    fs = CreateObject("roFileSystem")
    if cachePath = "" or fs.Exists(cachePath) <> true
        m.segmentCache.Delete(key)
        return invalid
    end if
    entry["lastUsed"] = ytsabr_nextCacheSeq()
    cachedResponse = ytsabr_cloneResponse(entry.response)
    if IsAssociativeArray(cachedResponse)
        cachedResponse["skipCleanup"] = true
        cachedResponse["servedFromCache"] = true
    end if
    sabr_log(m.logs, log_level_Type.INFO, `${requestLogTag} Serving spooled segment from cache key=${key}`)
    return cachedResponse
end function

sub ytsabr_segmentCacheEnforceLimit()
    limit = sabr_toInt(m.segmentCacheLimit)
    if limit = invalid or limit <= 0 then return
    while ytsabr_segmentCacheCount() > limit
        oldestKey = ""
        oldestSeq = 0
        for each key in m.segmentCache
            entry = m.segmentCache[key]
            seq = sabr_toInt(entry?.lastUsed)
            if oldestKey = "" or (seq <> invalid and seq < oldestSeq)
                oldestKey = key
                oldestSeq = seq
            end if
        end for
        if oldestKey = "" then exit while
        entry = m.segmentCache[oldestKey]
        sabr_deleteFileIfExists(entry?.path)
        m.segmentCache.Delete(oldestKey)
    end while
end sub

function ytsabr_segmentCacheStore(cacheInfo as object, sabrResponse as object, mediaIdHash as string, requestLogTag as string) as object
    if ytsabr_canCacheResponse(cacheInfo, sabrResponse) <> true then return sabrResponse
    sabr_ensureMediaDir(mediaIdHash)
    cachePath = sabr_toSafeString(cacheInfo?.path)
    cacheDir = sabr_toSafeString(cacheInfo?.dir)
    if cachePath = "" or cacheDir = "" then return sabrResponse
    fs = CreateObject("roFileSystem")
    fs.CreateDirectory(cacheDir)
    sourcePath = sabr_toSafeString(sabrResponse?.path)
    if sourcePath <> "" and sourcePath <> cachePath
        ignore = fs.CopyFile(sourcePath, cachePath)
    end if
    if sourcePath <> "" and sourcePath <> cachePath
        sabr_deleteFileIfExists(sourcePath)
    end if
    cachedResponse = ytsabr_cloneResponse(sabrResponse)
    if not IsAssociativeArray(cachedResponse) then cachedResponse = {}
    cachedResponse["path"] = cachePath
    cachedResponse["cleanupPath"] = ""
    cachedResponse["skipCleanup"] = true
    key = sabr_toSafeString(cacheInfo?.key)
    if key <> ""
        m.segmentCache[key] = {
            "path": cachePath
            "response": cachedResponse
            "lastUsed": ytsabr_nextCacheSeq()
        }
        ytsabr_segmentCacheEnforceLimit()
        sabr_log(m.logs, log_level_Type.INFO, `${requestLogTag} Cached spooled segment key=${key} path=${cachePath}`)
    end if
    return cachedResponse
end function

sub ytsabr_dispatchWorker(requestId as string, request as object, connection as object, cacheInfo as object, requestLogTag as string, requestByteRange as object, mediaIdHash as string, scopeKey as string, sabrPayload as object, sharedState as object)
    ' if m.serverPort = invalid
    '     m.serverPort = CreateObject("roMessagePort")
    ' end if
    worker = CreateObject("roSGNode", "ytsabrRequestWorker")
    if worker = invalid
        send_http_reply(connection, "500", "text/plain", "Internal Server Error - worker unavailable")
        return
    end if
    worker.observeField("result", m.serverPort)
    worker.requestId = requestId
    worker.request = request
    worker.mediaIdHash = mediaIdHash
    worker.scopeKey = scopeKey
    worker.sabrPayload = sabrPayload
    worker.contentType = m.contentType
    worker.videoNode = m.top.videoNode
    worker.debugUploadUrl = m.top.debugUploadUrl
    worker.requestSeq = sabr_toInt(requestId)
    worker.utilsTask = m.top.utilsTask
    worker.sharedState = sharedState
    worker.control = "run"

    m.pendingRequests[requestId] = {
        "socketId": connection.getID()
        "connection": connection
        "requestLogTag": requestLogTag
        "cacheInfo": cacheInfo
        "requestByteRange": requestByteRange
        "mediaIdHash": mediaIdHash
    }
end sub

sub onWorkerEvent(msg as object)
    if type(msg) <> "roSGNodeEvent" then return
    field = msg.GetField()
    if field <> "result" then return
    data = msg.GetData()
    reqId = sabr_toSafeString(data?.id)
    if reqId = "" then reqId = sabr_toSafeString(msg.GetNode()?.requestId)
    entry = m.pendingRequests.Lookup(reqId)
    if not IsAssociativeArray(entry) then
        sabr_log(m.logs, log_level_Type.WARN, `[YTSABR-Server] Worker result with no pending entry id=${reqId}`, false)
        return
    end if
    m.pendingRequests.Delete(reqId)

    connection = entry?.connection
    if connection = invalid then return
    requestLogTag = sabr_toSafeString(entry?.requestLogTag)
    cacheInfo = entry?.cacheInfo
    mediaIdHash = sabr_toSafeString(entry?.mediaIdHash)

    fatalReason = sabr_toSafeString(data?.fatalReason)
    sabrResponse = data?.response
    status = invalid
    if not IsAssociativeArray(data)
        fatalReason = "worker_result_missing"
        sabr_log(m.logs, log_level_Type.WARN, `[YTSABR-Server] Worker result missing data id=${reqId}`)
    else
        sabr_log(m.logs, log_level_Type.DEBUG, `[YTSABR-Server] Worker result id=${reqId} hasResponse=${IsAssociativeArray(sabrResponse)} fatal='${fatalReason}'`)
    end if
    if fatalReason <> ""
        status = send_http_reply(connection, "500", "text/plain", fatalReason)
    else if IsAssociativeArray(sabrResponse)
        if ytsabr_canCacheResponse(cacheInfo, sabrResponse)
            sabrResponse = ytsabr_segmentCacheStore(cacheInfo, sabrResponse, mediaIdHash, requestLogTag)
        end if
        status = sabr_streamUMPPayload(connection, sabrResponse, requestLogTag)
    else
        status = send_http_reply(connection, "500", "text/plain", "Internal Server Error - empty SABR response")
    end if

    socketIdStr = Stri(connection.getID())
    m.sockets[socketIdStr] = invalid
    m.connections[socketIdStr] = invalid
    connection.close()
    sabr_log(m.logs, log_level_Type.INFO, `[YTSABR-Server] finalizing connection close: ${socketIdStr} status=${status}`)
end sub

function sabr_hasBlobData(response as object) as boolean
    if not IsAssociativeArray(response) then return false
    dataBlob = response.Lookup("data")
    if GetInterface(dataBlob, "ifByteArray") = invalid then return false
    return dataBlob.count() > 0
end function

sub logSocketStatus(connection as object)
    if connection = invalid then return
    info = {
        "socketId": connection.getID()
        "readable": connection.isReadable()
        "connected": connection.isConnected()
        "recvBufBytes": -1
        "status": connection.status()
        "eConnAborted": connection.eConnAborted()
        "eConnRefused": connection.eConnRefused()
        "eConnReset": connection.eConnReset()
        "eIsConn": connection.eIsConn()
        "eNotConn": connection.eNotConn()
    }
    if connection.isReadable()
        try
            info["recvBufBytes"] = connection.getCountRcvBuf()
        catch e
            info["recvBufBytes"] = -2
        end try
    end if
    sabr_log(m.logs, log_level_Type.VERBOSE, `[YTSABR-Server] roSocketEvent detail: ${FormatJson(info)}`)
end sub

' Reads data from a client socket until an HTTP request is complete, then
' dispatches it to `process_request`. Manages connection lifetime bookkeeping.
sub handle_tcp(connection as object, port as object)
    if ytsabr_isSocketPending(connection) then return
    request = m.connections[Stri(connection.getID())]
    if request = invalid then
        ' An unsolicited request. Create an http handler for it
        request = create_new_request()
        m.connections[Stri(connection.getID())] = request
    end if
    status = request.read_data(request, connection)
    if status = false then ' More data is required
        sabr_log(m.logs, log_level_Type.INFO, "[YTSABR-Server] Not yet finished")
        return
    else if status = true then 'Data is complete. Execute handler
        ' body = request.body
        request.b64Body = request.body.ToBase64String()
        ' ' print "  body: "request.body
        sabr_log(m.logs, log_level_Type.VERBOSE, `[YTSABR-Server] Examining Request: {${chr(10)}  state: ${request.state},${chr(10)}  path: ${request.path},${chr(10)}  headers: ${FormatJson(request.headers)},${chr(10)}  method: ${request.method},${chr(10)}  body_size: ${request.body_size},${chr(10)}  search: ${FormatJson(request.search)},${chr(10)}  body: ${request.b64Body}${chr(10)}}`)
        ' Regardless of whether the socket is to be closed, the HTTP request has finished. We have to invalidate it here
        ' since the process_data() call might set up something else
        m.connections[Stri(connection.getID())] = invalid
        should_close = process_request(request, connection, port)
        if should_close then
            m.sockets[Stri(connection.getID())] = invalid
            connection.close()
            sabr_log(m.logs, log_level_Type.INFO, `[YTSABR-Server] finalizing connection close: ${connection.getID()}`)
        end if
    else ' Error condition. Not handled (FIXME! Need to return ints instead of booleans so we have a third case. Or invalid?)
        sabr_log(m.logs, log_level_Type.WARN, `[YTSABR-Server] unrecognized status: ${status}`, false)
        ' stop
    end if
end sub

' Handles a fully parsed HTTP request for the SABR server. Intercepts SABR
' segment URLs, loads the cached payload metadata, and forwards the request
' to `sabr_handleRequest`, returning `true` when the socket should close.
function process_request(request as object, connection as object, port as object)
    sabr_log(m.logs, log_level_Type.INFO, `[YTSABR-Server] Processing request: ${request?.path}`)
    ' port = CreateObject("roMessagePort")
    status = invalid
    if request.path.inStr("/sabr/") > -1 then
        sabr_log(m.logs, log_level_Type.INFO, `[YTSABR-Server] Intercepted SABR request: ${request.path}`)

        mediaIdHash = sabr_extractMediaIdHash(request.path)
        if mediaIdHash = invalid then
            sabr_log(m.logs, log_level_Type.WARN, `[YTSABR-Server] Could not extract mediaIdHash from URL: ${request.path} on ${connection.getID()}`, false)
            status = send_http_reply(connection, "400", "text/plain", "Bad Request - could not extract mediaIdHash")
            return true
        end if

        keyParam = ""
        if IsAssociativeArray(request?.search)
            keyParam = sabr_valueToLabel(request.search.Lookup("key"))
        end if
        parsedKey = sabr_parseScopedKey(keyParam)
        if parsedKey = invalid
            sabr_log(m.logs, log_level_Type.WARN, `[YTSABR-Server] Invalid SABR key format: ${keyParam} on ${connection.getID()}`, false)
            status = send_http_reply(connection, "400", "text/plain", "Bad Request - invalid SABR key")
            return true
        end if
        scopeKey = parsedKey.scope

        ' load SABR payload map (scoped) and period boundaries for this media
        sabrPayloadMap = ytsabr_loadSabrPayloadMap(mediaIdHash, connection.getID())
        periodInfo = ytsabr_loadPeriodBoundaries(mediaIdHash, connection.getID())

        sabrPayload = invalid
        if IsAssociativeArray(sabrPayloadMap)
            sabrPayload = sabrPayloadMap.Lookup(scopeKey)
        end if
        if sabrPayload = invalid
            sabr_log(m.logs, log_level_Type.WARN, `[YTSABR-Server-${m.contentType}] No SABR payload for scope ${scopeKey} (mediaIdHash=${mediaIdHash})`, false)
            status = send_http_reply(connection, "404", "text/plain", "Not Found - SABR scope missing")
            return true
        end if

        sharedState = sabr_sharedSeedFromPayload(mediaIdHash, scopeKey, sabrPayload, m.top.utilsTask)
        seedUrl = sabr_toSafeString(sharedState.Lookup("serverAbrStreamingUrl"))
        ' if seedUrl <> ""
        '     sabr_log(m.logs, log_level_Type.DEBUG, `[YTSABR-Server-${m.contentType}] Shared SABR seed scope=${scopeKey} url=${seedUrl}`)
        ' end if
        rangeHeader = ""
        if IsAssociativeArray(request?.headers)
            rangeHeader = sabr_valueToLabel(request.headers.Lookup("range"))
        end if
        requestByteRange = sabr_getHeaderByteRange(request)
        requestByteRange = sabr_normalizeByteRange(requestByteRange, {
            "mediaIdHash": mediaIdHash
            "contentType": m.contentType
        })
        sabr_log(m.logs, log_level_Type.DEBUG, `[YTSABR-Server-${m.contentType}] Request method=${request?.method} path=${request?.path} key=${keyParam} scope=${scopeKey} range=${rangeHeader}`)

        requestId = ytsabr_nextLocalRequestId()
        requestLogTag = sabr_utilLogTag(m.contentType, requestId)
        cacheInfo = ytsabr_buildSegmentCacheKey(mediaIdHash, scopeKey, m.contentType, keyParam, requestByteRange)
        if IsAssociativeArray(cacheInfo)
            request["cachePath"] = cacheInfo.path
        end if
        if IsArray(periodInfo) and periodInfo.Count() > 0
            request["periodBoundaries"] = periodInfo
        end if
        cachedResponse = ytsabr_segmentCacheLookup(cacheInfo, requestLogTag)
        if IsAssociativeArray(cachedResponse)
            status = sabr_streamUMPPayload(connection, cachedResponse, requestLogTag)
            m.sockets[Stri(connection.getID())] = invalid
            m.connections[Stri(connection.getID())] = invalid
            return true
        end if
        ytsabr_dispatchWorker(requestId, request, connection, cacheInfo, requestLogTag, requestByteRange, mediaIdHash, scopeKey, sabrPayload, sharedState)
        return false
    else
        sabr_log(m.logs, log_level_Type.WARN, `[YTSABR-Server] Unexpected URI: ${request.path} on ${connection.getID()}`, false)
    end if

    return false ' false = Keep-alive
end function
