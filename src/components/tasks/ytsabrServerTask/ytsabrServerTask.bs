import "pkg:/source/logger.bs"
import "pkg:/source/http.bs"
import "pkg:/source/SabrStreamingAdapter.bs"

sub init()
    m.logs = logger()
    m.top.functionName = "YtsabrServer"
    m.connections = {}
    m.sockets = {}
    m.ut = CreateObject("roUrlTransfer")
    m.ut.RetainBodyOnError(true)
    m.ut.enableEncodings(true)
    m.ut.setRequest("GET")
    m.ut.SetCertificatesFile("common:/certs/ca-bundle.crt")
    m.ut.initClientCertificates()
    m.logs.printl(log_level_Type.DEBUG, "[YTSABR-Server] Initializing YtsabrServer...")
    m.sabrPayloads = {}
    m.contentType = invalid
    m.fetchWorker = invalid
    m.fetchWorkerObserved = false
    m.fetchPending = {}
    m.connectionFetchMap = {}
    m.fetchSequence = 0
    m.port = invalid
end sub

sub YtsabrServer()
    port = CreateObject("roMessagePort")
    m.port = port
    tcp = createobject("roStreamSocket")
    tcp.setMessagePort(port)
    tcp_bind_addr = CreateObject("roSocketAddress")
    tcp_bind_addr.setPort(m.top.contentType = "AUDIO" ? 7012 : 7011)
    m.contentType = m.top.contentType
    m.logs.printl(log_level_Type.INFO, `[YTSABR-Server] Starting YtsabrServer: ${m.top.contentType} on port ${tcp_bind_addr.getPort()}`)
    tcp.setAddress(tcp_bind_addr)
    tcp.notifyReadable(true)
    tcp.listen(4)
    if not tcp.eOK()
        m.logs.printl(log_level_Type.WARN, "[YTSABR-Server] Could not create TCP socket")
        ' stop
    end if
    m.logs.printl(log_level_Type.INFO, `[YTSABR-Server] address is ${tcp_bind_addr.getAddress()}`)

    ensureFetchWorker(port)

    while(true)
        handledResponse = false
        msg = invalid

        if m.fetchWorker <> invalid
            pendingResponse = m.fetchWorker.fetchResponse
            if IsAssociativeArray(pendingResponse)
                processFetchResponse(pendingResponse)
                m.fetchWorker.fetchResponse = invalid
                handledResponse = true
            end if
        end if

        if handledResponse = false
            msg = wait(10, port)
            if msg = invalid then
                continue while
            end if
        end if
        if handledResponse = true
            continue while
        end if
        msgType = type(msg)
        if msgType = "roSocketEvent"
            try
                if msg.getSocketID() = tcp.getID()
                    client = tcp.accept()
                    if client = invalid
                        m.logs.printl(log_level_Type.WARN, "[YTSABR-Server] Accept failed")
                    else
                        client.notifyReadable(true)
                        client.setMessagePort(port)
                        m.sockets[Stri(client.getID())] = client
                    end if
                else
                    ' Must be a client connection!
                    connection = m.sockets[Stri(msg.getSocketID())]
                    ' If connection is invalid, what does that mean?
                    if isValid(connection)
                        ' FIXME: Do we actually correctly close sockets?
                        if connection.isReadable() and connection.getCountRcvBuf() = 0 and connection.isListening() = false then
                            ' Apparently this means the connection has been closed
                            ' What a terrible way to indicate it
                            m.logs.printl(log_level_Type.INFO, `[YTSABR-Server] Connection ${connection.getID()} is closed`)
                            connection.close()
                            cancelPendingFetchForConnection(connection)
                            m.sockets[Stri(msg.getSocketID())] = invalid
                        else
                            'print "tcp " ; msg.getSocketID() ; connection.eOK() ; connection.status() ; connection.isConnected() ; connection.isReadable() ; connection.getCountRcvBuf() = 0
                            handle_tcp(connection, port)
                        end if
                    ' else
                    '     m.logs.printl(log_level_Type.WARN, `[YTSABR-Server] Invalid connection: ${msg.getSocketID()}`)
                        ' stop
                    end if
                end if
            catch e
                m.logs.printl(log_level_Type.WARN, "[YTSABR-Server] emergency abort roSocket handling")
                m.logs.printl(log_level_Type.WARN, FormatJson(e))
            end try
        else if msgType = "roSGNodeEvent"
            handleNodeEvent(msg)
        end if
    end while
end sub

sub handle_tcp(connection as object, port as object)
    request = m.connections[Stri(connection.getID())]
    if request = invalid then
        ' An unsolicited request. Create an http handler for it
        request = create_new_request()
        m.connections[Stri(connection.getID())] = request
    end if
    status = request.read_data(request, connection)
    if status = false then ' More data is required
        m.logs.printl(log_level_Type.INFO, "[YTSABR-Server] Not yet finished")
        return
    else if status = true then 'Data is complete. Execute handler
        ' body = request.body
        request.b64Body = request.body.ToBase64String()
        ' ' print "  body: "request.body
        m.logs.printl(log_level_Type.VERBOSE, `[YTSABR-Server] Examining Request: {${chr(10)}  state: ${request.state},${chr(10)}  path: ${request.path},${chr(10)}  headers: ${FormatJson(request.headers)},${chr(10)}  method: ${request.method},${chr(10)}  body_size: ${request.body_size},${chr(10)}  search: ${FormatJson(request.search)},${chr(10)}  body: ${request.b64Body}${chr(10)}}`)
        ' Regardless of whether the socket is to be closed, the HTTP request has finished. We have to invalidate it here
        ' since the process_data() call might set up something else
        m.connections[Stri(connection.getID())] = invalid
        should_close = process_request(request, connection, port)
        if should_close then
            m.sockets[Stri(connection.getID())] = invalid
            connection.close()
            m.logs.printl(log_level_Type.INFO, `[YTSABR-Server] finalizing connection close: ${connection.getID()}`)
        end if
    else ' Error condition. Not handled (FIXME! Need to return ints instead of booleans so we have a third case. Or invalid?)
        m.logs.printl(log_level_Type.WARN, `[YTSABR-Server] unrecognized status: ${status}`)
        ' stop
    end if
end sub

function process_request(request as object, connection as object, port as object)
    m.logs.printl(log_level_Type.INFO, `[YTSABR-Server] Processing request: ${request?.path}`)
    ' port = CreateObject("roMessagePort")
    status = invalid
    if request.path.inStr("/sabr/") > -1 then
        m.logs.printl(log_level_Type.INFO, `[YTSABR-Server] Intercepted SABR request: ${request.path}`)

        mediaIdHash = sabr_extractMediaIdHash(request.path)
        if mediaIdHash = invalid then
            m.logs.printl(log_level_Type.WARN, `[YTSABR-Server] Could not extract mediaIdHash from URL: ${request.path} on ${connection.getID()}`)
            status = send_http_reply(connection, "400", "text/plain", "Bad Request - could not extract mediaIdHash")
            return true
        end if

        ' check if we already have this mediaIdHash sabrPayload.json file loaded
        if m.sabrPayloads[mediaIdHash] = invalid then
            ' Load the sabrPayload.json file from tmp:/{mediaIdHash}/sabrPayload.json
            filePath = `tmp:/${mediaIdHash}/sabrPayload.json`
            fileContent = getFile(filePath)
            if fileContent = invalid or fileContent = "" then
                m.logs.printl(log_level_Type.WARN, `[YTSABR-Server] Could not load sabrPayload.json file: ${filePath} on ${connection.getID()}`)
                status = send_http_reply(connection, "500", "text/plain", "Internal Server Error - could not load sabrPayload.json")
                return true
            end if
            ' Parse the JSON content
            sabrPayload = ParseJson(fileContent)
            if sabrPayload = invalid then
                m.logs.printl(log_level_Type.WARN, `[YTSABR-Server] sabrPayload.json file is not valid JSON: ${filePath} on ${connection.getID()}`)
                status = send_http_reply(connection, "500", "text/plain", "Internal Server Error - sabrPayload.json is not valid JSON")
                return true
            end if
            m.sabrPayloads[mediaIdHash] = sabrPayload
            m.logs.printl(log_level_Type.INFO, `[YTSABR-Server-${m.contentType}] Loaded sabrPayload for mediaIdHash: ${mediaIdHash} from ${filePath}`)
        else
            sabrPayload = m.sabrPayloads[mediaIdHash]
            m.logs.printl(log_level_Type.INFO, `[YTSABR-Server-${m.contentType}] Using cached sabrPayload for mediaIdHash: ${mediaIdHash}`)
        end if
        if enqueueFetchRequest(request, connection, mediaIdHash, sabrPayload)
            status = "ASYNC"
        else
            sabrResponse = sabr_handleRequest(request, m.contentType, mediaIdHash, sabrPayload, m.top.videoNode)

            if isValid(sabrResponse)
                responseBody = sabrResponse.body
                if not isValid(responseBody)
                    responseBody = CreateObject("roByteArray")
                end if
                responseHeaders = sabrResponse.headers
                if not isValid(responseHeaders)
                    responseHeaders = CreateObject("roAssociativeArray")
                end if
                statusCode = sabrResponse.status
                if not isValid(statusCode)
                    statusCode = 204
                end if
                if responseHeaders.DoesExist("Content-Length") = false
                    responseHeaders["Content-Length"] = responseBody.count().toStr()
                end if
                if responseHeaders.DoesExist("Content-Type") = false
                    responseHeaders["Content-Type"] = "text/plain"
                end if
                if responseHeaders.DoesExist("Connection") = false
                    responseHeaders["Connection"] = "close"
                end if
                status = send_http_reply_raw(connection, statusCode, responseHeaders, responseBody)
            else
                status = send_http_reply(connection, "204", "text/plain", "")
            end if
        end if
    else
        m.logs.printl(log_level_Type.WARN, `[YTSABR-Server] Unexpected URI: ${request.path} on ${connection.getID()}`)
    end if

    m.logs.printl(log_level_Type.INFO, `[YTSABR-Server] Status: ${status}`)
    return false ' false = Keep-alive
end function

sub ensureFetchWorker(port as object)
    if m.fetchWorker = invalid
        m.fetchWorker = CreateObject("roSGNode", "sabrFetchWorkerTask")
        if m.fetchWorker <> invalid
            m.fetchWorker.id = `sabrFetchWorker-${m.contentType}`
            m.fetchWorker.contentType = m.top.contentType
            if isValid(m.top.utilsTask) then m.fetchWorker.utilsTask = m.top.utilsTask
            if isValid(m.top.videoNode) then m.fetchWorker.videoNode = m.top.videoNode
            if isValid(m.top.debugUploadUrl) then m.fetchWorker.debugUploadUrl = m.top.debugUploadUrl
            m.fetchWorker.requestQueue = []
            m.fetchWorker.fetchResponse = invalid
            if not m.fetchWorkerObserved
                m.fetchWorker.observeField("fetchResponse", port)
                m.fetchWorkerObserved = true
            end if
            m.fetchWorker.control = "RUN"
        end if
    else
        if m.fetchWorker.id = invalid or m.fetchWorker.id = ""
            m.fetchWorker.id = `sabrFetchWorker-${m.contentType}`
        end if
        if isValid(m.top.utilsTask) and m.fetchWorker.utilsTask = invalid
            m.fetchWorker.utilsTask = m.top.utilsTask
        end if
        if isValid(m.top.videoNode) and m.fetchWorker.videoNode = invalid
            m.fetchWorker.videoNode = m.top.videoNode
        end if
        if isValid(m.top.debugUploadUrl) and m.fetchWorker.debugUploadUrl <> m.top.debugUploadUrl
            m.fetchWorker.debugUploadUrl = m.top.debugUploadUrl
        end if
        if not m.fetchWorkerObserved
            m.fetchWorker.observeField("fetchResponse", port)
            m.fetchWorkerObserved = true
        end if
    end if
end sub

function enqueueFetchRequest(request as object, connection as object, mediaIdHash as string, sabrPayload as object) as boolean
    ensureFetchWorker(m.port)
    if m.fetchWorker = invalid then return false
    if connection = invalid then return false

    fetchId = m.fetchSequence + 1
    m.fetchSequence = fetchId

    requestPayload = serializeRequestForWorker(request)
    if not IsAssociativeArray(requestPayload) then return false

    entry = {
        "connection": connection
        "request": requestPayload
        "mediaIdHash": mediaIdHash
    }
    key = Stri(fetchId)
    m.fetchPending[key] = entry
    connKey = Stri(connection.getID())
    m.connectionFetchMap[connKey] = fetchId

    payload = {
        "fetchId": fetchId
        "request": requestPayload
        "mediaIdHash": mediaIdHash
        "sabrPayload": sabrPayload
        "contentType": m.contentType
        "debugUploadUrl": m.top.debugUploadUrl
    }

    queuePayload = []
    existingQueue = m.fetchWorker.requestQueue
    if IsArray(existingQueue)
        for each item in existingQueue
            queuePayload.push(item)
        end for
    end if
    queuePayload.push(payload)
    m.fetchWorker.requestQueue = queuePayload
    m.logs.printl(log_level_Type.DEBUG, `[YTSABR-Server-${m.contentType}] Dispatched fetch ${fetchId} for ${mediaIdHash}`)
    return true
end function

function serializeRequestForWorker(request as object) as object
    if not IsAssociativeArray(request) then return invalid

    headers = CreateObject("roAssociativeArray")
    if IsAssociativeArray(request.headers)
        for each headerKey in request.headers
            headers[headerKey] = request.headers[headerKey]
        end for
    end if

    searchParams = CreateObject("roAssociativeArray")
    if IsAssociativeArray(request.search)
        for each paramKey in request.search
            searchParams[paramKey] = request.search[paramKey]
        end for
    end if

    payload = {
        "path": request.path
        "method": request.method
        "headers": headers
        "search": searchParams
        "bodySize": request.body_size
        "b64Body": request.b64Body
    }
    return payload
end function

sub handleNodeEvent(msg as object)
    node = msg.GetNode()
    if node = invalid then return

    nodeMatches = false
    nodeType = Type(node)
    if nodeType = "roSGNode"
        nodeMatches = (node = m.fetchWorker)
    else if nodeType = "roString"
        nodeMatches = (LCase(node) = LCase(m.fetchWorker.id))
    end if

    if nodeMatches = false then return

    field = msg.GetField()
    m.logs.printl(log_level_Type.DEBUG, `[YTSABR-Server-${m.contentType}] Node event ${field} (${nodeType}) from fetch worker`)
    if field = "fetchResponse"
        responsePayload = m.fetchWorker.fetchResponse
        if IsAssociativeArray(responsePayload)
            processFetchResponse(responsePayload)
        end if
        m.fetchWorker.fetchResponse = invalid
    end if
end sub

sub processFetchResponse(responsePayload as object)
    fetchId = responsePayload?.fetchId
    key = Stri(fetchId)
    pending = m.fetchPending.Lookup(key)
    if pending = invalid
        m.logs.printl(log_level_Type.WARN, `[YTSABR-Server] Received response for unknown fetch ${fetchId}`)
        return
    end if

    m.logs.printl(log_level_Type.DEBUG, `[YTSABR-Server-${m.contentType}] Processing fetch response ${fetchId}`)

    connection = pending.connection
    if connection = invalid
        m.logs.printl(log_level_Type.WARN, `[YTSABR-Server] Connection missing for fetch ${fetchId}`)
        cleanupFetch(fetchId, pending)
        return
    end if

    errorInfo = responsePayload?.error
    status = invalid

    if isValid(errorInfo)
        message = errorInfo?.message ?? "SABR request failed"
        status = send_http_reply(connection, "500", "text/plain", message)
    else
        responseInfo = responsePayload?.response
        if isValid(responseInfo)
            body = invalid
            bodyPath = responseInfo?.bodyPath
            responseHeaders = responseInfo?.headers
            if not IsAssociativeArray(responseHeaders)
                responseHeaders = CreateObject("roAssociativeArray")
            end if
            statusCode = responseInfo?.status
            if IsString(statusCode)
                statusCode = Val(statusCode)
            else if not IsInteger(statusCode)
                statusCode = 204
            end if

            responseError = responseInfo?.error
            if isValid(responseError)
                errorMessage = responseError?.message ?? "Internal worker error"
                status = send_http_reply(connection, "500", "text/plain", errorMessage)
                cleanupFetch(fetchId, pending)
                return
            end if

            if isValid(bodyPath) and bodyPath <> ""
                ba = CreateObject("roByteArray")
                if ba.readFile(bodyPath)
                    body = ba
                else
                    m.logs.printl(log_level_Type.WARN, `[YTSABR-Server-${m.contentType}] Failed to read body file ${bodyPath}`)
                end if
            end if

            if body = invalid
                fallbackBody = responseInfo?.body
                if GetInterface(fallbackBody, "ifByteArray") <> invalid
                    body = fallbackBody
                end if
            end if

            if body = invalid
                body = CreateObject("roByteArray")
            end if

            if responseHeaders.DoesExist("Content-Length") = false
                responseHeaders["Content-Length"] = body.count().toStr()
            end if
            if responseHeaders.DoesExist("Content-Type") = false
                responseHeaders["Content-Type"] = "text/plain"
            end if
            if responseHeaders.DoesExist("Connection") = false
                responseHeaders["Connection"] = "close"
            end if

            status = send_http_reply_raw(connection, statusCode, responseHeaders, body)

            if isValid(bodyPath) and bodyPath <> ""
                fs = CreateObject("roFileSystem")
                if fs <> invalid and fs.Exists(bodyPath)
                    fs.Delete(bodyPath)
                end if
            end if
        else
            status = send_http_reply(connection, "204", "text/plain", "")
        end if
    end if

    m.logs.printl(log_level_Type.INFO, `[YTSABR-Server] Completed fetch ${fetchId} with status ${status}`)
    cleanupFetch(fetchId, pending)
end sub

sub cleanupFetch(fetchId as integer, pending as object)
    key = Stri(fetchId)
    if m.fetchPending.DoesExist(key)
        m.fetchPending.Delete(key)
    end if

    connection = pending?.connection
    if connection <> invalid
        connKey = Stri(connection.getID())
        if m.connectionFetchMap.DoesExist(connKey)
            m.connectionFetchMap.Delete(connKey)
        end if
        connection.close()
        m.sockets[connKey] = invalid
    end if
end sub

sub cancelPendingFetchForConnection(connection as object)
    if connection = invalid then return
    connKey = Stri(connection.getID())
    if not m.connectionFetchMap.DoesExist(connKey) then return
    fetchId = m.connectionFetchMap.Lookup(connKey)
    key = Stri(fetchId)
    if m.fetchPending.DoesExist(key)
        m.fetchPending.Delete(key)
    end if
    m.connectionFetchMap.Delete(connKey)
    m.logs.printl(log_level_Type.INFO, `[YTSABR-Server] Cancelled pending fetch ${fetchId} for closed connection ${connKey}`)
end sub
