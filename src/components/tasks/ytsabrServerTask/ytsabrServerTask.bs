import "pkg:/source/logger.bs"
import "pkg:/source/http.bs"
import "pkg:/source/SabrStreamingAdapter.bs"

sub init()
    m.logs = logger()
    m.top.functionName = "YtsabrServer"
    m.connections = {}
    m.sockets = {}
    m.ut = CreateObject("roUrlTransfer")
    m.ut.RetainBodyOnError(true)
    m.ut.enableEncodings(true)
    m.ut.setRequest("GET")
    m.ut.SetCertificatesFile("common:/certs/ca-bundle.crt")
    m.ut.initClientCertificates()
    m.logs.printl(log_level_Type.DEBUG, "[YTSABR-Server] Initializing YtsabrServer...")
    m.sabrPayloads = {}
    m.contentType = invalid
    m.fetchPending = {}
    m.connectionFetchMap = {}
    m.fetchSequence = 0
    m.port = invalid
    m.workerPool = []
    m.workerState = {}
    m.requestQueue = []
    m.inFlightSignatures = {}
    m.workerPoolEnabled = true
end sub

sub YtsabrServer()
    port = CreateObject("roMessagePort")
    m.port = port
    tcp = createobject("roStreamSocket")
    tcp.setMessagePort(port)
    tcp_bind_addr = CreateObject("roSocketAddress")
    tcp_bind_addr.setPort(m.top.contentType = "AUDIO" ? 7012 : 7011)
    m.contentType = m.top.contentType
    m.logs.printl(log_level_Type.INFO, `[YTSABR-Server] Starting YtsabrServer: ${m.top.contentType} on port ${tcp_bind_addr.getPort()}`)
    tcp.setAddress(tcp_bind_addr)
    tcp.notifyReadable(true)
    tcp.listen(4)
    if not tcp.eOK()
        m.logs.printl(log_level_Type.WARN, "[YTSABR-Server] Could not create TCP socket")
        ' stop
    end if
    m.logs.printl(log_level_Type.INFO, `[YTSABR-Server] address is ${tcp_bind_addr.getAddress()}`)

    ensureWorkerPool(port)

    while(true)
        if processFetchWorkerEvents()
            continue while
        end if

        msg = wait(0, port)
        if msg = invalid then
            continue while
        end if

        msgType = type(msg)
        if msgType = "roSocketEvent"
            try
                if msg.getSocketID() = tcp.getID()
                    client = tcp.accept()
                    if client = invalid
                        m.logs.printl(log_level_Type.WARN, "[YTSABR-Server] Accept failed")
                    else
                        client.notifyReadable(true)
                        client.setMessagePort(port)
                        m.sockets[Stri(client.getID())] = client
                    end if
                else
                    ' Must be a client connection!
                    connection = m.sockets[Stri(msg.getSocketID())]
                    ' If connection is invalid, what does that mean?
                    if isValid(connection)
                        ' FIXME: Do we actually correctly close sockets?
                        if connection.isReadable() and connection.getCountRcvBuf() = 0 and connection.isListening() = false then
                            ' Apparently this means the connection has been closed
                            ' What a terrible way to indicate it
                            m.logs.printl(log_level_Type.INFO, `[YTSABR-Server] Connection ${connection.getID()} is closed`)
                            connection.close()
                            cancelPendingFetchForConnection(connection)
                            m.sockets[Stri(msg.getSocketID())] = invalid
                        else
                            'print "tcp " ; msg.getSocketID() ; connection.eOK() ; connection.status() ; connection.isConnected() ; connection.isReadable() ; connection.getCountRcvBuf() = 0
                            handle_tcp(connection, port)
                        end if
                    ' else
                    '     m.logs.printl(log_level_Type.WARN, `[YTSABR-Server] Invalid connection: ${msg.getSocketID()}`)
                        ' stop
                    end if
                end if
            catch e
                m.logs.printl(log_level_Type.WARN, "[YTSABR-Server] emergency abort roSocket handling")
                m.logs.printl(log_level_Type.WARN, FormatJson(e))
            end try
        end if
    end while
end sub

function processFetchWorkerEvents() as boolean
    processed = false
    if not IsArray(m.workerPool) then return false
    for each worker in m.workerPool
        if worker = invalid then continue for
        events = worker.fetchEvents
        if IsArray(events) and events.count() > 0
            for each event in events
                if not IsAssociativeArray(event) then continue for
                event["workerId"] = worker.id
                processFetchEvent(event)
                processed = true
            end for
            worker.fetchEvents = []
        end if
    end for
    return processed
end function

sub handle_tcp(connection as object, port as object)
    request = m.connections[Stri(connection.getID())]
    if request = invalid then
        ' An unsolicited request. Create an http handler for it
        request = create_new_request()
        m.connections[Stri(connection.getID())] = request
    end if
    status = request.read_data(request, connection)
    if status = false then ' More data is required
        m.logs.printl(log_level_Type.INFO, "[YTSABR-Server] Not yet finished")
        return
    else if status = true then 'Data is complete. Execute handler
        ' body = request.body
        request.b64Body = request.body.ToBase64String()
        ' ' print "  body: "request.body
        m.logs.printl(log_level_Type.VERBOSE, `[YTSABR-Server] Examining Request: {${chr(10)}  state: ${request.state},${chr(10)}  path: ${request.path},${chr(10)}  headers: ${FormatJson(request.headers)},${chr(10)}  method: ${request.method},${chr(10)}  body_size: ${request.body_size},${chr(10)}  search: ${FormatJson(request.search)},${chr(10)}  body: ${request.b64Body}${chr(10)}}`)
        ' Regardless of whether the socket is to be closed, the HTTP request has finished. We have to invalidate it here
        ' since the process_data() call might set up something else
        m.connections[Stri(connection.getID())] = invalid
        should_close = process_request(request, connection, port)
        if should_close then
            m.sockets[Stri(connection.getID())] = invalid
            connection.close()
            m.logs.printl(log_level_Type.INFO, `[YTSABR-Server] finalizing connection close: ${connection.getID()}`)
        end if
    else ' Error condition. Not handled (FIXME! Need to return ints instead of booleans so we have a third case. Or invalid?)
        m.logs.printl(log_level_Type.WARN, `[YTSABR-Server] unrecognized status: ${status}`)
        ' stop
    end if
end sub

function process_request(request as object, connection as object, port as object)
    m.logs.printl(log_level_Type.INFO, `[YTSABR-Server] Processing request: ${request?.path}`)
    ' port = CreateObject("roMessagePort")
    status = invalid
    if request.path.inStr("/sabr/") > -1 then
        m.logs.printl(log_level_Type.INFO, `[YTSABR-Server] Intercepted SABR request: ${request.path}`)

        mediaIdHash = sabr_extractMediaIdHash(request.path)
        if mediaIdHash = invalid then
            m.logs.printl(log_level_Type.WARN, `[YTSABR-Server] Could not extract mediaIdHash from URL: ${request.path} on ${connection.getID()}`)
            status = send_http_reply(connection, "400", "text/plain", "Bad Request - could not extract mediaIdHash")
            return true
        end if

        ' check if we already have this mediaIdHash sabrPayload.json file loaded
        if m.sabrPayloads[mediaIdHash] = invalid then
            ' Load the sabrPayload.json file from tmp:/{mediaIdHash}/sabrPayload.json
            filePath = `tmp:/${mediaIdHash}/sabrPayload.json`
            fileContent = getFile(filePath)
            if fileContent = invalid or fileContent = "" then
                m.logs.printl(log_level_Type.WARN, `[YTSABR-Server] Could not load sabrPayload.json file: ${filePath} on ${connection.getID()}`)
                status = send_http_reply(connection, "500", "text/plain", "Internal Server Error - could not load sabrPayload.json")
                return true
            end if
            ' Parse the JSON content
            sabrPayload = ParseJson(fileContent)
            if sabrPayload = invalid then
                m.logs.printl(log_level_Type.WARN, `[YTSABR-Server] sabrPayload.json file is not valid JSON: ${filePath} on ${connection.getID()}`)
                status = send_http_reply(connection, "500", "text/plain", "Internal Server Error - sabrPayload.json is not valid JSON")
                return true
            end if
            m.sabrPayloads[mediaIdHash] = sabrPayload
            m.logs.printl(log_level_Type.INFO, `[YTSABR-Server-${m.contentType}] Loaded sabrPayload for mediaIdHash: ${mediaIdHash} from ${filePath}`)
        else
            sabrPayload = m.sabrPayloads[mediaIdHash]
            m.logs.printl(log_level_Type.INFO, `[YTSABR-Server-${m.contentType}] Using cached sabrPayload for mediaIdHash: ${mediaIdHash}`)
        end if
        if enqueueFetchRequest(request, connection, mediaIdHash, sabrPayload)
            status = "ASYNC"
        else
            sabrResponse = sabr_handleRequest(request, m.contentType, mediaIdHash, sabrPayload, m.top.videoNode)

            if isValid(sabrResponse)
                responseBody = sabrResponse.body
                if not isValid(responseBody)
                    responseBody = CreateObject("roByteArray")
                end if
                responseHeaders = sabrResponse.headers
                if not isValid(responseHeaders)
                    responseHeaders = CreateObject("roAssociativeArray")
                end if
                statusCode = sabrResponse.status
                if not isValid(statusCode)
                    statusCode = 204
                end if
                if responseHeaders.DoesExist("Content-Length") = false
                    responseHeaders["Content-Length"] = responseBody.count().toStr()
                end if
                if responseHeaders.DoesExist("Content-Type") = false
                    responseHeaders["Content-Type"] = "text/plain"
                end if
                if responseHeaders.DoesExist("Connection") = false
                    responseHeaders["Connection"] = "keep-alive"
                end if
                status = send_http_reply_raw(connection, statusCode, responseHeaders, responseBody)
            else
                status = send_http_reply(connection, "204", "text/plain", "")
            end if
        end if
    else
        m.logs.printl(log_level_Type.WARN, `[YTSABR-Server] Unexpected URI: ${request.path} on ${connection.getID()}`)
    end if

    m.logs.printl(log_level_Type.INFO, `[YTSABR-Server] Status: ${status}`)
    return false ' false = Keep-alive
end function

sub ensureWorkerPool(port as object)
    if not IsArray(m.workerPool)
        m.workerPool = []
    end if
    targetSize = 3
    current = m.workerPool.count()
    while current < targetSize
        worker = CreateObject("roSGNode", "sabrFetchWorkerTask")
        if worker = invalid then exit while
        workerId = `sabrFetchWorker-${m.contentType}-${current}`
        worker.id = workerId
        worker.contentType = m.top.contentType
        if isValid(m.top.utilsTask) then worker.utilsTask = m.top.utilsTask
        if isValid(m.top.videoNode) then worker.videoNode = m.top.videoNode
        if isValid(m.top.debugUploadUrl) then worker.debugUploadUrl = m.top.debugUploadUrl
        worker.requestQueue = []
        worker.fetchEvents = []
        worker.control = "RUN"
        m.workerPool.push(worker)
        state = {
            "status": "idle"
            "fetchId": invalid
        }
        m.workerState[workerId] = state
        current = current + 1
    end while
    dispatchPendingRequests()
end sub

sub dispatchPendingRequests()
    if not IsArray(m.workerPool) then return
    if not IsArray(m.requestQueue) or m.requestQueue.count() = 0 then return
    for each worker in m.workerPool
        workerId = worker.id
        state = m.workerState.Lookup(workerId)
        if not IsAssociativeArray(state) then state = { "status": "idle", "fetchId": invalid }
        if state.status = "busy" then continue for
        if m.requestQueue.count() = 0 then exit for
        entry = m.requestQueue[0]
        m.requestQueue.delete(0)
        startWorkerFetch(worker, entry)
    end for
end sub

sub startWorkerFetch(worker as object, entry as object)
    if worker = invalid then return
    if not IsAssociativeArray(entry) then return

    fetchId = entry.fetchId
    if fetchId = invalid then return

    payload = {
        "fetchId": fetchId
        "request": entry.requestPayload
        "mediaIdHash": entry.mediaIdHash
        "sabrPayload": entry.sabrPayload
        "contentType": entry.contentType
        "debugUploadUrl": m.top.debugUploadUrl
    }

    queuePayload = []
    existingQueue = worker.requestQueue
    if IsArray(existingQueue)
        for each item in existingQueue
            queuePayload.push(item)
        end for
    end if
    queuePayload.push(payload)
    worker.requestQueue = queuePayload
    worker.fetchEvents = []

    workerId = worker.id
    state = {
        "status": "busy"
        "fetchId": fetchId
    }
    m.workerState[workerId] = state

    key = Stri(fetchId)
    entry.workerId = workerId
    m.fetchPending[key] = entry
end sub

function buildRequestSignature(request as object) as string
    if not IsAssociativeArray(request) then return ""
    method = LCase(`${request?.method ?? ""}`)
    path = LCase(`${request?.path ?? ""}`)
    rangeHeader = ""
    headers = request?.headers
    if IsAssociativeArray(headers)
        if headers.DoesExist("Range") then rangeHeader = `${headers.Range}`
        if rangeHeader = "" and headers.DoesExist("range") then rangeHeader = `${headers.range}`
    end if
    searchKey = ""
    search = request?.search
    if IsAssociativeArray(search)
        if search.DoesExist("key") then searchKey = `${search.key}`
    end if
    bodyHash = `${request?.b64Body ?? ""}`
    return `${method}|${path}|${searchKey}|${rangeHeader}|${bodyHash}`
end function

sub processFetchEvent(event as object)
    if not IsAssociativeArray(event) then return
    eventType = LCase(`${event?.type ?? ""}`)
    if eventType = "segment"
        handleFetchSegmentEvent(event)
    else if eventType = "final"
        handleFetchFinalEvent(event)
    else if eventType = "error"
        handleFetchErrorEvent(event)
    else
        m.logs.printl(log_level_Type.DEBUG, `[YTSABR-Server-${m.contentType}] Unrecognized fetch event type ${eventType}`)
    end if
end sub

sub handleFetchSegmentEvent(event as object)
    fetchId = event?.fetchId
    descriptor = event?.response
    key = Stri(fetchId)
    pending = m.fetchPending.Lookup(key)
    if pending = invalid
        cleanupDescriptorFile(descriptor)
        return
    end if

    if pending.workerId = invalid and event?.workerId <> invalid
        pending.workerId = event.workerId
    end if

    errorInfo = descriptor?.error
    if IsAssociativeArray(errorInfo)
        message = errorInfo?.message ?? "SABR request failed"
        deliverErrorToConnection(pending.connection, fetchId, message)
        if IsArray(pending.waiters)
            for i = pending.waiters.count() - 1 to 0 step -1
                deliverErrorToConnection(pending.waiters[i], fetchId, message)
                pending.waiters.delete(i)
            end for
        end if
        cleanupDescriptorFile(descriptor)
        cleanupFetch(fetchId, pending)
        return
    end if

    headers = ensureResponseHeaders(descriptor?.headers)
    statusCode = ensureStatusCode(descriptor?.status)
    body = loadResponseBody(descriptor)
    bodyLength = 0
    if GetInterface(body, "ifByteArray") <> invalid
        bodyLength = body.count()
    end if

    if headers.DoesExist("Content-Length") = false
        headers["Content-Length"] = StrI(bodyLength)
    end if
    if headers.DoesExist("Content-Type") = false
        headers["Content-Type"] = "text/plain"
    end if

    rangeHeader = ""
    if headers.DoesExist("Content-Range") then rangeHeader = headers["Content-Range"]
    m.logs.printl(log_level_Type.INFO, `[YTSABR-Server-${pending.contentType}] Segment response fetch=${fetchId} range=${rangeHeader} bytes=${bodyLength}`)

    pending.segmentStatus = statusCode
    pending.segmentHeaders = headers
    pending.segmentBody = body
    waiterCountBefore = 0
    if IsArray(pending.waiters)
        waiterCountBefore = pending.waiters.count()
    end if
    m.logs.printl(log_level_Type.DEBUG, `[YTSABR-Server-${pending.contentType}] Cached segment fetch=${fetchId} bytes=${bodyLength} waitersWaiting=${waiterCountBefore}`)

    deliverResponseToConnection(pending.connection, fetchId, statusCode, headers, body)
    pending.connection = invalid

    if IsArray(pending.waiters)
        for each waiterConn in pending.waiters
            deliverResponseToConnection(waiterConn, fetchId, statusCode, ensureResponseHeaders(headers), body)
        end for
        pending.waiters = []
    end if

    cleanupDescriptorFile(descriptor)
    pending.delivered = true
    m.fetchPending[key] = pending
end sub

sub handleFetchFinalEvent(event as object)
    fetchId = event?.fetchId
    descriptor = event?.response
    deliveredFlag = event?.deliveredViaCallback = true
    key = Stri(fetchId)
    pending = m.fetchPending.Lookup(key)
    if pending = invalid
        cleanupDescriptorFile(descriptor)
        return
    end if

    connection = pending.connection
    if pending.workerId = invalid and event?.workerId <> invalid
        pending.workerId = event.workerId
    end if

    errorInfo = descriptor?.error
    if IsAssociativeArray(errorInfo)
        message = errorInfo?.message ?? "SABR request failed"
        deliverErrorToConnection(connection, fetchId, message)
        cleanupDescriptorFile(descriptor)
        cleanupFetch(fetchId, pending)
        return
    end if

    headers = ensureResponseHeaders(descriptor?.headers)
    statusCode = ensureStatusCode(descriptor?.status)
    body = loadResponseBody(descriptor)
    bodyLength = 0
    if GetInterface(body, "ifByteArray") <> invalid
        bodyLength = body.count()
    end if
    if headers.DoesExist("Content-Length") = false
        headers["Content-Length"] = StrI(bodyLength)
    end if
    if headers.DoesExist("Content-Type") = false
        headers["Content-Type"] = "text/plain"
    end if

    if deliveredFlag <> true and connection <> invalid
        m.logs.printl(log_level_Type.INFO, `[YTSABR-Server-${pending.contentType}] Final response fetch=${fetchId} via direct send`)
        deliverResponseToConnection(connection, fetchId, statusCode, headers, body)
        connection = invalid
        pending.connection = invalid
    end if

    if deliveredFlag = true
        m.logs.printl(log_level_Type.INFO, `[YTSABR-Server-${pending.contentType}] Final response fetch=${fetchId} already delivered via segment`)
    end if

    if IsArray(pending.waiters) and pending.waiters.count() > 0
        waiterHeaders = headers
        waiterStatus = statusCode
        waiterBody = body
        if deliveredFlag = true and IsAssociativeArray(pending) and GetInterface(pending?.segmentBody, "ifByteArray") <> invalid
            waiterHeaders = ensureResponseHeaders(pending.segmentHeaders)
            waiterStatus = ensureStatusCode(pending.segmentStatus)
            waiterBody = pending.segmentBody
        end if
        waiterCount = pending.waiters.count()
        waiterBytes = 0
        if GetInterface(waiterBody, "ifByteArray") <> invalid
            waiterBytes = waiterBody.count()
        end if
        deliverySource = "final-body"
        if deliveredFlag = true
            deliverySource = "cached-segment"
        end if
        m.logs.printl(log_level_Type.INFO, `[YTSABR-Server-${pending.contentType}] Final fanout fetch=${fetchId} waiters=${waiterCount} bytes=${waiterBytes} source=${deliverySource}`)
        for each waiterConn in pending.waiters
            deliverResponseToConnection(waiterConn, fetchId, waiterStatus, ensureResponseHeaders(waiterHeaders), waiterBody)
        end for
        pending.waiters = []
    end if

    if deliveredFlag <> true
        pending.segmentStatus = statusCode
        pending.segmentHeaders = headers
        pending.segmentBody = body
        stagedBytes = 0
        if GetInterface(body, "ifByteArray") <> invalid
            stagedBytes = body.count()
        end if
        m.logs.printl(log_level_Type.DEBUG, `[YTSABR-Server-${pending.contentType}] Staged final body for fetch=${fetchId} bytes=${stagedBytes}`)
    end if
    pending.delivered = true

    cleanupDescriptorFile(descriptor)
    cleanupFetch(fetchId, pending)
end sub

sub handleFetchErrorEvent(event as object)
    fetchId = event?.fetchId
    key = Stri(fetchId)
    pending = m.fetchPending.Lookup(key)
    errorInfo = event?.error
    message = errorInfo?.message ?? "SABR request failed"
    if pending <> invalid
        connection = pending.connection
        if connection <> invalid
            status = send_http_reply(connection, "500", "text/plain", message)
            removeConnectionMapping(connection)
            m.logs.printl(log_level_Type.INFO, `[YTSABR-Server] Completed fetch ${fetchId} with status ${status}`)
        end if
        cleanupFetch(fetchId, pending)
    else
        m.logs.printl(log_level_Type.WARN, `[YTSABR-Server] Error event for unknown fetch ${fetchId}: ${message}`)
    end if
end sub

sub deliverResponseToConnection(connection as object, fetchId as integer, statusCode as integer, headers as object, body as object)
    if connection = invalid then return
    status = send_http_reply_raw(connection, statusCode, headers, body)
    m.logs.printl(log_level_Type.INFO, `[YTSABR-Server] Completed fetch ${fetchId} with status ${status}`)
    removeConnectionMapping(connection)
end sub

sub deliverErrorToConnection(connection as object, fetchId as integer, message as string)
    if connection = invalid then return
    status = send_http_reply(connection, "500", "text/plain", message)
    m.logs.printl(log_level_Type.WARN, `[YTSABR-Server] Error response for fetch ${fetchId} status=${status} message=${message}`)
    removeConnectionMapping(connection)
end sub

sub removeConnectionMapping(connection as object)
    if connection = invalid then return
    connKey = Stri(connection.getID())
    if m.connectionFetchMap.DoesExist(connKey)
        m.connectionFetchMap.Delete(connKey)
    end if
    if m.sockets.DoesExist(connKey)
        m.sockets[connKey] = invalid
    end if
    if connection.IsConnected()
        connection.close()
    end if
end sub

function loadResponseBody(descriptor as object) as object
    body = CreateObject("roByteArray")
    if not IsAssociativeArray(descriptor) then return body
    bodyPath = descriptor?.bodyPath
    if IsString(bodyPath) and bodyPath <> ""
        ba = CreateObject("roByteArray")
        if ba.readFile(bodyPath)
            return ba
        end if
    end if
    fallback = descriptor?.body
    if GetInterface(fallback, "ifByteArray") <> invalid
        return fallback
    end if
    return body
end function

function ensureResponseHeaders(headers as object) as object
    result = CreateObject("roAssociativeArray")
    if IsAssociativeArray(headers)
        for each key in headers
            result[key] = headers[key]
        end for
    end if
    if result.DoesExist("Connection") = false
        result["Connection"] = "keep-alive"
    end if
    return result
end function

function ensureStatusCode(value as dynamic) as integer
    if IsString(value)
        return Val(value)
    else if IsInteger(value)
        return value
    else
        return 204
    end if
end function

sub cleanupDescriptorFile(descriptor as object)
    if not IsAssociativeArray(descriptor) then return
    bodyPath = descriptor?.bodyPath
    if not IsString(bodyPath) or bodyPath = "" then return
    fs = CreateObject("roFileSystem")
    if fs <> invalid and fs.Exists(bodyPath)
        fs.Delete(bodyPath)
    end if
end sub

function enqueueFetchRequest(request as object, connection as object, mediaIdHash as string, sabrPayload as object) as boolean
    if m.workerPoolEnabled <> true
        m.logs.printl(log_level_Type.DEBUG, `[YTSABR-Server-${m.contentType}] Worker pool disabled; executing request synchronously`)
        return false
    end if
    ensureWorkerPool(m.port)
    if not IsArray(m.workerPool) or m.workerPool.count() = 0 then return false
    if connection = invalid then return false

    requestPayload = serializeRequestForWorker(request)
    if not IsAssociativeArray(requestPayload) then return false

    signature = buildRequestSignature(requestPayload)
    if signature = "" then signature = `sig-${m.fetchSequence}`

    if m.inFlightSignatures.DoesExist(signature)
        existingFetchId = m.inFlightSignatures.Lookup(signature)
        key = Stri(existingFetchId)
        pending = m.fetchPending.Lookup(key)
        if pending <> invalid
            deliveredAlready = pending?.delivered = true
            cachedBody = pending?.segmentBody
            if deliveredAlready and GetInterface(cachedBody, "ifByteArray") <> invalid
                cachedHeaders = ensureResponseHeaders(pending?.segmentHeaders)
                cachedStatus = ensureStatusCode(pending?.segmentStatus)
                deliverResponseToConnection(connection, existingFetchId, cachedStatus, cachedHeaders, cachedBody)
                m.logs.printl(log_level_Type.DEBUG, `[YTSABR-Server-${m.contentType}] Served cached segment for fetch ${existingFetchId} signature=${signature}`)
                return true
            end if
            if not IsArray(pending.waiters)
                pending.waiters = []
            end if
            pending.waiters.push(connection)
            connKeyWait = Stri(connection.getID())
            m.connectionFetchMap[connKeyWait] = existingFetchId
            m.fetchPending[key] = pending
            m.logs.printl(log_level_Type.DEBUG, `[YTSABR-Server-${m.contentType}] Attached waiter to fetch ${existingFetchId} signature=${signature}`)
            return true
        else
            m.inFlightSignatures.Delete(signature)
        end if
    end if

    fetchId = m.fetchSequence + 1
    m.fetchSequence = fetchId

    entry = {
        "fetchId": fetchId
        "connection": connection
        "waiters": []
        "requestPayload": requestPayload
        "mediaIdHash": mediaIdHash
        "sabrPayload": sabrPayload
        "contentType": m.contentType
        "delivered": false
        "signature": signature
        "workerId": invalid
    }

    key = Stri(fetchId)
    m.fetchPending[key] = entry
    connKey = Stri(connection.getID())
    m.connectionFetchMap[connKey] = fetchId
    if signature <> ""
        m.inFlightSignatures[signature] = fetchId
    end if

    if not IsArray(m.requestQueue)
        m.requestQueue = []
    end if
    m.requestQueue.push(entry)
    dispatchPendingRequests()
    m.logs.printl(log_level_Type.DEBUG, `[YTSABR-Server-${m.contentType}] Queued fetch ${fetchId} signature=${signature}`)
    return true
end function

function serializeRequestForWorker(request as object) as object
    if not IsAssociativeArray(request) then return invalid

    headers = CreateObject("roAssociativeArray")
    if IsAssociativeArray(request.headers)
        for each headerKey in request.headers
            headers[headerKey] = request.headers[headerKey]
        end for
    end if

    searchParams = CreateObject("roAssociativeArray")
    if IsAssociativeArray(request.search)
        for each paramKey in request.search
            searchParams[paramKey] = request.search[paramKey]
        end for
    end if

    payload = {
        "path": request.path
        "method": request.method
        "headers": headers
        "search": searchParams
        "bodySize": request.body_size
        "b64Body": request.b64Body
    }
    return payload
end function


sub cleanupFetch(fetchId as integer, pending as object)
    key = Stri(fetchId)
    if pending = invalid and m.fetchPending.DoesExist(key)
        pending = m.fetchPending.Lookup(key)
    end if

    signature = pending?.signature
    if signature <> "" and m.inFlightSignatures.DoesExist(signature)
        m.inFlightSignatures.Delete(signature)
    end if

    if m.fetchPending.DoesExist(key)
        m.fetchPending.Delete(key)
    end if

    if IsArray(pending?.waiters)
        for each conn in pending.waiters
            if conn <> invalid
                removeConnectionMapping(conn)
            end if
        end for
    end if

    connection = pending?.connection
    if connection <> invalid
        removeConnectionMapping(connection)
    end if

    workerId = pending?.workerId
    if workerId <> invalid and m.workerState.DoesExist(workerId)
        state = m.workerState.Lookup(workerId)
        state.status = "idle"
        state.fetchId = invalid
        m.workerState[workerId] = state
    end if

    dispatchPendingRequests()
end sub

sub cancelPendingFetchForConnection(connection as object)
    if connection = invalid then return
    connKey = Stri(connection.getID())
    if not m.connectionFetchMap.DoesExist(connKey) then return
    fetchId = m.connectionFetchMap.Lookup(connKey)
    key = Stri(fetchId)
    pending = m.fetchPending.Lookup(key)
    if pending <> invalid
        if isValid(pending.connection) and connection.getId() = pending.connection.getId()
            pending.connection = invalid
        else if IsArray(pending.waiters)
            newWaiters = []
            for each waiterConn in pending.waiters
                if waiterConn.GetID() <> connection.GetID() then newWaiters.push(waiterConn)
            end for
            pending.waiters = newWaiters
        end if
        m.fetchPending[key] = pending
    end if
    removeConnectionMapping(connection)
    m.logs.printl(log_level_Type.INFO, `[YTSABR-Server] Cancelled pending fetch ${fetchId} for closed connection ${connKey}`)
end sub
