import "pkg:/source/logger.bs"
import "pkg:/source/taskUtils.bs"
import "pkg:/source/SabrUtils.bs"

sub init()
    m.top.functionName = "messageHandlers"
    m.port = CreateObject("roMessagePort")
    m.top.ObserveField("LOAD_FILE_TO_STRING", m.port)
    ' m.top.ObserveField("CACHE_STRING_TO_FILE", m.port)
    m.nextRequestId = {}
    m.sabrSharedState = {}
    m.logs = logger()
end sub

sub messageHandlers()
    timespan = m.logs.mark()
    while true
        msg = wait(0, m.port)
        if type(msg) = "roSGNodeEvent"
            field = msg.GetField()
            if field = "LOAD_FILE_TO_STRING"
                loadFileToString(msg)
            ' else if field = "CACHE_STRING_TO_FILE"
            '     cacheStringToFile(msg)
            end if
        end if
    end while
end sub

' Returns a monotonically increasing counter per group at the utilsTask level.
' Use this when you need IDs shared across both audio/video server tasks,
' instead of the task-local globalAA-based counters. It may add some latency
' due to cross-task messaging, so I decided to use a globalAA-based approach until
' we had a use case that requires a cross-task counter.
function getNextId(group as string) as integer
    if not m.nextRequestId.DoesExist(group)
        m.nextRequestId[group] = 0
    end if
    m.nextRequestId[group] = m.nextRequestId[group] + 1
    return m.nextRequestId[group]
end function

function sabrSharedKey(mediaIdHash as string, scopeKey as string) as string
    safeHash = sabr_toSafeString(mediaIdHash)
    safeScope = sabr_toSafeString(scopeKey)
    if safeScope = "" then safeScope = "root"
    return `${safeHash}|${safeScope}`
end function

function sabrSharedGet(params as object) as object
    mediaIdHash = sabr_toSafeString(params?.mediaIdHash)
    scopeKey = sabr_toSafeString(params?.scopeKey)
    if scopeKey = "" then scopeKey = "root"
    key = sabrSharedKey(mediaIdHash, scopeKey)
    entry = m.sabrSharedState.Lookup(key)
    if IsAssociativeArray(entry) then return entry
    return {}
end function

function sabrSharedUpdate(params as object) as object
    if not IsAssociativeArray(params) then return {}
    mediaIdHash = sabr_toSafeString(params?.mediaIdHash)
    scopeKey = sabr_toSafeString(params?.scopeKey)
    updates = params.Lookup("updates")
    if scopeKey = "" then scopeKey = "root"
    if mediaIdHash = "" or not IsAssociativeArray(updates) then return sabrSharedGet({"mediaIdHash": mediaIdHash, "scopeKey": scopeKey})
    key = sabrSharedKey(mediaIdHash, scopeKey)
    current = m.sabrSharedState.Lookup(key)
    if not IsAssociativeArray(current) then current = {}
    for each k in updates.Keys()
        current[k] = updates.Lookup(k)
    end for
    m.sabrSharedState[key] = current
    return current
end function

function sabrSharedSeedFromPayload(params as object) as object
    mediaIdHash = sabr_toSafeString(params?.mediaIdHash)
    scopeKey = sabr_toSafeString(params?.scopeKey)
    payload = params?.payload
    if scopeKey = "" then scopeKey = "root"
    if mediaIdHash = "" or not IsAssociativeArray(payload)
        return sabrSharedGet({"mediaIdHash": mediaIdHash, "scopeKey": scopeKey})
    end if
    existing = sabrSharedGet({"mediaIdHash": mediaIdHash, "scopeKey": scopeKey})
    toSet = {}

    if sabr_toSafeString(existing.Lookup("serverAbrStreamingUrl")) = ""
        url = sabr_toSafeString(payload.Lookup("serverAbrStreamingUrl"))
        if url = "" and IsAssociativeArray(payload?.serverAbrStreamingEndpoint)
            url = sabr_toSafeString(payload.serverAbrStreamingEndpoint.Lookup("url"))
        end if
        if url <> "" then toSet["serverAbrStreamingUrl"] = url
    end if

    if not IsValid(existing.Lookup("playbackCookie"))
        cookieVal = payload.Lookup("playbackCookie")
        if isValid(cookieVal) then toSet["playbackCookie"] = cookieVal
    end if

    if not IsValid(existing.Lookup("videoPlaybackUstreamerConfig"))
        cfgVal = payload.Lookup("ustreamerConfig")
        if not isValid(cfgVal) then cfgVal = payload.Lookup("videoPlaybackUstreamerConfig")
        if isValid(cfgVal) then toSet["videoPlaybackUstreamerConfig"] = cfgVal
    end if

    if sabr_toSafeString(existing.Lookup("poToken")) = ""
        poVal = sabr_toSafeString(payload.Lookup("poToken"))
        if poVal <> "" then toSet["poToken"] = poVal
    end if

    if toSet.Count() = 0 then return existing
    return sabrSharedUpdate({
        "mediaIdHash": mediaIdHash
        "scopeKey": scopeKey
        "updates": toSet
    })
end function

sub sendUIMessage(message as object)
    m.top.uiMessage = message
end sub

sub loadFileToString(msg as object)
    path = msg.getData()
    
    m.logs.printl(log_level_Type.INFO, `[LOAD_FILE_TO_STRING] Starting string cache write: ${path}`)

    fileSystem = CreateObject("roFileSystem")

    byteArray = CreateObject("roByteArray")
    byteArray.readFile(path)
    result = byteArray.ToAsciiString()

    m.logs.printl(log_level_Type.INFO, `[LOAD_FILE_TO_STRING] String cache write result: ${result.len()} bytes`)

    sendUIMessage({ "type": "FILE_LOADED_TO_STRING", "fileData": result })

end sub

' sub cacheStringToFile(msg as object)
'     params = msg.getData()
'     content = params.content
'     path = params.path
'     result = { "status": "error", "message": "", "uri": invalid }

'     m.logs.printl(log_level_Type.INFO, `[CACHE_STRING_TO_FILE] Starting string cache write: ${path}`)

'     fileSystem = CreateObject("roFileSystem")

'     ' handle if the the path includes a directory that doesn't yet exist
'     volumeIndex = Instr(1, path, ":")
'     searchPos = 1
'     while true
'         slashPos = Instr(searchPos, path, "/")
'         if slashPos = 0 then exit while

'         if volumeIndex > 0 and slashPos <= volumeIndex + 1
'             searchPos = slashPos + 1
'             continue while
'         end if

'         dirPath = Left(path, slashPos - 1)
'         if dirPath <> "" and fileSystem.Exists(dirPath) <> true
'             fileSystem.CreateDirectory(dirPath)
'         end if

'         searchPos = slashPos + 1
'     end while

'     if writeFile(path, content)
'         result["status"] = "ok"
'         result["uri"] = path
'     else
'         result["message"] = `[cacheStringToFile] Failed to write string file: ${path}`
'     end if

'     m.logs.printl(log_level_Type.INFO, `[CACHE_STRING_TO_FILE] String cache write result: ${FormatJson(result)}`)

'     sendUIMessage({ "type": "CACHED_STRING_TO_FILE", "result": result })

' end sub
