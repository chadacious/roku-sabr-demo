import "pkg:/source/logger.bs"
import "pkg:/source/taskUtils.bs"

sub init()
    m.top.functionName = "messageHandlers"
    m.port = CreateObject("roMessagePort")
    m.top.ObserveField("LOAD_FILE_TO_STRING", m.port)
    m.top.ObserveField("CACHE_STRING_TO_FILE", m.port)
    m.nextRequestId = {}
    m.sidxIndexCache = {}
    m.playbackContextByMediaId = {}
    m.sabrPayloadByMediaId = {}
    m.logs = logger()
end sub

sub messageHandlers()
    timespan = m.logs.mark()
    while true
        msg = wait(0, m.port)
        if type(msg) = "roSGNodeEvent"
            field = msg.GetField()
            if field = "LOAD_FILE_TO_STRING"
                loadFileToString(msg)
            else if field = "CACHE_STRING_TO_FILE"
                cacheStringToFile(msg)
            end if
        end if
    end while
end sub

function profilerStore() as object
    if not IsAssociativeArray(m?.profilerStats)
        m.profilerStats = {}
    end if
    return m.profilerStats
end function

function profilerStart(label as string, thresholdMs = 5 as integer) as object
    timer = invalid
    if isValid(m?.logs)
        timer = m.logs.mark()
    else
        timer = CreateObject("roTimespan")
        timer.mark()
    end if
    return {
        "label": label
        "timer": timer
        "thresholdMs": thresholdMs
    }
end function

function profilerEnsureEntry(label as string) as object
    store = profilerStore()
    entry = store.Lookup(label)
    if not IsAssociativeArray(entry)
        entry = {
            "count": 0
            "totalMs": 0
            "maxMs": 0
            "minMs": -1
            "slowCount": 0
            "lastMs": 0
        }
    end if
    return entry
end function

sub profilerStop(mark as object)
    if mark = invalid then return
    timer = mark?.timer
    if timer = invalid then return
    durationVal = timer.TotalMilliseconds()
    durationMs = int(durationVal + 0.5)
    if durationMs < 0 then durationMs = 0

    entry = profilerEnsureEntry(mark.label)
    entry.count = entry.count + 1
    entry.totalMs = entry.totalMs + durationMs
    if durationMs > entry.maxMs then entry.maxMs = durationMs
    if entry.minMs < 0 or durationMs < entry.minMs then entry.minMs = durationMs
    if durationMs >= mark.thresholdMs
        entry.slowCount = entry.slowCount + 1
        if isValid(m?.logs)
            m.logs.printl(log_level_Type.DEBUG, `[UtilsTaskProfiler] ${mark.label} duration=${durationMs}ms`)
        end if
    end if
    entry.lastMs = durationMs

    store = profilerStore()
    store[mark.label] = entry
end sub

function profilerSnapshot() as object
    store = profilerStore()
    snapshot = {}
    for each label in store
        entry = store[label]
        if not IsAssociativeArray(entry) then continue for
        snapshot[label] = {
            "count": entry.count
            "totalMs": entry.totalMs
            "maxMs": entry.maxMs
            "minMs": entry.minMs
            "slowCount": entry.slowCount
            "lastMs": entry.lastMs
        }
    end for
    return snapshot
end function

sub resetProfilerStats()
    m.profilerStats = {}
end sub

function getProfilerStats() as object
    return profilerSnapshot()
end function

function getNextId(group as string) as integer
    profiler = profilerStart("utilsTask.getNextId")
    if not m.nextRequestId.DoesExist(group)
        m.nextRequestId[group] = 0
    end if
    m.nextRequestId[group] = m.nextRequestId[group] + 1
    result = m.nextRequestId[group]
    profilerStop(profiler)
    return result
end function

function getSidxIndexMap() as object
    profiler = profilerStart("utilsTask.getSidxIndexMap")
    if not IsAssociativeArray(m.sidxIndexCache)
        m.sidxIndexCache = {}
    end if
    result = m.sidxIndexCache
    profilerStop(profiler)
    return result
end function

function mergeSidxIndexMap(incoming as dynamic) as object
    profiler = profilerStart("utilsTask.mergeSidxIndexMap")
    if not IsAssociativeArray(m.sidxIndexCache)
        m.sidxIndexCache = {}
    end if
    if IsAssociativeArray(incoming)
        for each key in incoming
            m.sidxIndexCache[key] = incoming[key]
        end for
    end if
    result = m.sidxIndexCache
    profilerStop(profiler)
    return result
end function

sub clearSidxIndexMap()
    profiler = profilerStart("utilsTask.clearSidxIndexMap")
    m.sidxIndexCache = {}
    profilerStop(profiler)
end sub

function getPlaybackContext(mediaIdHash as string) as dynamic
    profiler = profilerStart("utilsTask.getPlaybackContext")
    if not isValid(mediaIdHash) or mediaIdHash = ""
        profilerStop(profiler)
        return invalid
    end if
    if not IsAssociativeArray(m.playbackContextByMediaId)
        m.playbackContextByMediaId = {}
    end if
    result = m.playbackContextByMediaId.Lookup(mediaIdHash)
    profilerStop(profiler)
    return result
end function

function setPlaybackContext(mediaIdHash as string, context as dynamic) as dynamic
    profiler = profilerStart("utilsTask.setPlaybackContext")
    if not IsAssociativeArray(m.playbackContextByMediaId)
        m.playbackContextByMediaId = {}
    end if
    result = invalid
    if not isValid(mediaIdHash) or mediaIdHash = ""
        profilerStop(profiler)
        return result
    end if
    if not IsAssociativeArray(context)
        if m.playbackContextByMediaId.DoesExist(mediaIdHash)
            m.playbackContextByMediaId.Delete(mediaIdHash)
        end if
        profilerStop(profiler)
        return result
    end if
    m.playbackContextByMediaId[mediaIdHash] = context
    result = context
    profilerStop(profiler)
    return result
end function

function getSabrPayload(mediaIdHash as string) as dynamic
    profiler = profilerStart("utilsTask.getSabrPayload")
    if not isValid(mediaIdHash) or mediaIdHash = ""
        profilerStop(profiler)
        return invalid
    end if
    if not IsAssociativeArray(m.sabrPayloadByMediaId)
        m.sabrPayloadByMediaId = {}
    end if
    result = m.sabrPayloadByMediaId.Lookup(mediaIdHash)
    profilerStop(profiler)
    return result
end function

function setSabrPayload(mediaIdHash as string, payload as dynamic) as dynamic
    profiler = profilerStart("utilsTask.setSabrPayload")
    if not IsAssociativeArray(m.sabrPayloadByMediaId)
        m.sabrPayloadByMediaId = {}
    end if
    result = invalid
    if not isValid(mediaIdHash) or mediaIdHash = ""
        profilerStop(profiler)
        return result
    end if
    normalized = payload
    if IsString(normalized)
        trimmed = normalized.Trim()
        if trimmed <> ""
            parsed = invalid
            parseError = false
            try
                parsed = ParseJson(trimmed)
            catch e
                parseError = true
            end try
            if parsed <> invalid
                normalized = parsed
            else if parseError
                if isValid(m?.logs)
                    m.logs.printl(log_level_Type.WARN, `[UtilsTask] Failed to parse SABR payload JSON for mediaIdHash=${mediaIdHash}`)
                end if
                normalized = invalid
            end if
        else
            normalized = invalid
        end if
    end if
    if not isValid(normalized)
        if m.sabrPayloadByMediaId.DoesExist(mediaIdHash)
            m.sabrPayloadByMediaId.Delete(mediaIdHash)
        end if
        profilerStop(profiler)
        return result
    end if
    m.sabrPayloadByMediaId[mediaIdHash] = normalized
    result = normalized
    profilerStop(profiler)
    return result
end function

sub clearPlaybackContext(mediaIdHash as string)
    profiler = profilerStart("utilsTask.clearPlaybackContext")
    if not IsAssociativeArray(m.playbackContextByMediaId)
        profilerStop(profiler)
        return
    end if
    if m.playbackContextByMediaId.DoesExist(mediaIdHash)
        m.playbackContextByMediaId.Delete(mediaIdHash)
    end if
    profilerStop(profiler)
end sub

sub sendUIMessage(message as object)
    m.top.uiMessage = message
end sub

sub loadFileToString(msg as object)
    path = msg.getData()
    
    m.logs.printl(log_level_Type.INFO, `[LOAD_FILE_TO_STRING] Starting string cache write: ${path}`)

    fileSystem = CreateObject("roFileSystem")

    byteArray = CreateObject("roByteArray")
    byteArray.readFile(path)
    result = byteArray.ToAsciiString()

    m.logs.printl(log_level_Type.INFO, `[LOAD_FILE_TO_STRING] String cache write result: ${result.len()} bytes`)

    sendUIMessage({ "type": "FILE_LOADED_TO_STRING", "fileData": result })

end sub

sub cacheStringToFile(msg as object)
    params = msg.getData()
    content = params.content
    path = params.path
    result = { "status": "error", "message": "", "uri": invalid }

    m.logs.printl(log_level_Type.INFO, `[CACHE_STRING_TO_FILE] Starting string cache write: ${path}`)

    fileSystem = CreateObject("roFileSystem")

    ' handle if the the path includes a directory that doesn't yet exist
    dirPath = path
    lastSlash = 0
    searchPos = 1
    while true
        slashPos = Instr(searchPos, dirPath, "/")
        if slashPos = 0 then exit while
        lastSlash = slashPos
        searchPos = slashPos + 1
    end while

    if lastSlash > 0
        dirPath = Left(dirPath, lastSlash - 1)
        if not fileSystem.Exists(dirPath)
            fileSystem.CreateDirectory(dirPath)
        end if
    end if

    if writeFile(path, content)
        result["status"] = "ok"
        result["uri"] = path
    else
        result["message"] = `[cacheStringToFile] Failed to write string file: ${path}`
    end if

    m.logs.printl(log_level_Type.INFO, `[CACHE_STRING_TO_FILE] String cache write result: ${FormatJson(result)}`)

    sendUIMessage({ "type": "CACHED_STRING_TO_FILE", "result": result })

end sub
