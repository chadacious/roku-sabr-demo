import "pkg:/source/isItem.bs"

function http_sanitizePathPart(value as string) as string
    if not IsString(value) then value = ""
    cleaned = ""
    total = Len(value)
    for i = 1 to total
        ch = Mid(value, i, 1)
        ascii = Asc(ch)
        isDigit = ascii >= 48 and ascii <= 57
        isLower = ascii >= 97 and ascii <= 122
        isUpper = ascii >= 65 and ascii <= 90
        if isDigit or isLower or isUpper
            cleaned = cleaned + LCase(ch)
        else if ch = "-" or ch = "_"
            cleaned = cleaned + ch
        end if
    end for
    if cleaned = "" then cleaned = "segment"
    return cleaned
end function

function http_hexPreview(data as object, limit as integer) as string
    if GetInterface(data, "ifByteArray") = invalid then return ""
    total = data.Count()
    if limit > total then limit = total
    if limit <= 0 then return ""
    digits = "0123456789abcdef"
    preview = ""
    for i = 0 to limit - 1
        byteVal = data[i]
        hi = byteVal \ 16
        lo = byteVal Mod 16
        if hi > 15 then hi = 15
        if hi < 0 then hi = 0
        if lo > 15 then lo = 15
        if lo < 0 then lo = 0
        hexPair = Mid(digits, hi + 1, 1) + Mid(digits, lo + 1, 1)
        if preview <> "" then preview = preview + " "
        preview = preview + hexPair
    end for
    return preview
end function

function create_new_request()
    return { "state": 0
        "headers": {}
        "method": ""
        "body_size": 0
        "search": {}
        "read_data": read_http
        "pathBytes": createobject("roByteArray")
        "buffer": createobject("roByteArray")
        "body": createobject("roByteArray")
    }
end function

function read_http(request as object, connection as object)
    length = connection.getCountRcvBuf()
    if length <= 0 then return false
    'print "Processing message on socket: " ; connection.getID() ; " of length " ; length
    if request.state < 6 or request.body_handler <> invalid then
        request.buffer[length - 1] = 0
        ' request.buffer[length - 1] = invalid
        r = connection.receive(request.buffer, 0, length)
    else
        request.body[request.content_length - 1] = 0
        ' request.body[request.content_length - 1] = invalid
        r = connection.receive(request.body, request.body_size, length)
        request.body_size = request.body_size + length
    end if

    ' Great. No switch statements
    if request.state = 0 then
        parse_http_method(connection, request)
    else if request.state = 1 then
        parse_http_path(connection, request)
    else if request.state = 2 then
        parse_http_search(connection, request)
    else if request.state = 3 then
        parse_http_version(connection, request)
    else if request.state = 4 then
        parse_http_headers(connection, request)
    else if request.state = 5 then
        parse_http_headers(connection, request)
    else if request.state = 6 then
        parse_http_body(connection, request)
    end if
    'print "Final state is " ; request.state
    return request.state = 7
end function


function parse_http_body(connection as object, request as object)
    if request.body_handler <> invalid then
        return request.body_handler(request, connection)
    end if
    while request.buffer.Count() > 0
        request.body.Push(request.buffer.Shift())
        request.body_size = request.body_size + 1
    end while
    if request.body_size >= request.content_length then
        request.state = 7
    end if
end function

function parse_http_headers(connection as object, request as object)
    while request.buffer.Count() > 0 and request.state < 5
        if request.state = 4 then
            ' From 4, either go to 5 or 6
            parse_http_header_name(connection, request)
        end if
        if request.state = 5 then
            ' From 5 always go to 4
            parse_http_header_value(connection, request)
        end if
    end while
end function

function parse_http_header_name(connection as object, request as object)
    while request.buffer.Count() > 0
        code = request.buffer.Shift()
        if code = 13 then
            ' Do nothing
        else if code = 10 then
            ' Must be end of headers
            request.state = 6
            if request.headers["content-length"] <> invalid then
                request.content_length = val(request.headers["content-length"])
            else
                request.content_length = 0
            end if
            parse_http_body(connection, request)
            exit while
        else if code = 58 then
            ' End of header name
            request.headerValue = createobject("roByteArray")
            ' trim header name
            while request.headerName[0] = 32
                request.headerName.Shift()
            end while
            while request.headerName.Peek() = 32
                request.headerName.Pop()
            end while
            request.state = 5
            exit while
        else
            request.headerName.Push(code)
        end if
    end while
end function

function parse_http_header_value(connection as object, request as object)
    while request.buffer.Count() > 0
        code = request.buffer.Shift()
        if code = 13 then
            ' Do nothing
        else if code = 10 then
            ' End of header value
            header_name = Lcase(request.headerName.toAsciiString())
            while request.headerValue[0] = 32
                request.headerValue.Shift()
            end while

            header_value = request.headerValue.toAsciiString()
            request.headers[header_name] = header_value
            ' Reset header name
            request.headerName = createobject("roByteArray")
            request.state = 4
            exit while
        else
            request.headerValue.Push(code)
        end if
    end while
end function


function parse_http_version(connection as object, request as object)
    while request.buffer.Count() > 0
        code = request.buffer.Shift()
        if code = 10 then
            request.state = 4
            request.headerName = createobject("roByteArray")
            parse_http_headers(connection, request)
            exit while
        end if
    end while
end function

function parse_http_path(connection as object, request as object)
    while request.buffer.Count() > 0
        code = request.buffer.Shift()
        if code = 63 then
            request.path = request.pathBytes.toAsciiString()
            request.state = 2
            request.search_bytes = createobject("roByteArray")
            parse_http_search(connection, request)
            exit while
        else if code = 32 then
            request.path = request.pathBytes.toAsciiString()
            request.state = 3
            parse_http_version(connection, request)
            exit while
        end if
        request.pathBytes.Push(code)
    end while
end function

function parse_http_method(connection as object, request as object)
    while request.buffer.Count() > 0
        code = request.buffer.Shift()
        if code = 32 then
            request.state = 1
            parse_http_path(connection, request)
            exit while
        end if
        request.method = request.method + Lcase(chr(code))
    end while
end function

function parse_http_search(connection as object, request as object)
    while request.buffer.Count() > 0
        code = request.buffer.Shift()
        if code = 32 then
            munge_search(request)
            request.state = 3
            parse_http_version(connection, request)
            exit while
        end if
        request.search_bytes.push(code)
    end while
end function

sub munge_search(request as object)
    name_bytes = createobject("roByteArray")
    name = invalid
    For each code in request.search_bytes
        if code = 61 then '=
            name = name_bytes.toAsciiString()
            name_bytes = createobject("roByteArray")
        else if code = 38 then '&
            if name = invalid then
                request.search[name_bytes.toAsciiString()] = ""
            else
                request.search[name] = name_bytes.toAsciiString()
            end if
            name_bytes = createobject("roByteArray")
        else
            name_bytes.Push(code)
        end if
    end for
    if name_bytes.count() > 0 then
        if name = invalid then
            request.search[name_bytes.toAsciiString()] = ""
        else
            request.search[name] = name_bytes.toAsciiString()
        end if
    end if
end sub

function parse_url(s as string)
    url = { "path": "/"
        "hostname": ""
        "port": 0
        "protocol": ""
    }
    bytes = createobject("roByteArray")
    bytes.fromAsciiString(s)
    state = 0
    For each byte in bytes
        if state = 0 then
            if byte = 58 then
                state = 1
            else
                url.protocol = url.protocol + chr(byte)
            end if
        else if state = 1 then '/
            state = 2
        else if state = 2 then '/
            state = 3
        else if state = 3 then
            if byte = 47 then
                url.port = 80
                state = 5
            else if byte = 58 then
                state = 4
            else
                url.hostname = url.hostname + chr(byte)
            end if
        else if state = 4 then
            if byte = 47 then
                state = 5
            else
                url.port = 10 * url.port + val(chr(byte))
            end if
        else if state = 5 then
            url.path = url.path + chr(byte)
        end if
    end for
    return url
end function

'We have a central loop that JUST read http requests
'We have a list of (socket,request) pairs. Only once a request has been fully read do we actually dispatch it
'Until then, each time a socket is ready for reading, tell the request-parser to read some more data from the socket
'The request-parser then has to remember exactly what state is was in. There are only a few states:
'0) Method
'1) Path
'2) Search
'3) HTTP version
'4) Header name
'5) Header value
'6) Data

' ***************************************************
' Handle building responses Below here
' ***************************************************

function pad_integer(source as integer)
    if source < 10 then
        return "0" + right(str(source), 1)
    else
        return right(str(source), 2)
    end if
end function

function send_http_reply(connection as object, response_code as string, content_type as string, textData = "" as string, b64Data = "" as string)
    loggers = logger()
    reply = createobject("roByteArray")
    data = createobject("roByteArray")
    if textData <> "" then
        data.FromAsciiString(textData)
    else if b64Data <> "" then
        ' If we have base64 data, decode it
        data.FromBase64String(b64Data)
    end if
    date = createobject("roDateTime")
    months = ["placeholder"
        "Jan"
        "Feb"
        "Mar"
        "Apr"
        "May"
        "Jun"
        "Jul"
        "Aug"
        "Sep"
        "Oct"
        "Nov"
    "Dec"]
    month_name = months[date.getMonth()]
    ' WHY does str(6) return " 6" ?!
    rfc822 = Left(date.GetWeekday(), 3) + ", " + pad_integer(date.GetDayOfMonth()) + " " + month_name + " " + right(str(date.getYear()), 4) + " " + pad_integer(date.getHours()) + ":" + pad_integer(date.getMinutes()) + ":" + pad_integer(date.getSeconds()) + " GMT"
    packet = "HTTP/1.1 " + response_code + " OK" + chr(13) + chr(10)
    packet = packet + "Date: " + rfc822 + chr(13) + chr(10)
    packet = packet + "Content-Type: " + content_type + chr(13) + chr(10)
    packet = packet + "Content-Length: " + str(data.Count()) + chr(13) + chr(10)
    loggers.printl(log_level_Type.VERBOSE, "Preparing to HTTP reply with:" + chr(13) + chr(10) + packet + chr(13) + chr(10) + b64Data.left(100))
    reply.fromAsciiString(packet + chr(13) + chr(10))
    reply.append(data)
    loggers.printl(log_level_Type.VERBOSE, "Entire response size: " + str(reply.count()))
    status = connection.send(reply, 0, reply.Count())
    loggers.printl(log_level_Type.VERBOSE, "sent status: " + str(status))
    return status
end function

function send_http_reply_raw(connection as object, response_code as integer, headers as object, data, port = invalid)
    loggers = logger()
    reply = createobject("roByteArray")

    rangeHeader = invalid
    itagHeader = invalid
    if GetInterface(data, "ifByteArray") = invalid
        if IsString(data)
            tmpBytes = CreateObject("roByteArray")
            tmpBytes.FromAsciiString(data)
            data = tmpBytes
        else
            data = CreateObject("roByteArray")
        end if
    end if

    ' date = createobject("roDateTime")
    ' months = ["placeholder", "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    ' month_name = months[date.getMonth()]
    ' ' WHY does str(6) return " 6" ?!
    ' rfc822 = Left(date.GetWeekday(), 3) + ", " + pad_integer(date.GetDayOfMonth()) + " " + month_name + " " + right(str(date.getYear()), 4) + " " + pad_integer(date.getHours()) + ":" + pad_integer(date.getMinutes()) + ":" + pad_integer(date.getSeconds()) + " GMT"
    ' if response_code = 206 then response_code = 200
    resStatus = ""
    if response_code = 200
        resStatus = "OK"
    else if response_code = 206
        resStatus = "Partial Content"
    else if response_code = 404
        resStatus = "Not Found"
    else
        resStatus = "Unknown"
    end if

    packet = `HTTP/1.1 ${response_code} ${resStatus}${chr(13)}${chr(10)}`
    ' packet = `${packet}Date: ${rfc822}${chr(13)}${chr(10)}`
    for each key in headers.keys()
        ' if findIndex(["accept-ranges"], lCase(key)) = -1
        packet = `${packet}${key}: ${headers[key]}${chr(13)}${chr(10)}`
        ' end if
    next
    if IsAssociativeArray(headers)
        rangeHeader = headers.Lookup("Content-Range")
        if not isValid(rangeHeader) then rangeHeader = headers.Lookup("content-range")
        if not isValid(rangeHeader)
            rangeHeader = headers.Lookup("X-Cache-Range")
        end if
        itagHeader = headers.Lookup("X-Cache-Itag")
        if not isValid(itagHeader) then itagHeader = headers.Lookup("x-cache-itag")
        if not isValid(itagHeader)
            itagHeader = headers.Lookup("X-Stream-Itag")
        end if
        if isValid(rangeHeader)
            if isValid(itagHeader) and itagHeader <> ""
                loggers.printl(log_level_Type.INFO, `[HTTP] Reply itag=${itagHeader} range=${rangeHeader} status=${response_code} length=${data.Count()}`)
            else
                loggers.printl(log_level_Type.INFO, `[HTTP] Reply range=${rangeHeader} status=${response_code} length=${data.Count()}`)
            end if
        end if
    end if

    if GetInterface(data, "ifByteArray") <> invalid and data.Count() > 0
        safeItag = "itag"
        itagLabel = ""
        if isValid(itagHeader) and itagHeader <> ""
            itagLabel = `${itagHeader}`
            safeItag = http_sanitizePathPart(itagLabel)
        end if
        safeRangeStart = "start"
        safeRangeEnd = "end"
        rangeLabel = ""
        if isValid(rangeHeader) and rangeHeader <> ""
            rangeLabel = `${rangeHeader}`
            rangeParts = rangeLabel.Split(" ")
            rangeCore = rangeParts.count() > 1 ? rangeParts[1] : rangeParts[0]
            slashParts = rangeCore.Split("/")
            spanPart = slashParts[0]
            spanPart = spanPart.Trim()
            if Len(spanPart) >= 5 and LCase(Left(spanPart, 5)) = "bytes"
                spanPart = Mid(spanPart, 6).Trim()
            end if
            dashParts = spanPart.Split("-")
            if dashParts.count() > 0 and dashParts[0] <> ""
                safeRangeStart = http_sanitizePathPart(`${dashParts[0]}`)
            end if
            if dashParts.count() > 1 and dashParts[1] <> ""
                safeRangeEnd = http_sanitizePathPart(`${dashParts[1]}`)
            end if
        end if
        dt = CreateObject("roDateTime")
        timestamp = StrI(dt.AsSeconds())
        fs = CreateObject("roFileSystem")
        if fs <> invalid
            dumpDir = "tmp:/http-replies"
            if not fs.Exists(dumpDir)
                fs.CreateDirectory(dumpDir)
            end if
            fileName = `http-${safeItag}-${safeRangeStart}-${safeRangeEnd}-${timestamp}.bin`
            dumpPath = `${dumpDir}/${fileName}`
            if data.writeFile(dumpPath)
                loggers.printl(log_level_Type.INFO, `[HTTP] Saved reply body to ${dumpPath}`)
            else
                loggers.printl(log_level_Type.WARN, `[HTTP] Failed to save reply body to ${dumpPath}`)
            end if
        end if
        previewHex = http_hexPreview(data, 32)
        if previewHex <> ""
            loggers.printl(log_level_Type.DEBUG, `[HTTP] Reply preview itag=${itagLabel} range=${rangeLabel} hex=${previewHex}`)
        end if
    end if
    loggers.printl(log_level_Type.INFO, `Preparing to HTTP reply with:${chr(13)}${chr(10)}${packet}${chr(13)}${chr(10)}Raw data length: ${str(data.Count())}`)
    reply.fromAsciiString(packet + chr(13) + chr(10))
    reply.append(data)
    ' loggers.printl(log_level_Type.INFO, "Entire response size: " + str(reply.count()))

    offset = 0
    bytes_to_send = reply.Count()
    ' FRAME_SIZE = 4024
    ' BUFFER_SOCKET_SIZE = 8192 
    ' BUFFER_SLEEP = 10
    ' BUFFER_LOOP_LIMIT = 1000 / BUFFER_SLEEP ' max waiting time till try to push another value into buffer, _BUFFER_SLEEP * _BUFFER_LOOP_LIMIT

    ' if isValid(port) then connection.NotifyWritable(true) ' Enable writable events

    ' while bytes_to_send > 0
    sent = connection.send(reply, offset, bytes_to_send)
    ' sent = connection.send(reply, offset, not isValid(port) or bytes_to_send < FRAME_SIZE ? bytes_to_send : FRAME_SIZE)
    if sent <= 0 then
        loggers.printl(log_level_Type.FATAL, "Send failed with status: " + str(sent))
        return sent ' Or handle error as needed
    end if
    status = connection.Status()
    if status <> 0 then
        loggers.printl(log_level_Type.FATAL, "Connection status error: " + str(status))
        return status
    end if
    ' offset = offset + sent
    ' bytes_to_send = bytes_to_send - sent
    ' loggers.printl(log_level_Type.INFO, "Sent chunk: " + str(sent) + " bytes, remaining: " + str(bytes_to_send) + ` - bytes in send buffer: ` + str(connection.GetCountSendBuf()))
    ' if isValid(port)
    '     loop_wait = 0
    '     while not connection.IsWritable() or connection.GetCountSendBuf() > 0
    loggers.printl(log_level_Type.INFO, `sent status: ${reply.Count()} - ${connection.GetCountSendBuf()}`)
    return reply.Count() - connection.GetCountSendBuf()
end function
