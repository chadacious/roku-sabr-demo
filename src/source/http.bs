import "pkg:/source/isItem.bs"

function http_trace(functionName as string)
    log = logger()
    if isValid(log)
        log.printl(log_level_Type.DEBUG, `[HTTP-Trace] ${functionName}`)
    end if
end function

'------------------------------------------------------------------------------
' Function : create_new_request
' Purpose  : Initializes the HTTP request state machine with empty buffers
'            ready to parse an incoming socket stream.
'------------------------------------------------------------------------------
function create_new_request()
    http_trace("create_new_request")
    return { "state": 0
        "headers": {}
        "method": ""
        "body_size": 0
        "search": {}
        "read_data": read_http
        "pathBytes": createobject("roByteArray")
        "buffer": createobject("roByteArray")
        "body": createobject("roByteArray")
    }
end function

'------------------------------------------------------------------------------
' Function : read_http
' Purpose  : Drives the HTTP request state machine by reading from the socket
'            and dispatching to method/path/header/body parsers.
'------------------------------------------------------------------------------
function read_http(request as object, connection as object)
    http_trace("read_http")
    length = connection.getCountRcvBuf()
    'print "Processing message on socket: " ; connection.getID() ; " of length " ; length
    if request.state < 6 or request.body_handler <> invalid then
        request.buffer[length - 1] = 0
        ' request.buffer[length - 1] = invalid
        r = connection.receive(request.buffer, 0, length)
    else
        request.body[request.content_length - 1] = 0
        ' request.body[request.content_length - 1] = invalid
        r = connection.receive(request.body, request.body_size, length)
        request.body_size = request.body_size + length
    end if

    ' Great. No switch statements
    if request.state = 0 then
        parse_http_method(connection, request)
    else if request.state = 1 then
        parse_http_path(connection, request)
    else if request.state = 2 then
        parse_http_search(connection, request)
    else if request.state = 3 then
        parse_http_version(connection, request)
    else if request.state = 4 then
        parse_http_headers(connection, request)
    else if request.state = 5 then
        parse_http_headers(connection, request)
    else if request.state = 6 then
        parse_http_body(connection, request)
    end if
    'print "Final state is " ; request.state
    return request.state = 7
end function


'------------------------------------------------------------------------------
' Function : parse_http_body
' Purpose  : Transfers buffered bytes into the request body and signals
'            completion when the declared Content-Length is satisfied.
'------------------------------------------------------------------------------
function parse_http_body(connection as object, request as object)
    http_trace("parse_http_body")
    if request.body_handler <> invalid then
        return request.body_handler(request, connection)
    end if
    while request.buffer.Count() > 0
        request.body.Push(request.buffer.Shift())
        request.body_size = request.body_size + 1
    end while
    if request.body_size >= request.content_length then
        request.state = 7
    end if
end function

'------------------------------------------------------------------------------
' Function : parse_http_headers
' Purpose  : Alternates between header-name and header-value parsing until the
'            blank line that terminates the HTTP header section is reached.
'------------------------------------------------------------------------------
function parse_http_headers(connection as object, request as object)
    http_trace("parse_http_headers")
    while request.buffer.Count() > 0 and request.state < 5
        if request.state = 4 then
            ' From 4, either go to 5 or 6
            parse_http_header_name(connection, request)
        end if
        if request.state = 5 then
            ' From 5 always go to 4
            parse_http_header_value(connection, request)
        end if
    end while
end function

'------------------------------------------------------------------------------
' Function : parse_http_header_name
' Purpose  : Reads bytes from the buffer to accumulate an HTTP header name and
'            transitions to value parsing or body handling when needed.
'------------------------------------------------------------------------------
function parse_http_header_name(connection as object, request as object)
    http_trace("parse_http_header_name")
    while request.buffer.Count() > 0
        code = request.buffer.Shift()
        if code = 13 then
            ' Do nothing
        else if code = 10 then
            ' Must be end of headers
            request.state = 6
            if request.headers["content-length"] <> invalid then
                request.content_length = val(request.headers["content-length"])
            else
                request.content_length = 0
            end if
            parse_http_body(connection, request)
            exit while
        else if code = 58 then
            ' End of header name
            request.headerValue = createobject("roByteArray")
            ' trim header name
            while request.headerName[0] = 32
                request.headerName.Shift()
            end while
            while request.headerName.Peek() = 32
                request.headerName.Pop()
            end while
            request.state = 5
            exit while
        else
            request.headerName.Push(code)
        end if
    end while
end function

'------------------------------------------------------------------------------
' Function : parse_http_header_value
' Purpose  : Decodes the header value until CRLF, trims whitespace, and stores
'            it on the request object.
'------------------------------------------------------------------------------
function parse_http_header_value(connection as object, request as object)
    http_trace("parse_http_header_value")
    while request.buffer.Count() > 0
        code = request.buffer.Shift()
        if code = 13 then
            ' Do nothing
        else if code = 10 then
            ' End of header value
            header_name = Lcase(request.headerName.toAsciiString())
            while request.headerValue[0] = 32
                request.headerValue.Shift()
            end while

            header_value = request.headerValue.toAsciiString()
            request.headers[header_name] = header_value
            ' Reset header name
            request.headerName = createobject("roByteArray")
            request.state = 4
            exit while
        else
            request.headerValue.Push(code)
        end if
    end while
end function


'------------------------------------------------------------------------------
' Function : parse_http_version
' Purpose  : Consumes the HTTP version token after the request path and then
'            resumes header parsing.
'------------------------------------------------------------------------------
function parse_http_version(connection as object, request as object)
    http_trace("parse_http_version")
    while request.buffer.Count() > 0
        code = request.buffer.Shift()
        if code = 10 then
            request.state = 4
            request.headerName = createobject("roByteArray")
            parse_http_headers(connection, request)
            exit while
        end if
    end while
end function

'------------------------------------------------------------------------------
' Function : parse_http_path
' Purpose  : Collects the request path and detects query parameters so the
'            parser can branch into search parsing or version parsing.
'------------------------------------------------------------------------------
function parse_http_path(connection as object, request as object)
    http_trace("parse_http_path")
    while request.buffer.Count() > 0
        code = request.buffer.Shift()
        if code = 63 then
            request.path = request.pathBytes.toAsciiString()
            request.state = 2
            request.search_bytes = createobject("roByteArray")
            parse_http_search(connection, request)
            exit while
        else if code = 32 then
            request.path = request.pathBytes.toAsciiString()
            request.state = 3
            parse_http_version(connection, request)
            exit while
        end if
        request.pathBytes.Push(code)
    end while
end function

'------------------------------------------------------------------------------
' Function : parse_http_method
' Purpose  : Reads the HTTP method token and transitions to path parsing when
'            the separating space is encountered.
'------------------------------------------------------------------------------
function parse_http_method(connection as object, request as object)
    http_trace("parse_http_method")
    while request.buffer.Count() > 0
        code = request.buffer.Shift()
        if code = 32 then
            request.state = 1
            parse_http_path(connection, request)
            exit while
        end if
        request.method = request.method + Lcase(chr(code))
    end while
end function

'------------------------------------------------------------------------------
' Function : parse_http_search
' Purpose  : Collects the query string bytes following the path and populates
'            the request search map when the space before HTTP version arrives.
'------------------------------------------------------------------------------
function parse_http_search(connection as object, request as object)
    http_trace("parse_http_search")
    while request.buffer.Count() > 0
        code = request.buffer.Shift()
        if code = 32 then
            munge_search(request)
            request.state = 3
            parse_http_version(connection, request)
            exit while
        end if
        request.search_bytes.push(code)
    end while
end function

'------------------------------------------------------------------------------
' Function : munge_search
' Purpose  : Splits the raw query-string byte array into a key/value map stored
'            on the request.
'------------------------------------------------------------------------------
sub munge_search(request as object)
    http_trace("munge_search")
    name_bytes = createobject("roByteArray")
    name = invalid
    For each code in request.search_bytes
        if code = 61 then '=
            name = name_bytes.toAsciiString()
            name_bytes = createobject("roByteArray")
        else if code = 38 then '&
            if name = invalid then
                request.search[name_bytes.toAsciiString()] = ""
            else
                request.search[name] = name_bytes.toAsciiString()
            end if
            name_bytes = createobject("roByteArray")
        else
            name_bytes.Push(code)
        end if
    end for
    if name_bytes.count() > 0 then
        if name = invalid then
            request.search[name_bytes.toAsciiString()] = ""
        else
            request.search[name] = name_bytes.toAsciiString()
        end if
    end if
end sub

'------------------------------------------------------------------------------
' Function : parse_url
' Purpose  : Parses a simple URL string into protocol/host/port/path components
'            for internal manifest rewriting utilities.
'------------------------------------------------------------------------------
function parse_url(s as string)
    http_trace("parse_url")
    url = { "path": "/"
        "hostname": ""
        "port": 0
        "protocol": ""
    }
    bytes = createobject("roByteArray")
    bytes.fromAsciiString(s)
    state = 0
    For each byte in bytes
        if state = 0 then
            if byte = 58 then
                state = 1
            else
                url.protocol = url.protocol + chr(byte)
            end if
        else if state = 1 then '/
            state = 2
        else if state = 2 then '/
            state = 3
        else if state = 3 then
            if byte = 47 then
                url.port = 80
                state = 5
            else if byte = 58 then
                state = 4
            else
                url.hostname = url.hostname + chr(byte)
            end if
        else if state = 4 then
            if byte = 47 then
                state = 5
            else
                url.port = 10 * url.port + val(chr(byte))
            end if
        else if state = 5 then
            url.path = url.path + chr(byte)
        end if
    end for
    return url
end function

'We have a central loop that JUST read http requests
'We have a list of (socket,request) pairs. Only once a request has been fully read do we actually dispatch it
'Until then, each time a socket is ready for reading, tell the request-parser to read some more data from the socket
'The request-parser then has to remember exactly what state is was in. There are only a few states:
'0) Method
'1) Path
'2) Search
'3) HTTP version
'4) Header name
'5) Header value
'6) Data

' ***************************************************
' Handle building responses Below here
' ***************************************************

function pad_integer(source as integer)
    http_trace("pad_integer")
    if source < 10 then
        return "0" + right(str(source), 1)
    else
        return right(str(source), 2)
    end if
end function

'------------------------------------------------------------------------------
' Function : send_http_reply
' Purpose  : Sends a complete HTTP response constructed in-memory, including
'            RFC822 date formatting and optional base64-decoded body content.
'------------------------------------------------------------------------------
function send_http_reply(connection as object, response_code as string, content_type as string, textData = "" as string, b64Data = "" as string)
    http_trace("send_http_reply")
    loggers = logger()
    reply = createobject("roByteArray")
    data = createobject("roByteArray")
    if textData <> "" then
        data.FromAsciiString(textData)
    else if b64Data <> "" then
        ' If we have base64 data, decode it
        data.FromBase64String(b64Data)
    end if
    date = createobject("roDateTime")
    months = ["placeholder"
        "Jan"
        "Feb"
        "Mar"
        "Apr"
        "May"
        "Jun"
        "Jul"
        "Aug"
        "Sep"
        "Oct"
        "Nov"
    "Dec"]
    month_name = months[date.getMonth()]
    ' WHY does str(6) return " 6" ?!
    rfc822 = Left(date.GetWeekday(), 3) + ", " + pad_integer(date.GetDayOfMonth()) + " " + month_name + " " + right(str(date.getYear()), 4) + " " + pad_integer(date.getHours()) + ":" + pad_integer(date.getMinutes()) + ":" + pad_integer(date.getSeconds()) + " GMT"
    packet = "HTTP/1.1 " + response_code + " OK" + chr(13) + chr(10)
    packet = packet + "Date: " + rfc822 + chr(13) + chr(10)
    packet = packet + "Content-Type: " + content_type + chr(13) + chr(10)
    packet = packet + "Content-Length: " + str(data.Count()) + chr(13) + chr(10)
    loggers.printl(log_level_Type.VERBOSE, "Preparing to HTTP reply with:" + chr(13) + chr(10) + packet + chr(13) + chr(10) + b64Data.left(100))
    reply.fromAsciiString(packet + chr(13) + chr(10))
    reply.append(data)
    loggers.printl(log_level_Type.VERBOSE, "Entire response size: " + str(reply.count()))
    status = connection.send(reply, 0, reply.Count())
    loggers.printl(log_level_Type.VERBOSE, "sent status: " + str(status))
    return status
end function

'------------------------------------------------------------------------------
' Function : http_sendHeaders
' Purpose  : Writes only the HTTP status line and headers to the socket,
'            logging range metadata and supporting partial responses.
'------------------------------------------------------------------------------
function http_sendHeaders(connection as object, response_code as integer, headers as object) as boolean
    http_trace("http_sendHeaders")
    loggers = logger()

    resStatus = ""
    if response_code = 200
        resStatus = "OK"
    else if response_code = 206
        resStatus = "Partial Content"
    else if response_code = 404
        resStatus = "Not Found"
    else
        resStatus = "Unknown"
    end if

    packet = `HTTP/1.1 ${response_code} ${resStatus}${chr(13)}${chr(10)}`
    for each key in headers.keys()
        packet = `${packet}${key}: ${headers[key]}${chr(13)}${chr(10)}`
    next
    if IsAssociativeArray(headers)
        rangeHeader = headers.Lookup("Content-Range")
        if not isValid(rangeHeader) then rangeHeader = headers.Lookup("content-range")
        if not isValid(rangeHeader)
            rangeHeader = headers.Lookup("X-Cache-Range")
        end if
        itagHeader = headers.Lookup("X-Cache-Itag")
        if not isValid(itagHeader) then itagHeader = headers.Lookup("x-cache-itag")
        if not isValid(itagHeader)
            itagHeader = headers.Lookup("X-Stream-Itag")
        end if
        lengthLabel = headers.Lookup("Content-Length")
        if not isValid(lengthLabel) then lengthLabel = headers.Lookup("content-length")
        if isValid(rangeHeader)
            taggedRange = rangeHeader
            if isValid(lengthLabel) then taggedRange = `${rangeHeader} length=${lengthLabel}`
            if isValid(itagHeader) and itagHeader <> ""
                loggers.printl(log_level_Type.INFO, `[HTTP] Reply itag=${itagHeader} range=${taggedRange} status=${response_code}`)
            else
                loggers.printl(log_level_Type.INFO, `[HTTP] Reply range=${taggedRange} status=${response_code}`)
            end if
        end if
    end if
    loggers.printl(log_level_Type.INFO, `Preparing to HTTP reply with:${chr(13)}${chr(10)}${packet}${chr(13)}${chr(10)}`)
    headerBytes = CreateObject("roByteArray")
    headerBytes.FromAsciiString(packet + chr(13) + chr(10))
    sent = connection.send(headerBytes, 0, headerBytes.Count())
    if sent <= 0 then
        loggers.printl(log_level_Type.DEBUG, `[HTTP] Client closed socket before headers completed; status=${sent}`)
        return false
    end if
    return true
end function

'------------------------------------------------------------------------------
' Function : send_http_reply_stream_chunks
' Purpose  : Streams a file to the client either via specific chunk offsets or
'            sequentially when chunk metadata is absent, after sending headers.
'------------------------------------------------------------------------------
function send_http_reply_stream_chunks(connection as object, response_code as integer, headers as object, dataPath as string, chunks as object, totalBytes = invalid as dynamic) as integer
    http_trace("send_http_reply_stream_chunks")
    loggers = logger()

    if not IsAssociativeArray(headers)
        headers = CreateObject("roAssociativeArray")
    end if

    if not IsString(dataPath) or dataPath = ""
        loggers.printl(log_level_Type.WARN, `[HTTP] Chunk stream requested without valid dataPath; sending headers only`)
        if http_sendHeaders(connection, response_code, headers) = false then return -1
        return 0
    end if

    hasChunks = IsArray(chunks) and chunks.Count() > 0

    computedTotal = totalBytes
    if computedTotal = invalid
        if hasChunks
            computedTotal = 0
            for each chunk in chunks
                chunkLen = chunk?.length
                if chunkLen <> invalid and chunkLen > 0
                    computedTotal = computedTotal + chunkLen
                end if
            end for
        else
            computedTotal = http_getFileSize(dataPath)
        end if
    end if
    if computedTotal <> invalid and computedTotal >= 0 and headers.DoesExist("Content-Length") = false
        headers["Content-Length"] = computedTotal.toStr()
    end if

    if http_sendHeaders(connection, response_code, headers) = false then return -1

    bytesSent = 0

    if not hasChunks
        chunkSize = 32768
        offset = 0
        remaining = computedTotal
        while remaining = invalid or remaining > 0
            readLen = chunkSize
            if remaining <> invalid and readLen > remaining
                readLen = remaining
            end if
            if readLen <= 0 then exit while

            buffer = CreateObject("roByteArray")
            if buffer.ReadFile(dataPath, offset, readLen) <> true then exit while
            chunkLen = buffer.Count()
            if chunkLen <= 0 then exit while

            sentOffset = 0
            while sentOffset < chunkLen
                sendLen = chunkLen - sentOffset
                sent = connection.send(buffer, sentOffset, sendLen)
                if sent <= 0
                    loggers.printl(log_level_Type.DEBUG, `[HTTP] Client closed socket mid-body (sequential stream) path=${dataPath} offset=${offset + sentOffset} chunk=${sendLen} status=${sent}`)
                    try
                        connection.Close()
                    catch e
                    end try
                    return sent
                end if
                sentOffset = sentOffset + sent
                bytesSent = bytesSent + sent
            end while

            offset = offset + chunkLen
            if remaining <> invalid
                remaining = remaining - chunkLen
                if remaining <= 0 then exit while
            end if
        end while

        loggers.printl(log_level_Type.INFO, `sent status: ${bytesSent} bytes sequential body`)
        return bytesSent
    end if

    for each chunk in chunks
        chunkOffset = chunk?.offset
        chunkLength = chunk?.length
        if chunkOffset = invalid or chunkLength = invalid or chunkLength <= 0 then continue for

        buffer = CreateObject("roByteArray")
        if buffer.ReadFile(dataPath, chunkOffset, chunkLength) <> true then exit for
        chunkLen = buffer.Count()
        if chunkLen <= 0 then exit for

        sentOffset = 0
        while sentOffset < chunkLen
            sendLen = chunkLen - sentOffset
            sent = connection.send(buffer, sentOffset, sendLen)
            if sent <= 0
                loggers.printl(log_level_Type.DEBUG, `[HTTP] Client closed socket mid-body (chunk stream) path=${dataPath} offset=${chunkOffset + sentOffset} chunk=${sendLen} status=${sent}`)
                try
                    connection.Close()
                catch e
                end try
                return sent
            end if
            sentOffset = sentOffset + sent
            bytesSent = bytesSent + sent
        end while
    end for

    loggers.printl(log_level_Type.INFO, `sent status: ${bytesSent} bytes chunked body`)
    return bytesSent
end function

'------------------------------------------------------------------------------
' Function : http_getFileSize
' Purpose  : Queries the filesystem for a path's size, returning invalid when
'            the path is missing or stat fails.
'------------------------------------------------------------------------------
function http_getFileSize(path as string) as dynamic
    if not IsString(path) or path = "" then return invalid
    fs = CreateObject("roFileSystem")
    stat = invalid
    try
        stat = fs.Stat(path)
    catch e
        stat = invalid
    end try
    if IsAssociativeArray(stat)
        sizeVal = stat.Lookup("size")
        if sizeVal = invalid then sizeVal = stat.Lookup("length")
        return sizeVal
    end if
    return invalid
end function
