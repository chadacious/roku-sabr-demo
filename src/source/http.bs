import "pkg:/source/isItem.bs"

function create_new_request()
    return { "state": 0
        "headers": {}
        "method": ""
        "body_size": 0
        "search": {}
        "read_data": read_http
        "pathBytes": createobject("roByteArray")
        "buffer": createobject("roByteArray")
        "body": createobject("roByteArray")
    }
end function

function read_http(request as object, connection as object)
    length = connection.getCountRcvBuf()
    'print "Processing message on socket: " ; connection.getID() ; " of length " ; length
    if request.state < 6 or request.body_handler <> invalid then
        request.buffer[length - 1] = 0
        ' request.buffer[length - 1] = invalid
        r = connection.receive(request.buffer, 0, length)
    else
        request.body[request.content_length - 1] = 0
        ' request.body[request.content_length - 1] = invalid
        r = connection.receive(request.body, request.body_size, length)
        request.body_size = request.body_size + length
    end if

    ' Great. No switch statements
    if request.state = 0 then
        parse_http_method(connection, request)
    else if request.state = 1 then
        parse_http_path(connection, request)
    else if request.state = 2 then
        parse_http_search(connection, request)
    else if request.state = 3 then
        parse_http_version(connection, request)
    else if request.state = 4 then
        parse_http_headers(connection, request)
    else if request.state = 5 then
        parse_http_headers(connection, request)
    else if request.state = 6 then
        parse_http_body(connection, request)
    end if
    'print "Final state is " ; request.state
    return request.state = 7
end function


function parse_http_body(connection as object, request as object)
    if request.body_handler <> invalid then
        return request.body_handler(request, connection)
    end if
    while request.buffer.Count() > 0
        request.body.Push(request.buffer.Shift())
        request.body_size = request.body_size + 1
    end while
    if request.body_size >= request.content_length then
        request.state = 7
    end if
end function

function parse_http_headers(connection as object, request as object)
    while request.buffer.Count() > 0 and request.state < 5
        if request.state = 4 then
            ' From 4, either go to 5 or 6
            parse_http_header_name(connection, request)
        end if
        if request.state = 5 then
            ' From 5 always go to 4
            parse_http_header_value(connection, request)
        end if
    end while
end function

function parse_http_header_name(connection as object, request as object)
    while request.buffer.Count() > 0
        code = request.buffer.Shift()
        if code = 13 then
            ' Do nothing
        else if code = 10 then
            ' Must be end of headers
            request.state = 6
            if request.headers["content-length"] <> invalid then
                request.content_length = val(request.headers["content-length"])
            else
                request.content_length = 0
            end if
            parse_http_body(connection, request)
            exit while
        else if code = 58 then
            ' End of header name
            request.headerValue = createobject("roByteArray")
            ' trim header name
            while request.headerName[0] = 32
                request.headerName.Shift()
            end while
            while request.headerName.Peek() = 32
                request.headerName.Pop()
            end while
            request.state = 5
            exit while
        else
            request.headerName.Push(code)
        end if
    end while
end function

function parse_http_header_value(connection as object, request as object)
    while request.buffer.Count() > 0
        code = request.buffer.Shift()
        if code = 13 then
            ' Do nothing
        else if code = 10 then
            ' End of header value
            header_name = Lcase(request.headerName.toAsciiString())
            while request.headerValue[0] = 32
                request.headerValue.Shift()
            end while

            header_value = request.headerValue.toAsciiString()
            request.headers[header_name] = header_value
            ' Reset header name
            request.headerName = createobject("roByteArray")
            request.state = 4
            exit while
        else
            request.headerValue.Push(code)
        end if
    end while
end function


function parse_http_version(connection as object, request as object)
    while request.buffer.Count() > 0
        code = request.buffer.Shift()
        if code = 10 then
            request.state = 4
            request.headerName = createobject("roByteArray")
            parse_http_headers(connection, request)
            exit while
        end if
    end while
end function

function parse_http_path(connection as object, request as object)
    while request.buffer.Count() > 0
        code = request.buffer.Shift()
        if code = 63 then
            request.path = request.pathBytes.toAsciiString()
            request.state = 2
            request.search_bytes = createobject("roByteArray")
            parse_http_search(connection, request)
            exit while
        else if code = 32 then
            request.path = request.pathBytes.toAsciiString()
            request.state = 3
            parse_http_version(connection, request)
            exit while
        end if
        request.pathBytes.Push(code)
    end while
end function

function parse_http_method(connection as object, request as object)
    while request.buffer.Count() > 0
        code = request.buffer.Shift()
        if code = 32 then
            request.state = 1
            parse_http_path(connection, request)
            exit while
        end if
        request.method = request.method + Lcase(chr(code))
    end while
end function

function parse_http_search(connection as object, request as object)
    while request.buffer.Count() > 0
        code = request.buffer.Shift()
        if code = 32 then
            munge_search(request)
            request.state = 3
            parse_http_version(connection, request)
            exit while
        end if
        request.search_bytes.push(code)
    end while
end function

sub munge_search(request as object)
    name_bytes = createobject("roByteArray")
    name = invalid
    For each code in request.search_bytes
        if code = 61 then '=
            name = name_bytes.toAsciiString()
            name_bytes = createobject("roByteArray")
        else if code = 38 then '&
            if name = invalid then
                request.search[name_bytes.toAsciiString()] = ""
            else
                request.search[name] = name_bytes.toAsciiString()
            end if
            name_bytes = createobject("roByteArray")
        else
            name_bytes.Push(code)
        end if
    end for
    if name_bytes.count() > 0 then
        if name = invalid then
            request.search[name_bytes.toAsciiString()] = ""
        else
            request.search[name] = name_bytes.toAsciiString()
        end if
    end if
end sub

function parse_url(s as string)
    url = { "path": "/"
        "hostname": ""
        "port": 0
        "protocol": ""
    }
    bytes = createobject("roByteArray")
    bytes.fromAsciiString(s)
    state = 0
    For each byte in bytes
        if state = 0 then
            if byte = 58 then
                state = 1
            else
                url.protocol = url.protocol + chr(byte)
            end if
        else if state = 1 then '/
            state = 2
        else if state = 2 then '/
            state = 3
        else if state = 3 then
            if byte = 47 then
                url.port = 80
                state = 5
            else if byte = 58 then
                state = 4
            else
                url.hostname = url.hostname + chr(byte)
            end if
        else if state = 4 then
            if byte = 47 then
                state = 5
            else
                url.port = 10 * url.port + val(chr(byte))
            end if
        else if state = 5 then
            url.path = url.path + chr(byte)
        end if
    end for
    return url
end function

'We have a central loop that JUST read http requests
'We have a list of (socket,request) pairs. Only once a request has been fully read do we actually dispatch it
'Until then, each time a socket is ready for reading, tell the request-parser to read some more data from the socket
'The request-parser then has to remember exactly what state is was in. There are only a few states:
'0) Method
'1) Path
'2) Search
'3) HTTP version
'4) Header name
'5) Header value
'6) Data

' ***************************************************
' Handle building responses Below here
' ***************************************************

function pad_integer(source as integer)
    if source < 10 then
        return "0" + right(str(source), 1)
    else
        return right(str(source), 2)
    end if
end function

function send_http_reply(connection as object, response_code as string, content_type as string, textData = "" as string, b64Data = "" as string)
    loggers = logger()
    reply = createobject("roByteArray")
    data = createobject("roByteArray")
    if textData <> "" then
        data.FromAsciiString(textData)
    else if b64Data <> "" then
        ' If we have base64 data, decode it
        data.FromBase64String(b64Data)
    end if
    date = createobject("roDateTime")
    months = ["placeholder"
        "Jan"
        "Feb"
        "Mar"
        "Apr"
        "May"
        "Jun"
        "Jul"
        "Aug"
        "Sep"
        "Oct"
        "Nov"
    "Dec"]
    month_name = months[date.getMonth()]
    ' WHY does str(6) return " 6" ?!
    rfc822 = Left(date.GetWeekday(), 3) + ", " + pad_integer(date.GetDayOfMonth()) + " " + month_name + " " + right(str(date.getYear()), 4) + " " + pad_integer(date.getHours()) + ":" + pad_integer(date.getMinutes()) + ":" + pad_integer(date.getSeconds()) + " GMT"
    packet = "HTTP/1.1 " + response_code + " OK" + chr(13) + chr(10)
    packet = packet + "Date: " + rfc822 + chr(13) + chr(10)
    packet = packet + "Content-Type: " + content_type + chr(13) + chr(10)
    packet = packet + "Content-Length: " + str(data.Count()) + chr(13) + chr(10)
    loggers.printl(log_level_Type.VERBOSE, "Preparing to HTTP reply with:" + chr(13) + chr(10) + packet + chr(13) + chr(10) + b64Data.left(100))
    reply.fromAsciiString(packet + chr(13) + chr(10))
    reply.append(data)
    loggers.printl(log_level_Type.VERBOSE, "Entire response size: " + str(reply.count()))
    status = connection.send(reply, 0, reply.Count())
    loggers.printl(log_level_Type.VERBOSE, "sent status: " + str(status))
    return status
end function

' Streams an HTTP response back to the client, optionally reading payload
' bytes from disk to avoid large in-memory buffers.
function http_sendHeaders(connection as object, response_code as integer, headers as object) as boolean
    loggers = logger()

    resStatus = ""
    if response_code = 200
        resStatus = "OK"
    else if response_code = 206
        resStatus = "Partial Content"
    else if response_code = 404
        resStatus = "Not Found"
    else
        resStatus = "Unknown"
    end if

    packet = `HTTP/1.1 ${response_code} ${resStatus}${chr(13)}${chr(10)}`
    for each key in headers.keys()
        packet = `${packet}${key}: ${headers[key]}${chr(13)}${chr(10)}`
    next
    if IsAssociativeArray(headers)
        rangeHeader = headers.Lookup("Content-Range")
        if not isValid(rangeHeader) then rangeHeader = headers.Lookup("content-range")
        if not isValid(rangeHeader)
            rangeHeader = headers.Lookup("X-Cache-Range")
        end if
        itagHeader = headers.Lookup("X-Cache-Itag")
        if not isValid(itagHeader) then itagHeader = headers.Lookup("x-cache-itag")
        if not isValid(itagHeader)
            itagHeader = headers.Lookup("X-Stream-Itag")
        end if
        lengthLabel = headers.Lookup("Content-Length")
        if not isValid(lengthLabel) then lengthLabel = headers.Lookup("content-length")
        if isValid(rangeHeader)
            taggedRange = rangeHeader
            if isValid(lengthLabel) then taggedRange = `${rangeHeader} length=${lengthLabel}`
            if isValid(itagHeader) and itagHeader <> ""
                loggers.printl(log_level_Type.INFO, `[HTTP] Reply itag=${itagHeader} range=${taggedRange} status=${response_code}`)
            else
                loggers.printl(log_level_Type.INFO, `[HTTP] Reply range=${taggedRange} status=${response_code}`)
            end if
        end if
    end if
    loggers.printl(log_level_Type.INFO, `Preparing to HTTP reply with:${chr(13)}${chr(10)}${packet}${chr(13)}${chr(10)}`)
    headerBytes = CreateObject("roByteArray")
    headerBytes.FromAsciiString(packet + chr(13) + chr(10))
    sent = connection.send(headerBytes, 0, headerBytes.Count())
    if sent <= 0 then
        loggers.printl(log_level_Type.DEBUG, `[HTTP] Client closed socket before headers completed; status=${sent}`)
        return false
    end if
    return true
end function

function http_resolveTotalBytes(headers as object, data as dynamic, dataPath as dynamic, dataLength as dynamic) as dynamic
    totalBytes = dataLength
    if totalBytes = invalid
        if IsAssociativeArray(headers)
            lenLabel = headers.Lookup("Content-Length")
            if not isValid(lenLabel) then lenLabel = headers.Lookup("content-length")
            if isValid(lenLabel)
                lenValue = Val(lenLabel)
                if lenValue <> invalid then totalBytes = lenValue
            end if
        end if
    end if
    if totalBytes = invalid
        if GetInterface(data, "ifByteArray") <> invalid
            totalBytes = data.Count()
        else if IsString(dataPath) and dataPath <> ""
            sizeGuess = http_getFileSize(dataPath)
            if sizeGuess <> invalid then totalBytes = sizeGuess
        else
            totalBytes = 0
        end if
    end if
    return totalBytes
end function

function send_http_reply_raw(connection as object, response_code as integer, headers as object, data, port = invalid, dataPath = invalid as dynamic, dataOffset = 0 as dynamic, dataLength = invalid as dynamic)
    if http_sendHeaders(connection, response_code, headers) = false then return -1

    loggers = logger()
    totalBytes = http_resolveTotalBytes(headers, data, dataPath, dataLength)

    bytesSent = 0
    chunkSize = 32768

    if GetInterface(data, "ifByteArray") <> invalid and data.Count() > 0
        offset = 0
        while offset < data.Count()
            sendLen = chunkSize
            if offset + sendLen > data.Count()
                sendLen = data.Count() - offset
            end if
            if sendLen <= 0 then exit while
            sent = connection.send(data, offset, sendLen)
            if sent <= 0
                loggers.printl(log_level_Type.DEBUG, `[HTTP] Client closed socket mid-body (byte array) offset=${offset} remaining=${data.Count() - offset} status=${sent}`)
                try
                    connection.Close()
                catch e
                end try
                return sent
            end if
            offset = offset + sent
            bytesSent = bytesSent + sent
        end while
    else if IsString(dataPath) and dataPath <> ""
        currentOffset = dataOffset
        if currentOffset = invalid then currentOffset = 0
        remaining = totalBytes
        while remaining = invalid or remaining > 0
            readLen = chunkSize
            if remaining <> invalid and readLen > remaining
                readLen = remaining
            end if
            if readLen <= 0 then exit while
            chunk = CreateObject("roByteArray")
            if chunk.ReadFile(dataPath, currentOffset, readLen) <> true
                exit while
            end if
            chunkLen = chunk.Count()
            if chunkLen <= 0 then exit while
            offset = 0
            while offset < chunkLen
                sendLen = chunkLen - offset
                sent = connection.send(chunk, offset, sendLen)
                if sent <= 0
                    loggers.printl(log_level_Type.DEBUG, `[HTTP] Client closed socket mid-body (file stream) path=${dataPath} offset=${currentOffset + offset} chunk=${sendLen} status=${sent}`)
                    try
                        connection.Close()
                    catch e
                    end try
                    return sent
                end if
                offset = offset + sent
                bytesSent = bytesSent + sent
            end while
            currentOffset = currentOffset + chunkLen
            if remaining <> invalid
                remaining = remaining - chunkLen
                if remaining <= 0 then exit while
            end if
        end while
    end if

    loggers.printl(log_level_Type.INFO, `sent status: ${bytesSent} bytes body`)
    return bytesSent
end function

function send_http_reply_stream(connection as object, response_code as integer, headers as object, dataPath as string, dataOffset = 0 as dynamic, dataLength = invalid as dynamic) as integer
    loggers = logger()
    if not IsString(dataPath) or dataPath = ""
        loggers.printl(log_level_Type.WARN, `[HTTP] Stream requested without valid dataPath; falling back to empty response`)
        return send_http_reply_raw(connection, response_code, headers, CreateObject("roByteArray"))
    end if
    if http_sendHeaders(connection, response_code, headers) = false then return -1

    totalBytes = http_resolveTotalBytes(headers, invalid, dataPath, dataLength)
    chunkSize = 32768
    currentOffset = dataOffset
    if currentOffset = invalid or currentOffset < 0 then currentOffset = 0
    remaining = totalBytes
    bytesSent = 0
    chunk = CreateObject("roByteArray")

    while remaining = invalid or remaining > 0
        readLen = chunkSize
        if remaining <> invalid and readLen > remaining
            readLen = remaining
        end if
        if readLen <= 0 then exit while

        if chunk.ReadFile(dataPath, currentOffset, readLen) <> true then exit while
        chunkLen = chunk.Count()
        if chunkLen <= 0 then exit while

        offset = 0
        while offset < chunkLen
            sendLen = chunkLen - offset
            sent = connection.send(chunk, offset, sendLen)
            if sent <= 0
                loggers.printl(log_level_Type.DEBUG, `[HTTP] Client closed socket mid-body (file stream) path=${dataPath} offset=${currentOffset + offset} chunk=${sendLen} status=${sent}`)
                try
                    connection.Close()
                catch e
                end try
                return sent
            end if
            offset = offset + sent
            bytesSent = bytesSent + sent
        end while

        currentOffset = currentOffset + chunkLen
        if remaining <> invalid
            remaining = remaining - chunkLen
            if remaining <= 0 then exit while
        end if
    end while

    loggers.printl(log_level_Type.INFO, `sent status: ${bytesSent} bytes body (file stream)`)
    return bytesSent
end function

function http_getFileSize(path as string) as dynamic
    if not IsString(path) or path = "" then return invalid
    fs = CreateObject("roFileSystem")
    stat = invalid
    try
        stat = fs.Stat(path)
    catch e
        stat = invalid
    end try
    if IsAssociativeArray(stat)
        sizeVal = stat.Lookup("size")
        if sizeVal = invalid then sizeVal = stat.Lookup("length")
        return sizeVal
    end if
    return invalid
end function
