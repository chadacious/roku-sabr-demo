' SABR cache manager that persists segments to tmp:/ to conserve channel memory.

import "pkg:/source/logger.bs"
import "pkg:/source/utils.bs"
import "pkg:/source/isItem.bs"

function createSabrCacheManager(options = invalid as dynamic) as object
    defaults = {
        basePath: "tmp:/sabr-cache"
        maxSizeBytes: 8 * 1024 * 1024 ' 8 MB default
        maxEntryAgeMs: 5 * 60 * 1000 ' 5 minutes
    }

    if not isValid(options) then options = {}

    basePath = options?.basePath
    if not isValid(basePath) or basePath = "" then basePath = defaults.basePath

    fs = CreateObject("roFileSystem")
    if fs.Exists(basePath)
        ' no-op
    else
        ok = fs.CreateDirectory(basePath)
        if not ok
            logger().printl(log_level_Type.WARN, `[SabrCache] Unable to create cache directory: ${basePath}`)
        end if
    end if

    manager = {
        basePath: basePath
        maxSizeBytes: options?.maxSizeBytes ?? defaults.maxSizeBytes
        maxEntryAgeMs: options?.maxEntryAgeMs ?? defaults.maxEntryAgeMs
        currentSize: 0
        entries: createObject("roAssociativeArray")
        segmentIndexes: createObject("roAssociativeArray")
        logs: logger()
    }

    manager.storeInitSegment = function(self as object, key as string, bytes as object, coverage = invalid as dynamic) as void
        sabr_cache_store(self, key, bytes, true, coverage)
    end function
    manager.setInitSegment = function(self as object, key as string, bytes as object, coverage = invalid as dynamic) as void
        sabr_cache_store(self, key, bytes, true, coverage)
    end function
    manager.storeSegment = function(self as object, key as string, bytes as object, coverage = invalid as dynamic) as void
        sabr_cache_store(self, key, bytes, false, coverage)
    end function
    manager.getInitSegment = function(self as object, key as string) as dynamic
        return sabr_cache_get(self, key, true)
    end function
    manager.getSegment = function(self as object, key as string) as dynamic
        return sabr_cache_get(self, key, false)
    end function
    manager.getInitSegmentSlice = function(self as object, key as string, range as object) as dynamic
        return sabr_cache_getSlice(self, key, true, range)
    end function
    manager.getSegmentSlice = function(self as object, key as string, range as object) as dynamic
        return sabr_cache_getSlice(self, key, false, range)
    end function
    manager.getEntryInfo = function(self as object, key as string) as dynamic
        return sabr_cache_entryInfo(self, key)
    end function
    manager.clear = function(self as object) as void
        sabr_cache_clear(self)
    end function
    manager.stats = function(self as object) as object
        return sabr_cache_stats(self)
    end function
    manager.computeIndexKey = function(self as object, metadata as dynamic) as string
        return sabr_cache_computeIndexKey(metadata)
    end function
    manager.registerSegmentIndex = function(self as object, metadata as dynamic, indexData as object) as void
        sabr_cache_registerSegmentIndex(self, metadata, indexData)
    end function
    manager.getSegmentIndex = function(self as object, metadataOrKey as dynamic) as dynamic
        return sabr_cache_getSegmentIndex(self, metadataOrKey)
    end function
    manager.inferRangeForByteRange = function(self as object, metadata as dynamic, byteRange as object, fallbackLength = invalid as dynamic) as dynamic
        return sabr_cache_inferRangeForByteRange(self, metadata, byteRange, fallbackLength)
    end function
    manager.attachSegmentToIndex = function(self as object, metadata as dynamic, entry as object, cacheKey = "" as string) as void
        sabr_cache_attachSegmentToIndex(self, metadata, entry, cacheKey)
    end function
    manager.listSegments = function(self as object, filter = invalid as dynamic) as object
        return sabr_cache_listSegments(self, filter)
    end function

    return manager
end function

function sabr_cache_store(ctx as object, key as string, bytes as object, isInitEntry as boolean, metadata = invalid as dynamic) as void
    if not isValid(bytes) then return
    if not isValid(key) or key = "" then return

    size = bytes.count()
    if size <= 0 then return

    filePath = sabr_cache_pathForKey(ctx, key, isInitEntry, metadata)

    existing = ctx.entries.Lookup(key)
    if isValid(existing)
        sabr_cache_removeEntry(ctx, key, existing)
    end if

    ok = bytes.writeFile(filePath)
    if not ok
        ctx.logs.printl(log_level_Type.WARN, `[SabrCache] Failed to write cache entry ${filePath}`)
        return
    end if

    entry = {
        path: filePath
        storedAt: sabr_cache_timestamp()
        size: size
        isInit: isInitEntry
    }
    if isValid(metadata)
        entry["rangeStart"] = metadata?.rangeStart ?? metadata?.start
        entry["rangeEnd"] = metadata?.rangeEnd ?? metadata?.end
        entry["headerId"] = metadata?.headerId
        entry["etag"] = metadata?.etag
        entry["contentType"] = metadata?.contentType
        entry["itag"] = metadata?.itag
        entry["xtags"] = metadata?.xtags
        entry["mediaIdHash"] = metadata?.mediaIdHash
        entry["sequenceNumber"] = metadata?.sequenceNumber
        entry["metadata"] = sabr_cache_cloneObject(metadata)
    end if

    if isValid(metadata)
        metadata["cacheKey"] = key
        inferredRange = invalid
        indexKey = sabr_cache_computeIndexKey(metadata)
        if indexKey <> ""
            entry["indexKey"] = indexKey
        end if
        if (not isValid(entry?.rangeStart) or not isValid(entry?.rangeEnd)) and isValid(indexKey)
            inferredRange = sabr_cache_inferRangeForByteRange(ctx, metadata, metadata, size)
            if isValid(inferredRange)
                entry["rangeStart"] = inferredRange?.rangeStart
                entry["rangeEnd"] = inferredRange?.rangeEnd
                metadata["rangeStart"] = inferredRange?.rangeStart
                metadata["rangeEnd"] = inferredRange?.rangeEnd
                if not isValid(metadata?.sequenceNumber) and isValid(inferredRange?.sequenceNumber)
                    metadata["sequenceNumber"] = inferredRange.sequenceNumber
                    entry["sequenceNumber"] = inferredRange.sequenceNumber
                end if
            end if
        end if
        sabr_cache_attachSegmentToIndex(ctx, metadata, entry, key)
    end if

    ctx.entries[key] = entry
    ctx.currentSize = ctx.currentSize + size

    sabr_cache_enforceLimits(ctx)
end function

function sabr_cache_get(ctx as object, key as string, expectInit as boolean) as dynamic
    entry = sabr_cache_findEntry(ctx, key, expectInit)
    if not isValid(entry) then return invalid

    result = CreateObject("roByteArray")
    if result.readFile(entry.path)
        return result
    else
        ctx.logs.printl(log_level_Type.WARN, `[SabrCache] Failed to read cached entry ${entry.path}; removing`)
        sabr_cache_removeEntry(ctx, key, entry)
        return invalid
    end if
end function

function sabr_cache_getSlice(ctx as object, key as string, expectInit as boolean, range as object) as dynamic
    if not isValid(range) then return invalid

    entry = sabr_cache_findEntry(ctx, key, expectInit)
    if not isValid(entry) then return invalid

    coverage = sabr_cache_extractRangeFromEntry(entry)
    requested = sabr_cache_extractRange(range)

    if not sabr_cache_rangeIsCovered(coverage, requested) then return invalid

    offset = requested.start - coverage.start
    length = requested.end - requested.start + 1

    if offset < 0 or length < 0 then return invalid
    if offset + length > entry.size
        length = entry.size - offset
        if length < 0 then return invalid
    end if

    if length = 0
        emptySlice = CreateObject("roByteArray")
        return emptySlice
    end if

    slice = invalid
    success = false
    try
        slice = CreateObject("roByteArray")
        success = slice.ReadFile(entry.path, offset, length)
    catch e
        success = false
        slice = invalid
    end try

    if success = true and isValid(slice)
        return slice
    end if

    full = CreateObject("roByteArray")
    if full.readFile(entry.path)
        return sabr_cache_copyRange(full, offset, length)
    else
        ctx.logs.printl(log_level_Type.WARN, `[SabrCache] Failed to read cached entry ${entry.path}; removing`)
        sabr_cache_removeEntry(ctx, key, entry)
        return invalid
    end if
end function

function sabr_cache_entryInfo(ctx as object, key as string) as dynamic
    if not isValid(key) or key = "" then return invalid
    entry = ctx.entries.Lookup(key)
    if not isValid(entry) then return invalid
    return entry
end function

function sabr_cache_findEntry(ctx as object, key as string, expectInit as boolean) as dynamic
    if not isValid(key) or key = "" then return invalid

    entry = ctx.entries.Lookup(key)
    if not isValid(entry) then return invalid
    if expectInit <> entry.isInit then return invalid

    if sabr_cache_timestamp() - entry.storedAt > ctx.maxEntryAgeMs
        sabr_cache_removeEntry(ctx, key, entry)
        return invalid
    end if

    return entry
end function

function sabr_cache_extractRange(range as dynamic) as dynamic
    if not isValid(range) then return invalid
    startVal = sabr_cache_toNumber(range?.start)
    if startVal = invalid then startVal = sabr_cache_toNumber(range?.startRange)
    endVal = sabr_cache_toNumber(range?.end)
    if endVal = invalid then endVal = sabr_cache_toNumber(range?.endRange)
    if startVal = invalid or endVal = invalid then return invalid
    if endVal < startVal then return invalid
    return { start: startVal, end: endVal }
end function

function sabr_cache_extractRangeFromEntry(entry as dynamic) as dynamic
    if not isValid(entry) then return invalid
    startVal = sabr_cache_toNumber(entry?.rangeStart)
    endVal = sabr_cache_toNumber(entry?.rangeEnd)
    if startVal = invalid or endVal = invalid then return invalid
    if endVal < startVal then return invalid
    return { start: startVal, end: endVal }
end function

function sabr_cache_rangeIsCovered(coverage as dynamic, requested as dynamic) as boolean
    if not isValid(coverage) or not isValid(requested) then return false
    return requested.start >= coverage.start and requested.end <= coverage.end
end function

function sabr_cache_toInt(value as dynamic) as dynamic
    if not isValid(value) then return invalid
    if IsInteger(value) then return value
    if IsFloat(value) or IsDouble(value) then return int(value)
    if IsString(value)
        trimmed = value.trim()
        if trimmed = "" then return invalid
        return trimmed.toInt()
    end if
    return invalid
end function

function sabr_cache_copyRange(source as object, offset as integer, length as integer) as object
    result = CreateObject("roByteArray")
    if not isValid(source) then return result
    total = source.count()
    if offset < 0 then offset = 0
    if length < 0 then length = 0
    if offset > total then offset = total
    if offset + length > total
        length = total - offset
        if length < 0 then length = 0
    end if
    if length = 0 then return result

    result[length - 1] = 0
    destIndex = 0
    for i = offset to offset + length - 1
        result[destIndex] = source[i]
        destIndex = destIndex + 1
    end for
    return result
end function

sub sabr_cache_enforceLimits(ctx as object)
    if ctx.currentSize <= ctx.maxSizeBytes then return

    sabr_cache_removeExpired(ctx)
    if ctx.currentSize <= ctx.maxSizeBytes then return

    ' Remove oldest segments first, then init segments if needed.
    sabr_cache_evictOldest(ctx, false)
    if ctx.currentSize <= ctx.maxSizeBytes then return
    sabr_cache_evictOldest(ctx, true)
end sub

sub sabr_cache_removeExpired(ctx as object)
    now = sabr_cache_timestamp()
    for each key in ctx.entries.keys()
        entry = ctx.entries.Lookup(key)
        if isValid(entry) and now - entry.storedAt > ctx.maxEntryAgeMs
            sabr_cache_removeEntry(ctx, key, entry)
        end if
    end for
end sub

sub sabr_cache_evictOldest(ctx as object, includeInits as boolean)
    oldestKey = invalid
    oldestTime = sabr_cache_timestamp()

    for each key in ctx.entries.keys()
        entry = ctx.entries.Lookup(key)
        if isValid(entry)
            if (includeInits or entry.isInit = false)
                if oldestKey = invalid or entry.storedAt < oldestTime
                    oldestKey = key
                    oldestTime = entry.storedAt
                end if
            end if
        end if
    end for

    if isValid(oldestKey)
        entry = ctx.entries.Lookup(oldestKey)
        sabr_cache_removeEntry(ctx, oldestKey, entry)
    end if
end sub

function sabr_cache_stats(ctx as object) as object
    initCount = 0
    segmentCount = 0
    for each key in ctx.entries.keys()
        entry = ctx.entries.Lookup(key)
        if isValid(entry)
            if entry.isInit = true then initCount = initCount + 1 else segmentCount = segmentCount + 1
        end if
    end for

    return {
        initSegments: initCount
        segments: segmentCount
        currentSize: ctx.currentSize
        maxSizeBytes: ctx.maxSizeBytes
        basePath: ctx.basePath
    }
end function

sub sabr_cache_clear(ctx as object)
    for each key in ctx.entries.keys()
        entry = ctx.entries.Lookup(key)
        sabr_cache_removeEntry(ctx, key, entry)
    end for
    ctx.entries = createObject("roAssociativeArray")
    ctx.currentSize = 0
end sub

sub sabr_cache_removeEntry(ctx as object, key as string, entry as object)
    if not isValid(entry) then
        ctx.entries.Delete(key)
        return
    end if

    filePath = entry.path
    if isValid(filePath) and filePath <> ""
        fs = CreateObject("roFileSystem")
        if fs.Exists(filePath)
            fs.Delete(filePath)
        end if
    end if

    ctx.currentSize = ctx.currentSize - entry.size
    if ctx.currentSize < 0 then ctx.currentSize = 0
    ctx.entries.Delete(key)
end sub

function sabr_cache_pathForKey(ctx as object, key as string, isInitEntry as boolean, metadata = invalid as dynamic) as string
    digest = hashStringEVP(key, "md5")

    contentType = sabr_cache_sanitizeLabel(metadata?.contentType ?? "")
    if contentType = "" or contentType = "unknown"
        if key.inStr("|") >= 0
            keyParts = key.Split("|")
            if keyParts.count() >= 2
                candidateType = sabr_cache_sanitizeLabel(keyParts[1] ?? "")
                if candidateType <> "" then contentType = candidateType
            end if
        end if
        if contentType = "" or contentType = "unknown"
            contentType = "unknown"
        end if
    end if

    itagLabel = sabr_cache_sanitizeLabel(`${metadata?.itag ?? ""}`)
    if itagLabel = "" and key.inStr("|") >= 0
        pieces = key.Split("|")
        if pieces.count() >= 3
            altItag = sabr_cache_sanitizeLabel(pieces[2] ?? "")
            if altItag <> "" then itagLabel = altItag
        end if
    end if
    if itagLabel = ""
        itagLabel = "itag-unknown"
    end if

    xtagsLabel = sabr_cache_sanitizeLabel(metadata?.xtags ?? "")

    descriptor = "init"
    rangeSuffix = "init"
    if not isInitEntry
        descriptor = "seg"
        startVal = sabr_cache_toNumber(metadata?.rangeStart)
        if startVal = invalid then startVal = sabr_cache_toNumber(metadata?.start)
        endVal = sabr_cache_toNumber(metadata?.rangeEnd)
        if endVal = invalid then endVal = sabr_cache_toNumber(metadata?.end)
        if startVal <> invalid and endVal <> invalid
            rangeSuffix = `${Int(startVal)}-${Int(endVal)}`
        else if startVal <> invalid
            rangeSuffix = `${Int(startVal)}`
        else if metadata?.cacheKey <> invalid and metadata.cacheKey.inStr("-") >= 0
            rangeSuffix = metadata.cacheKey.Split("-")[0]
        else
            rangeSuffix = "seg"
        end if
    end if

    parts = []
    parts.push(contentType)
    if itagLabel <> "" then parts.push(itagLabel)
    if xtagsLabel <> "unknown" then parts.push(xtagsLabel)
    parts.push(descriptor)
    if rangeSuffix <> "" then parts.push(sabr_cache_sanitizeLabel(rangeSuffix ?? ""))

    baseLabel = ""
    for each part in parts
        safePart = sabr_cache_sanitizeLabel(part ?? "")
        if safePart = "" then continue for
        if baseLabel = ""
            baseLabel = safePart
        else
            baseLabel = `${baseLabel}-${safePart}`
        end if
    end for

    digestPreview = Left(digest, 8)
    baseName = `${baseLabel}-${digestPreview}.bin`
    if Len(baseName) > 96
        baseName = Left(baseName, 92) + ".bin"
    end if

    if ctx.logs <> invalid and GetInterface(ctx.logs, "ifAssociativeArray") <> invalid
        ctx.logs.printl(log_level_Type.DEBUG, `[SabrCache] storing ${descriptor} entry; type=${contentType} itag=${itagLabel} suffix=${rangeSuffix} digest=${digest}`)
    end if
    return `${ctx.basePath}/${baseName}`
end function

function sabr_cache_computeIndexKey(metadata as dynamic) as string
    if not isValid(metadata) then return ""

    mediaId = sabr_cache_toSafeString(metadata?.mediaIdHash)
    if mediaId = "" then mediaId = sabr_cache_toSafeString(metadata?.mediaId)
    contentType = sabr_cache_toSafeString(metadata?.contentType)
    if contentType = ""
         contentType = "unknown"
    end if
    itagLabel = sabr_cache_toSafeString(metadata?.itag)
    if itagLabel = "" then
        itagLabel = "unknown"
    end if
    xtagsLabel = sabr_cache_toSafeString(metadata?.xtags)
    if xtagsLabel = "" then xtagsLabel = "none"

    return `${mediaId}|${contentType}|${itagLabel}|${xtagsLabel}`
end function

sub sabr_cache_registerSegmentIndex(ctx as object, metadata as dynamic, indexData as object)
    if GetInterface(ctx.segmentIndexes, "ifAssociativeArray") = invalid then return
    if not isValid(indexData) then return

    indexKey = sabr_cache_computeIndexKey(metadata)
    if indexKey = "" then return

    if GetInterface(indexData, "ifAssociativeArray") = invalid
        sanitized = { references: [] }
    else
        sanitized = indexData
    end if

    sanitized["indexKey"] = indexKey
    sanitized["registeredAt"] = sabr_cache_timestamp()
    sanitized["metadata"] = {
        mediaIdHash: sabr_cache_toSafeString(metadata?.mediaIdHash)
        contentType: sabr_cache_toSafeString(metadata?.contentType)
        itag: sabr_cache_toSafeString(metadata?.itag)
        xtags: sabr_cache_toSafeString(metadata?.xtags)
    }

    refs = sanitized?.references
    if GetInterface(refs, "ifArray") <> invalid
        total = refs.count()
        for i = 0 to total - 1
            ref = refs[i]
            if GetInterface(ref, "ifAssociativeArray") = invalid
                ref = { }
            end if
            ref["index"] = i
            ref["rangeStart"] = sabr_cache_toNumber(ref?.rangeStart)
            ref["rangeEnd"] = sabr_cache_toNumber(ref?.rangeEnd)
            ref["referenceSize"] = sabr_cache_toNumber(ref?.referenceSize)
            refs[i] = ref
        end for
        sanitized["references"] = refs
    else
        sanitized["references"] = []
    end if

    ctx.segmentIndexes[indexKey] = sanitized
end sub

function sabr_cache_getSegmentIndex(ctx as object, metadataOrKey as dynamic) as dynamic
    if GetInterface(ctx.segmentIndexes, "ifAssociativeArray") = invalid then return invalid

    indexKey = ""
    if IsString(metadataOrKey)
        indexKey = metadataOrKey
    else
        indexKey = sabr_cache_computeIndexKey(metadataOrKey)
    end if
    if indexKey = "" then return invalid

    return ctx.segmentIndexes.Lookup(indexKey)
end function

function sabr_cache_cloneObject(value as dynamic) as dynamic
    if not isValid(value) then return invalid
    clone = invalid
    try
        serialized = FormatJson(value)
        if isValid(serialized) and serialized <> ""
            clone = ParseJson(serialized)
        end if
    catch e
        clone = invalid
    end try
    if not isValid(clone) then clone = value
    return clone
end function

sub sabr_cache_collectEntries(ctx as object, filter as object, into as object)
    if GetInterface(ctx?.entries, "ifAssociativeArray") = invalid then return
    desiredContent = `${filter?.contentType ?? ""}`
    desiredItag = `${filter?.itag ?? ""}`
    desiredXtags = `${filter?.xtags ?? ""}`
    includeInit = filter?.includeInit = true
    maxCount = sabr_cache_toInt(filter?.maxCount)
    collected = 0

    for each entryKey in ctx.entries
        if maxCount <> invalid and collected >= maxCount then exit for
        entry = ctx.entries.Lookup(entryKey)
        if not isValid(entry) then continue for
        if entry.isInit = true and includeInit = false then continue for
        entryContent = `${entry?.contentType ?? ""}`
        if desiredContent <> "" and LCase(entryContent) <> LCase(desiredContent) then continue for
        entryItag = `${entry?.itag ?? ""}`
        if desiredItag <> "" and entryItag <> desiredItag then continue for
        entryXtags = `${entry?.xtags ?? ""}`
        if desiredXtags <> "" and entryXtags <> desiredXtags then continue for

        descriptor = {
            cacheKey: entryKey
            rangeStart: sabr_cache_toNumber(entry?.rangeStart)
            rangeEnd: sabr_cache_toNumber(entry?.rangeEnd)
            sequenceNumber: sabr_cache_toInt(entry?.sequenceNumber)
            headerId: entry?.headerId
            isInit: entry?.isInit
            storedAt: entry?.storedAt
            size: entry?.size
            metadata: sabr_cache_cloneObject(entry?.metadata)
        }
        into.push(descriptor)
        collected = collected + 1
    end for
end sub

function sabr_cache_inferRangeForByteRange(ctx as object, metadata as dynamic, byteRange as dynamic, fallbackLength = invalid as dynamic) as dynamic
    index = sabr_cache_getSegmentIndex(ctx, metadata)
    if not isValid(index) then return invalid

    startVal = sabr_cache_toNumber(byteRange?.startRange)
    if startVal = invalid then startVal = sabr_cache_toNumber(byteRange?.start)
    endVal = sabr_cache_toNumber(byteRange?.endRange)
    if endVal = invalid then endVal = sabr_cache_toNumber(byteRange?.end)

    match = invalid
    if startVal <> invalid or endVal <> invalid
        match = sabr_cache_findIndexEntryForRange(index, startVal, endVal, byteRange)
        if not isValid(match) and startVal <> invalid and fallbackLength <> invalid and fallbackLength > 0
            candidateEnd = startVal + fallbackLength - 1
            match = sabr_cache_findIndexEntryForRange(index, startVal, candidateEnd, byteRange)
        end if
    end if

    sequenceVal = sabr_cache_toNumber(byteRange?.sequenceNumber)
    if sequenceVal = invalid and isValid(metadata)
        sequenceVal = sabr_cache_toNumber(metadata?.sequenceNumber)
    end if
    if not isValid(match) and sequenceVal <> invalid
        match = sabr_cache_findIndexEntryBySequence(index, sequenceVal)
    end if

    headerId = invalid
    if isValid(byteRange?.headerId) then headerId = byteRange.headerId
    if not isValid(headerId) and isValid(metadata?.headerId) then headerId = metadata.headerId
    if not isValid(match) and isValid(headerId)
        match = sabr_cache_findIndexEntryByHeader(index, headerId)
    end if

    if not isValid(match) then return invalid

    startOut = sabr_cache_toNumber(match?.rangeStart)
    endOut = sabr_cache_toNumber(match?.rangeEnd)
    if startOut = invalid then return invalid
    if endOut = invalid
        refSize = sabr_cache_toNumber(match?.referenceSize)
        if refSize <> invalid and refSize > 0
            endOut = startOut + refSize - 1
        else if fallbackLength <> invalid and fallbackLength > 0
            endOut = startOut + fallbackLength - 1
        end if
    end if

    result = {
        rangeStart: startOut
        rangeEnd: endOut
    }
    if isValid(match?.sequenceNumber) then result["sequenceNumber"] = match.sequenceNumber
    if isValid(match?.subsegmentDuration) then result["subsegmentDuration"] = match.subsegmentDuration
    if isValid(match?.headerId) then result["headerId"] = match.headerId
    return result
end function

function sabr_cache_findIndexEntryForRange(index as dynamic, startVal as dynamic, endVal as dynamic, metadata = invalid as dynamic) as dynamic
    references = index?.references
    if GetInterface(references, "ifArray") = invalid then return invalid

    matched = invalid
    refCount = references.count()

    if startVal <> invalid
        for i = 0 to refCount - 1
            ref = references[i]
            if GetInterface(ref, "ifAssociativeArray") <> invalid
                refStart = sabr_cache_toNumber(ref?.rangeStart)
                refEnd = sabr_cache_toNumber(ref?.rangeEnd)
                if refEnd = invalid and startVal <> invalid
                    refSize = sabr_cache_toNumber(ref?.referenceSize)
                    if refSize <> invalid and refSize > 0
                        refEnd = refStart + refSize - 1
                    end if
                end if
                if refStart <> invalid and refEnd <> invalid
                    if startVal >= refStart and startVal <= refEnd
                        ref["index"] = i
                        matched = ref
                        exit for
                    end if
                end if
            end if
        end for
    end if

    if not isValid(matched) and endVal <> invalid
        for i = 0 to refCount - 1
            ref = references[i]
            if GetInterface(ref, "ifAssociativeArray") <> invalid
                refStart = sabr_cache_toNumber(ref?.rangeStart)
                refEnd = sabr_cache_toNumber(ref?.rangeEnd)
                if refEnd = invalid
                    refSize = sabr_cache_toNumber(ref?.referenceSize)
                    if refSize <> invalid and refSize > 0
                        refEnd = refStart + refSize - 1
                    end if
                end if
                if refStart <> invalid and refEnd <> invalid
                    if endVal >= refStart and endVal <= refEnd
                        ref["index"] = i
                        matched = ref
                        exit for
                    end if
                end if
            end if
        end for
    end if

    if isValid(matched) then return matched
    return invalid
end function

function sabr_cache_findIndexEntryBySequence(index as dynamic, sequenceNumber as dynamic) as dynamic
    seqVal = sabr_cache_toNumber(sequenceNumber)
    if seqVal = invalid then return invalid
    references = index?.references
    if GetInterface(references, "ifArray") = invalid then return invalid

    for i = 0 to references.count() - 1
        ref = references[i]
        if GetInterface(ref, "ifAssociativeArray") = invalid then continue for
        refSeq = sabr_cache_toNumber(ref?.sequenceNumber)
        if refSeq = invalid then continue for
        if refSeq = seqVal
            ref["index"] = i
            return ref
        end if
    end for
    return invalid
end function

function sabr_cache_findIndexEntryByHeader(index as dynamic, headerId as dynamic) as dynamic
    if not isValid(headerId) then return invalid
    references = index?.references
    if GetInterface(references, "ifArray") = invalid then return invalid
    for i = 0 to references.count() - 1
        ref = references[i]
        if GetInterface(ref, "ifAssociativeArray") = invalid then continue for
        if ref?.headerId = headerId
            ref["index"] = i
            return ref
        end if
    end for
    return invalid
end function

sub sabr_cache_attachSegmentToIndex(ctx as object, metadata as dynamic, entry as dynamic, cacheKey = "" as string)
    if not isValid(metadata) then return
    if GetInterface(ctx.segmentIndexes, "ifAssociativeArray") = invalid then return

    index = sabr_cache_getSegmentIndex(ctx, metadata)
    if not isValid(index) then return

    range = sabr_cache_extractRangeFromEntry(entry)
    if not isValid(range)
        inferred = sabr_cache_inferRangeForByteRange(ctx, metadata, metadata, entry?.size)
        if isValid(inferred)
            range = { start: inferred.rangeStart, end: inferred.rangeEnd }
            entry["rangeStart"] = inferred.rangeStart
            entry["rangeEnd"] = inferred.rangeEnd
        else
            return
        end if
    end if

    matched = sabr_cache_findIndexEntryForRange(index, range.start, range.end, metadata)
    if not isValid(matched)
        matched = sabr_cache_findIndexEntryBySequence(index, metadata?.sequenceNumber)
    end if
    if not isValid(matched) then return

    seqVal = sabr_cache_toNumber(metadata?.sequenceNumber)
    if seqVal = invalid then seqVal = sabr_cache_toNumber(entry?.sequenceNumber)
    if seqVal = invalid then seqVal = sabr_cache_toNumber(matched?.sequenceNumber)
    if seqVal = invalid then seqVal = matched?.index

    matched["sequenceNumber"] = seqVal
    matched["headerId"] = metadata?.headerId ?? entry?.headerId
    matched["cacheKey"] = cacheKey
    matched["rangeStart"] = range.start
    matched["rangeEnd"] = range.end
    matched["referenceSize"] = sabr_cache_toNumber(matched?.referenceSize)
    matched["lastUpdatedAt"] = sabr_cache_timestamp()

    if isValid(seqVal) then entry["sequenceNumber"] = seqVal

    references = index?.references
    if GetInterface(references, "ifArray") <> invalid and isValid(matched?.index)
        references[matched.index] = matched
        index["references"] = references
    end if

    indexKey = index?.indexKey
    if indexKey = "" then indexKey = sabr_cache_computeIndexKey(metadata)
    if indexKey <> ""
        ctx.segmentIndexes[indexKey] = index
    end if
end sub

function sabr_cache_toNumber(value as dynamic) as dynamic
    if not isValid(value) then return invalid
    if IsInteger(value) or IsFloat(value) or IsDouble(value)
        return value * 1.0
    else if IsString(value)
        trimmed = value.trim()
        if trimmed = "" then return invalid
        return Val(trimmed)
    end if
    return invalid
end function

function sabr_cache_listSegments(ctx as object, filter = invalid as dynamic) as object
    results = []
    if GetInterface(ctx, "ifAssociativeArray") = invalid then return results
    params = filter
    if not isValid(params) then params = {}
    sabr_cache_collectEntries(ctx, params, results)
    count = results.count()
    if count <= 1 then return results
    for i = 0 to count - 2
        for j = i + 1 to count - 1
            left = results[i]
            right = results[j]
            leftStart = sabr_cache_toNumber(left?.rangeStart)
            rightStart = sabr_cache_toNumber(right?.rangeStart)
            if leftStart = invalid then leftStart = 9223372036854775807.0
            if rightStart = invalid then rightStart = 9223372036854775807.0
            if rightStart < leftStart
                temp = results[i]
                results[i] = results[j]
                results[j] = temp
            end if
        end for
    end for
    return results
end function

function sabr_cache_sanitizeLabel(label as string) as string
    if not isValid(label)
        return "unknown"
    end if
    result = ""
    total = Len(label)
    if total = 0
        return "unknown"
    end if
    for i = 1 to total
        ch = Mid(label, i, 1)
        ascii = Asc(ch)
        if (ascii >= 48 and ascii <= 57) or (ascii >= 65 and ascii <= 90) or (ascii >= 97 and ascii <= 122) or ch = "-" or ch = "_"
            result = result + LCase(ch)
        else if ch = ":" or ch = "|"
            result = result + "-"
        else
            result = result + "_"
        end if
    end for
    if result = ""
        result = "unknown"
    end if
    return result
end function

function sabr_cache_trimLabel(label as string, maxLen as integer) as string
    if maxLen <= 0 then return ""
    if not isValid(label) then return ""
    if Len(label) <= maxLen then return label
    return Left(label, maxLen)
end function

function sabr_cache_toSafeString(value as dynamic) as string
    if not isValid(value) then return ""
    if IsString(value)
        return value
    else if IsNumber(value)
        return Str(value).trim()
    end if
    return Str(value).trim()
end function

function sabr_cache_timestamp() as integer
    dt = CreateObject("roDateTime")
    if GetInterface(dt, "ifDateTime") = invalid then return 0
    return (dt.AsSeconds() * 1000) + dt.GetMilliseconds()
end function
