import "pkg:/source/ytproto/generated/runtime.brs"
import "pkg:/source/ytproto/generated/messages/VideoPlaybackAbrRequest.brs"
import "pkg:/source/ytproto/generated/messages/ClientAbrState.brs"
import "pkg:/source/ytproto/generated/messages/FormatId.brs"
import "pkg:/source/ytproto/generated/messages/StreamerContext.brs"
import "pkg:/source/ytproto/generated/messages/ClientInfo.brs"
import "pkg:/source/ytproto/generated/messages/TimeRange.brs"
import "pkg:/source/ytproto/generated/messages/BufferedRange.brs"
import "pkg:/source/ytproto/generated/messages/StreamerContext.brs"  
import "pkg:/source/ytproto/generated/messages/SabrContext.brs"
import "pkg:/source/ytproto/generated/messages/GLDeviceInfo.brs"
import "pkg:/source/ytproto/generated/messages/MediaCapabilities.brs"
import "pkg:/source/ytproto/generated/messages/VideoFormatCapability.brs"
import "pkg:/source/ytproto/generated/messages/AudioFormatCapability.brs"
import "pkg:/source/ytproto/generated/messages/PlaybackAuthorization.brs"
import "pkg:/source/ytproto/generated/messages/AuthorizedFormat.brs"
import "pkg:/source/ytproto/generated/messages/Range.brs"
import "pkg:/source/ytproto/generated/messages/PlaybackCookie.brs"
import "pkg:/source/ytproto/generated/messages/UnknownInnerMessage.brs"
import "pkg:/source/ytproto/generated/messages/UnknownInnerMessage1.brs"
import "pkg:/source/ytproto/generated/messages/UnknownMessage3.brs"
import "pkg:/source/ytproto/generated/messages/VideoStreamingBufferedRangeUnknownMessage1.brs"
import "pkg:/source/ytproto/generated/messages/VideoStreamingBufferedRangeUnknownMessage2.brs"
import "pkg:/source/ytproto/generated/messages/VideoStreamingStreamerContextUnknownMessage1.brs"
import "pkg:/source/ytproto/generated/messages/VideoStreamingUnknownMessage1.brs"
import "pkg:/source/ytproto/generated/messages/VideoStreamingUnknownMessage2.brs"
import "pkg:/source/SabrUmpProcessor.bs"
import "pkg:/source/SabrSimpleCache.bs"
import "pkg:/source/SabrRequestMetadataManager.bs"
import "pkg:/source/isItem.bs"
import "pkg:/source/httpRequest.bs"
import "pkg:/source/taskUtils.bs"

const SABR_REPEAT_SEGMENT_THRESHOLD = 2
const SABR_REPEAT_SEGMENT_WINDOW_MS = 5000

function getHeaderByteRange(request as object) as object
    range = "bytes=0-"
    if isValid(request.headers.Range)
        range = request.headers.Range
    else if isValid(request.headers.range)
        range = request.headers.range
    end if
    ' split the range into start and end
    parts = range.Split("=")[1].Split("-")
    if parts.count() = 2
        startRange = parts[0]
        endRange = parts[1]
    end if
    return { startRange: startRange, endRange: endRange }
end function

function collectBufferedRangesForFormat(mediaIdHash as string, formatType as string, activeFormat as object) as object
    ranges = []
    if not isValid(activeFormat) then return ranges
    if not isValid(mediaIdHash) or mediaIdHash = "" then return ranges

    entries = sabrCacheListEntries(mediaIdHash, formatType, activeFormat?.itag, activeFormat?.audioTrackId ?? "")
    if GetInterface(entries, "ifArray") = invalid or entries.count() = 0 then return ranges

    segmentEntries = []
    for each entry in entries
        if entry?.isInit = true then continue for
        segmentEntries.push(entry)
    end for
    if segmentEntries.count() = 0 then return ranges

    sortedEntries = sortCacheEntriesBySegment(segmentEntries)
    seen = {}
    for each entry in sortedEntries
        metadata = buildMetadataFromCacheEntry(entry, activeFormat, formatType)
        rangeEntry = buildBufferedRangeFromMetadata(metadata)
        if isValid(rangeEntry)
            startKey = rangeEntry?.startSegmentIndex
            if startKey = invalid then startKey = rangeEntry?.rangeStart
            label = `${startKey ?? ""}`
            if label <> ""
                if seen.DoesExist(label)
                    continue for
                end if
                seen[label] = true
            end if
            ranges.push(rangeEntry)
            if ranges.count() >= 6
                exit for
            end if
        end if
    end for

    return ranges
end function

function computeNextPlaybackTime(ranges as object, formatType as string) as dynamic
    if GetInterface(ranges, "ifArray") = invalid or ranges.count() = 0 then return invalid

    latest = invalid
    latestIndex = -2147483647

    for each range in ranges
        if GetInterface(range, "ifAssociativeArray") = invalid then continue for

        idx = toInt(range?.startSegmentIndex)
        if idx = invalid then idx = toInt(range?.sequenceNumber)
        if idx = invalid then idx = toInt(range?.rangeStart)

        if idx = invalid then continue for
        if idx >= latestIndex
            latestIndex = idx
            latest = range
        end if
    end for

    if not isValid(latest) then return invalid

    startMs = toInt(latest?.startTimeMs)
    if startMs = invalid then startMs = toInt(latest?.startMs)
    if startMs = invalid
        startTicks = toInt(latest?.timeRange?.startTicks)
        timescale = toInt(latest?.timeRange?.timescale)
        if startTicks <> invalid and timescale <> invalid and timescale <> 0
            startMs = int((startTicks * 1000) / timescale)
        end if
    end if
    if startMs = invalid then startMs = 0

    durationMs = toInt(latest?.durationMs)
    if durationMs = invalid
        durationTicks = toInt(latest?.timeRange?.durationTicks)
        timescale = toInt(latest?.timeRange?.timescale)
        if durationTicks <> invalid and timescale <> invalid and timescale <> 0
            durationMs = int((durationTicks * 1000) / timescale)
        end if
    end if

    ' if durationMs = invalid or durationMs < 0 then durationMs = 0

    ' if durationMs = 0
    '     if formatType = "AUDIO"
    '         durationMs = 9985
    '     else if formatType = "VIDEO"
    '         durationMs = 7000
    '     end if
    ' end if

    return startMs + durationMs
end function

function buildBufferedState(mediaIdHash as string, currentFormat as object, activeFormats as object, playbackContext as object, requestedFormatType as string) as object
    rangesByType = {}
    rangesByType["AUDIO"] = []
    rangesByType["VIDEO"] = []

    state = {
        "formatToDiscard": invalid
        "rangesByType": rangesByType
        "playerTimeMs": invalid
    }

    currentFormatKey = formatToKey(currentFormat)
    activeFormatKeys = [ "audioFormat", "videoFormat" ]

    for each fieldName in activeFormatKeys
        format = activeFormats[fieldName]
        if not isValid(format)
            if fieldName = "audioFormat" and isValid(activeFormats.audioFormat)
                format = activeFormats.audioFormat
            else if fieldName = "videoFormat" and isValid(activeFormats.videoFormat)
                format = activeFormats.videoFormat
            end if
        end if

        if not isValid(format) then continue for

        formatType = formatTypeFromFormat(format)
        if formatType = "" then formatType = "UNKNOWN"

        if not state.rangesByType.DoesExist(formatType)
            state.rangesByType[formatType] = []
        end if

        shouldDiscard = formatToKey(format) <> currentFormatKey
        bufferedRanges = []
        if shouldDiscard
            bufferedRanges = [ createFullBufferRange(format) ]
            if not isValid(state.formatToDiscard)
                state.formatToDiscard = format
            end if
        else
            bufferedRanges = collectBufferedRangesForFormat(mediaIdHash, formatType, format)
        end if

        if GetInterface(bufferedRanges, "ifArray") <> invalid
            for each bufferedRange in bufferedRanges
                if isValid(bufferedRange)
                    state.rangesByType[formatType].push(bufferedRange)
                end if
            end for
        else if isValid(bufferedRanges)
            state.rangesByType[formatType].push(bufferedRanges)
        end if
    end for

    playerRanges = invalid
    if state.rangesByType.DoesExist(requestedFormatType)
        playerRanges = state.rangesByType.Lookup(requestedFormatType)
    end if

    ' if activeFormats.videoFormat.itag = 160
    '     stop
    ' end if
    playerTimeCandidate = computeNextPlaybackTime(playerRanges, requestedFormatType)
    if playerTimeCandidate <> invalid and playerTimeCandidate >= 0
        state.playerTimeMs = playerTimeCandidate
    else
        state.playerTimeMs = resolveFallbackPlayerTimeMs(playbackContext, currentFormat)
    end if

    return state
end function

function applyBufferedStateToRequest(videoPlaybackAbrRequest as object, bufferState as object) as dynamic
    if GetInterface(bufferState, "ifAssociativeArray") = invalid then return invalid

    rangeMap = bufferState?.rangesByType
    if GetInterface(rangeMap, "ifAssociativeArray") <> invalid
        for each rangeType in rangeMap
            ranges = rangeMap[rangeType]
            if GetInterface(ranges, "ifArray") <> invalid
                for each bufferedRange in ranges
                    if isValid(bufferedRange)
                        videoPlaybackAbrRequest.bufferedRanges.push(bufferedRange)
                    end if
                end for
            end if
        end for
    end if

    return bufferState?.formatToDiscard
end function


function sortCacheEntriesBySegment(entries as object) as object
    if GetInterface(entries, "ifArray") = invalid then return entries
    sorted = []
    for each item in entries
        sorted.push(item)
    end for
    total = sorted.count()
    if total <= 1 then return sorted

    for i = 0 to total - 2
        for j = i + 1 to total - 1
            left = sorted[i]
            right = sorted[j]
            leftIndex = toInt(left?.startSegmentIndex)
            if leftIndex = invalid then leftIndex = toInt(left?.sequenceNumber)
            if leftIndex = invalid then leftIndex = toInt(left?.rangeStart)
            rightIndex = toInt(right?.startSegmentIndex)
            if rightIndex = invalid then rightIndex = toInt(right?.sequenceNumber)
            if rightIndex = invalid then rightIndex = toInt(right?.rangeStart)
            if leftIndex = invalid then leftIndex = 2147483647
            if rightIndex = invalid then rightIndex = 2147483647
            if rightIndex < leftIndex
                temp = sorted[i]
                sorted[i] = sorted[j]
                sorted[j] = temp
            end if
        end for
    end for
    return sorted
end function

function sabr_entryItagValue(entry as object) as dynamic
    if GetInterface(entry, "ifAssociativeArray") = invalid then return invalid
    raw = entry?.itag
    if not isValid(raw) then return invalid
    if IsInteger(raw) then return raw
    if IsFloat(raw) or IsDouble(raw) then return int(raw)
    if IsString(raw)
        trimmed = raw.trim()
        if trimmed = "" then return invalid
        parsed = toInt(trimmed)
        if parsed <> invalid then return parsed
        return trimmed
    end if
    return raw
end function

function sabr_copyFormatId(source as object) as object
    if GetInterface(source, "ifAssociativeArray") = invalid then return invalid
    copy = {}
    for each key in source
        copy[key] = source[key]
    end for
    return copy
end function

function sabr_resolveFormatIdForCacheEntry(entry as object, fallback as dynamic, activeFormat as object) as object
    formatId = invalid
    if GetInterface(fallback, "ifAssociativeArray") <> invalid
        fallbackId = fallback?.formatId
        if GetInterface(fallbackId, "ifAssociativeArray") <> invalid
            formatId = sabr_copyFormatId(fallbackId)
        end if
    end if

    entryItag = sabr_entryItagValue(entry)
    if entryItag <> invalid
        if GetInterface(formatId, "ifAssociativeArray") = invalid
            formatId = {}
        end if
        formatId["itag"] = entryItag
    end if

    if GetInterface(formatId, "ifAssociativeArray") <> invalid
        existingXtags = invalid
        if formatId.DoesExist("xtags")
            existingXtags = formatId.Lookup("xtags")
        end if
        xtagsMissing = true
        if isValid(existingXtags)
            xtagsMissing = sabr_valueToLabel(existingXtags) = ""
        end if
        if xtagsMissing
            candidate = invalid
            if GetInterface(fallback?.formatId, "ifAssociativeArray") <> invalid and fallback.formatId.DoesExist("xtags")
                candidate = fallback.formatId.Lookup("xtags")
            else if isValid(activeFormat?.xtags)
                candidate = activeFormat.xtags
            end if
            if isValid(candidate) then formatId["xtags"] = candidate
        end if
        existingLastModified = invalid
        if formatId.DoesExist("lastModified")
            existingLastModified = formatId.Lookup("lastModified")
        end if
        lastModifiedMissing = true
        if isValid(existingLastModified)
            lastModifiedMissing = sabr_valueToLabel(existingLastModified) = ""
        end if
        if lastModifiedMissing
            candidate = invalid
            if GetInterface(fallback?.formatId, "ifAssociativeArray") <> invalid and fallback.formatId.DoesExist("lastModified")
                candidate = fallback.formatId.Lookup("lastModified")
            else if isValid(activeFormat?.lastModified)
                candidate = activeFormat.lastModified
            end if
            if isValid(candidate) then formatId["lastModified"] = candidate
        end if
    else
        formatId = formatToFormatId(activeFormat)
    end if

    if GetInterface(formatId, "ifAssociativeArray") = invalid
        formatId = formatToFormatId(activeFormat)
    end if

    return formatId
end function

function buildMetadataFromCacheEntry(entry as object, activeFormat as object, formatType as string) as dynamic
    if GetInterface(entry, "ifAssociativeArray") = invalid then return invalid

    metadata = {}
    metadata["formatId"] = sabr_resolveFormatIdForCacheEntry(entry, entry, activeFormat)

    rangeStartVal = toInt(entry?.rangeStart)
    rangeEndVal = toInt(entry?.rangeEnd)

    startIndex = toInt(entry?.startSegmentIndex)
    if startIndex = invalid then startIndex = toInt(entry?.sequenceNumber)
    if startIndex = invalid and rangeStartVal <> invalid then startIndex = rangeStartVal
    if startIndex = invalid then return invalid

    endIndex = toInt(entry?.endSegmentIndex)
    if endIndex = invalid then endIndex = toInt(entry?.sequenceNumber)
    if endIndex = invalid then endIndex = startIndex

    startTimeVal = toInt(entry?.startTimeMs)
    if startTimeVal = invalid then startTimeVal = toInt(entry?.startMs)
    startTicksVal = toInt(entry?.startTicks)
    durationMsVal = toInt(entry?.durationMs)
    durationTicksVal = toInt(entry?.durationTicks)

    timescaleVal = toInt(entry?.timescale)
    if timescaleVal = invalid or timescaleVal <= 0
        timescaleVal = toInt(entry?.timeRange?.timescale)
    end if
    if timescaleVal = invalid or timescaleVal <= 0
        if formatType = "AUDIO"
            timescaleVal = 48000
        else
            timescaleVal = 1000
        end if
    end if

    if startTimeVal = invalid and startTicksVal <> invalid and timescaleVal > 0
        startTimeVal = int((startTicksVal * 1000) / timescaleVal)
    end if
    if startTicksVal = invalid and startTimeVal <> invalid and timescaleVal > 0
        startTicksVal = int((startTimeVal * timescaleVal) / 1000)
    end if

    if durationMsVal = invalid and durationTicksVal <> invalid and timescaleVal > 0
        durationMsVal = int((durationTicksVal * 1000) / timescaleVal)
    end if
    if durationTicksVal = invalid and durationMsVal <> invalid and timescaleVal > 0
        durationTicksVal = int((durationMsVal * timescaleVal) / 1000)
    end if

    if startTimeVal = invalid then startTimeVal = 0
    if startTimeVal < 0 then startTimeVal = 0
    if durationMsVal = invalid then durationMsVal = 0
    if durationMsVal < 0 then durationMsVal = 0
    if startTicksVal = invalid then startTicksVal = int((startTimeVal * timescaleVal) / 1000)
    if durationTicksVal = invalid then durationTicksVal = int((durationMsVal * timescaleVal) / 1000)
    if startTicksVal = invalid then startTicksVal = 0
    if startTicksVal < 0 then startTicksVal = 0
    if durationTicksVal = invalid then durationTicksVal = 0
    if durationTicksVal < 0 then durationTicksVal = 0

    metadata["startSequenceNumber"] = startIndex
    metadata["endSequenceNumber"] = endIndex
    metadata["sequenceNumber"] = toInt(entry?.sequenceNumber)
    if metadata["sequenceNumber"] = invalid then metadata["sequenceNumber"] = startIndex

    metadata["startTimeMs"] = startTimeVal.toStr()
    metadata["startMs"] = metadata["startTimeMs"]
    metadata["durationMs"] = durationMsVal.toStr()
    metadata["timescale"] = timescaleVal
    metadata["timeRange"] = {
        "timescale": timescaleVal
        "startTicks": startTicksVal
        "durationTicks": durationTicksVal
    }

    if rangeStartVal <> invalid then metadata["rangeStart"] = rangeStartVal
    if rangeEndVal <> invalid then metadata["rangeEnd"] = rangeEndVal

    return metadata
end function

function isInit(contentType as string, format as object, requestByteRange as object, requestRef = invalid as dynamic) as boolean
    logTag = sabr_utilLogTag(contentType, requestRef)
    if rangesMatch(format?.initRange, requestByteRange)
        m.logs.printl(log_level_Type.INFO, `${logTag} SABR format itag ${format.itag} init range requested: ${FormatJson(requestByteRange)}`)
        return true
    end if

    if rangesMatch(format?.indexRange, requestByteRange)
        m.logs.printl(log_level_Type.INFO, `${logTag} SABR format itag ${format.itag} index range requested: ${FormatJson(requestByteRange)}`)
        return true
    end if
    return false
end function

' Returns mediaIdHash (string) or invalid if not found
function extractMediaIdHash(url as string) as dynamic
    ' /sabr/<anything-not-a-slash>(optional slash)
    re = CreateObject("roRegex", "/sabr/([^/]+)/?", "i")
    m = re.Match(url)
    if m.Count() >= 2 then return m[1]
    return invalid
end function

function zeroPadDigits(value as integer, width as integer) as string
    if IsString(value)
        strValue = value
    else if IsInteger(value)
        strValue = value.toStr()
    else if IsNumber(value)
        strValue = Str(value).trim()
    else
        strValue = Str(value).trim()
    end if

    if width <= 0 then return strValue
    while Len(strValue) < width
        strValue = "0" + strValue
    end while
    return strValue
end function

sub ensureSabrInfrastructure()
    sabrCacheSetLogger(m.logs)
    sabrCacheEnsureBasePath()
    if not isValid(m.sabrRequestMetadataManager)
        m.sabrRequestMetadataManager = createSabrRequestMetadataManager()
    end if
end sub

function buildSabrCacheKey(mediaIdHash as string, contentType as string, format as object, byteRange as object, isInitSegment as boolean) as string
    keyParts = []

    mediaIdLabel = sabr_valueToLabel(mediaIdHash)
    if mediaIdLabel <> "" then keyParts.push(mediaIdLabel)

    contentTypeLabel = sabr_valueToLabel(contentType)
    if contentTypeLabel <> "" then keyParts.push(contentTypeLabel)

    itagLabel = sabr_valueToLabel(format?.itag)
    if itagLabel = "" then itagLabel = sabr_valueToLabel(format?.formatId?.itag)
    if itagLabel <> "" then keyParts.push(itagLabel)

    xtagsLabel = sabr_valueToLabel(format?.xtags)
    if xtagsLabel = "" and isValid(format?.formatId)
        xtagsLabel = sabr_valueToLabel(format.formatId?.xtags)
    end if
    if xtagsLabel <> "" then keyParts.push(xtagsLabel)

    trackLabel = sabr_valueToLabel(format?.audioTrackId)
    if trackLabel <> "" then keyParts.push(trackLabel)

    if isInitSegment
        keyParts.push("init")
    else
        startRange = sabr_valueToLabel(byteRange?.startRange)
        if startRange = "" then startRange = sabr_valueToLabel(byteRange?.start)
        if startRange = "" then startRange = "0"
        endRange = sabr_valueToLabel(byteRange?.endRange)
        if endRange = "" then endRange = sabr_valueToLabel(byteRange?.end)
        if startRange <> "" and endRange <> ""
            keyParts.push(`${startRange}-${endRange}`)
        else if startRange <> ""
            keyParts.push(`${startRange}`)
        else
            keyParts.push("segment")
        end if
    end if

    return joinWithPipe(keyParts)
end function

function buildPrefetchInfo(streamInfo as object, currentFormat as object, requestMetadataEntry as object) as object
    if not isValid(streamInfo) then return invalid
    mediaHeader = streamInfo.mediaHeader
    if not isValid(mediaHeader) then return invalid

    startTimeMs = safeToInt(mediaHeader.startTimeMs)
    durationMs = safeToInt(mediaHeader.durationMs)
    endTimeMs = startTimeMs + durationMs

    return {
        formatKey: formatToKey(currentFormat)
        endTimeMs: endTimeMs
        durationMs: durationMs
        cacheKey: requestMetadataEntry?.cacheKey
        byteRange: requestMetadataEntry?.byteRange
        updatedAt: sabrCurrentTimestampMs()
        requestNumber: requestMetadataEntry?.requestNumber
    }
end function

sub maybeSchedulePrefetch(playbackContext as object, videoNode as object, prefetchInfo as object, contentType as string)
    if not isValid(playbackContext) then return
    if not isValid(prefetchInfo) then return
    if not isValid(videoNode) then return

    currentPositionMs = int((videoNode.position ?? 0) * 1000)
    remainingMs = prefetchInfo.endTimeMs - currentPositionMs

    playbackContext["prefetchState"] = prefetchInfo

    if remainingMs <= 5000 and remainingMs > -500
        if prefetchInfo.prefetchLogged <> true
            prefetchInfo.prefetchLogged = true
            prefetchInfo.loggedAt = sabrCurrentTimestampMs()
            playbackContext["prefetchState"] = prefetchInfo
            logTag = sabr_utilLogTag(contentType, prefetchInfo?.requestNumber)
            m.logs.printl(log_level_Type.INFO, `${logTag} Prefetch window reached for cache key ${prefetchInfo.cacheKey}; remainingMs=${remainingMs}`)
        end if
    end if
end sub

function safeToInt(value as dynamic) as integer
    if not isValid(value) then return 0
    if IsInteger(value)
        return value
    else if IsFloat(value) or IsDouble(value)
        return int(value)
    else if IsString(value)
        return value.toInt()
    else
        return 0
    end if
end function

function joinWithPipe(parts as object) as string
    if not isValid(parts) then return ""
    total = parts.count()
    if total = 0 then return ""
    result = ""
    for i = 0 to total - 1
        piece = parts[i] ?? ""
        if result <> "" then result = `${result}|`
        result = `${result}${piece}`
    end for
    return result
end function

function sabrCurrentTimestampMs() as integer
    dt = CreateObject("roDateTime")
    if GetInterface(dt, "ifDateTime") = invalid then return 0
    return (dt.AsSeconds() * 1000) + dt.GetMilliseconds()
end function

function sabr_valueToLabel(value as dynamic) as string
    if not isValid(value) then return ""
    if IsString(value)
        trimmed = value.trim()
        if trimmed = "" then return ""
        if Instr(1, trimmed, "e") > 0 or Instr(1, trimmed, "E") > 0
            numeric = trimmed.toFloat()
            if numeric <> invalid
                return sabr_valueToLabel(numeric)
            end if
        end if
        return trimmed
    end if
    if IsInteger(value)
        return value.toStr()
    end if
    if IsFloat(value) or IsDouble(value)
        precise = FormatJson(value)
        if precise <> "" and Instr(1, precise, "e") = 0 and Instr(1, precise, "E") = 0
            return precise
        end if
        intVal = int(value)
        if Abs(value - intVal) < 0.000001
            return intVal.toStr()
        end if
        strVal = Str(value).trim()
        if Instr(1, strVal, "e") > 0 or Instr(1, strVal, "E") > 0
            return FormatJson(int(value))
        end if
        return strVal
    end if
    return Str(value).trim()
end function

function formatRequestedRangeForPath(byteRange as object) as string
    if not isValid(byteRange) then return "none"
    startLabel = sabr_valueToLabel(byteRange?.startRange)
    if startLabel = "" then startLabel = sabr_valueToLabel(byteRange?.start)
    endLabel = sabr_valueToLabel(byteRange?.endRange)
    if endLabel = "" then endLabel = sabr_valueToLabel(byteRange?.end)
    if startLabel <> "" and endLabel <> ""
        return `${startLabel}-${endLabel}`
    else if startLabel <> ""
        return `${startLabel}-`
    else if endLabel <> ""
        return `-${endLabel}`
    end if
    return "none"
end function

function nextDumpSequence() as integer
    if not isValid(m.sabrDumpSequence)
        m.sabrDumpSequence = 0
    end if
    m.sabrDumpSequence = m.sabrDumpSequence + 1
    return m.sabrDumpSequence
end function

function buildSegmentCacheKeyForRange(format as object, byteRange as object) as string
    if not isValid(format) then return ""
    startLabel = sabr_valueToLabel(byteRange?.startRange)
    if startLabel = "" then startLabel = sabr_valueToLabel(byteRange?.start)
    if startLabel = "" then startLabel = "0"
    endLabel = sabr_valueToLabel(byteRange?.endRange)
    if endLabel = "" then endLabel = sabr_valueToLabel(byteRange?.end)
    if endLabel = "" then endLabel = "0"
    if startLabel = "" and endLabel = "" then return ""
    rangeLabel = startLabel
    if startLabel <> "" and endLabel <> ""
        rangeLabel = `${startLabel}-${endLabel}`
    end if

    itagPart = `${format?.itag ?? ""}`
    xtagsPart = `${format?.xtags ?? ""}`

    return `${rangeLabel}-${itagPart}-${xtagsPart}`
end function

sub logCoverageDiagnostics(info as object)
    if not isValid(info) then return
    logTag = info?.logTag ?? "[coverage]"
    cacheKey = info?.cacheKey ?? ""
    requested = info?.requested
    coverage = info?.coverage
    requestedLabel = formatRequestedRangeForPath(requested)
    coverageLabel = ""
    if isValid(coverage)
        coverageLabel = `${coverage?.rangeStart ?? "?"}-${coverage?.rangeEnd ?? "?"}`
    end if
    m.logs.printl(log_level_Type.DEBUG, `${logTag} Coverage diagnostics key=${cacheKey} requested=${requestedLabel} coverage=${coverageLabel} sequence=${coverage?.sequenceNumber ?? requested?.sequenceNumber ?? "?"}`)
end sub

function buildRepeatRequestKey(contentType as string, format as object, byteRange as object) as string
    if not isValid(byteRange) then return ""
    segmentKey = buildSegmentCacheKeyForRange(format, byteRange)
    if segmentKey = "" then return ""
    typeLabel = contentType ?? ""
    if typeLabel = "" then typeLabel = "UNKNOWN"
    return `${typeLabel}|${segmentKey}`
end function

function streamInfoKey(contentType as string, format as object) as string
    keyPart = formatToKey(format)
    if keyPart = ""
        keyPart = "unknown"
    end if
    typePart = contentType ?? ""
    if typePart = "" then typePart = "UNKNOWN"
    return `${typePart}|${keyPart}`
end function

function toInt(value as dynamic) as dynamic
    if not isValid(value) then return invalid
    if IsInteger(value) then return value
    if IsFloat(value) or IsDouble(value) then return int(value)
    if IsString(value)
        trimmed = value.trim()
        if trimmed = "" then return invalid
        return trimmed.toInt()
    end if
    return invalid
end function

function storeStreamInfoForFormat(playbackContext as object, contentType as string, format as object, streamInfo as object) as void
    if not isValid(playbackContext) then return
    if not isValid(streamInfo) then return
    key = streamInfoKey(contentType, format)
    if key = "" then return

    map = playbackContext?.streamInfoByFormat
    if GetInterface(map, "ifAssociativeArray") = invalid
        map = createObject("roAssociativeArray")
    end if
    map[key] = streamInfo
    playbackContext["streamInfoByFormat"] = map
end function

function fetchStreamInfoForFormat(playbackContext as object, contentType as string, format as object) as dynamic
    if not isValid(playbackContext) then return invalid
    key = streamInfoKey(contentType, format)
    if key = "" then return invalid
    map = playbackContext?.streamInfoByFormat
    if GetInterface(map, "ifAssociativeArray") = invalid then return invalid
    info = map.Lookup(key)
    if isValid(info) then return info
    return invalid
end function

function guardRepeatedRequests(playbackContext as object, contentType as string, currentFormat as object, requestMetadataEntry as object, requestNumber as string, videoNode as object, mediaIdHash as string) as dynamic
    if not isValid(playbackContext) then return invalid
    if requestMetadataEntry?.isInit = true then return invalid

    repeatKey = buildRepeatRequestKey(contentType, currentFormat, requestMetadataEntry?.byteRange)
    if repeatKey = "" then return invalid
    requestMetadataEntry["repeatKey"] = repeatKey

    nowTs = sabrCurrentTimestampMs()
    logTag = sabr_utilLogTag(contentType, requestNumber)
    repeatState = playbackContext?.repeatRequestState
    consecutiveCount = 1
    lastKey = ""
    lastCount = 0
    lastUpdated = invalid
    successStreak = 0
    failureStreak = 0

    if GetInterface(repeatState, "ifAssociativeArray") <> invalid
        lastKey = repeatState?.lastKey ?? ""
        lastCount = toInt(repeatState?.count)
        lastUpdated = toInt(repeatState?.updatedAt)
        successStreak = toInt(repeatState?.successStreak)
        failureStreak = toInt(repeatState?.failureStreak)
    end if

    if lastKey = repeatKey and lastCount <> invalid and lastCount > 0
        if lastUpdated = invalid or (nowTs - lastUpdated) <= SABR_REPEAT_SEGMENT_WINDOW_MS
            consecutiveCount = lastCount + 1
        end if
    else
        successStreak = 0
        failureStreak = 0
    end if

    rangeLabel = formatRequestedRangeForPath(requestMetadataEntry?.byteRange)
    newState = {
        lastKey: repeatKey
        count: consecutiveCount
        updatedAt: nowTs
        lastRequestNumber: requestNumber
        range: rangeLabel
        formatKey: formatToKey(currentFormat)
        successStreak: successStreak
        failureStreak: failureStreak
        lastResult: repeatState?.lastResult ?? ""
        lastStatus: repeatState?.lastStatus
    }
    playbackContext["repeatRequestState"] = newState

    if successStreak < SABR_REPEAT_SEGMENT_THRESHOLD then return invalid

    fatalMessage = `Repeated SABR requests detected for segment ${repeatKey} (range ${rangeLabel}); aborting playback`
    playbackContext["sabrFatalError"] = {
        reason: fatalMessage
        requestNumber: requestNumber
        timestamp: nowTs
    }
    newState["aborted"] = true
    playbackContext["repeatRequestState"] = newState

    m.logs.printl(log_level_Type.WARN, `${logTag} ${fatalMessage}`)

    if isValid(videoNode)
        try
            videoNode.control = "stop"
        catch e
            m.logs.printl(log_level_Type.DEBUG, `${logTag} Failed to stop video node after repeat guard: ${e?.message}`)
        end try
    end if

    serialized = FormatJson(playbackContext)
    if isValid(serialized) and serialized <> ""
        writeFile(`tmp:/${mediaIdHash}/playbackContext.json`, serialized)
    end if

    return buildErrorResponseForPlayer(502, fatalMessage)
end function

sub recordRepeatResult(playbackContext as object, requestMetadataEntry as object, response as object)
    if not isValid(playbackContext) then return
    repeatKey = `${requestMetadataEntry?.repeatKey ?? ""}`
    if repeatKey = "" then return

    repeatState = playbackContext?.repeatRequestState
    if GetInterface(repeatState, "ifAssociativeArray") = invalid then return
    if `${repeatState?.lastKey ?? ""}` <> repeatKey then return

    statusVal = toInt(response?.status)
    success = false
    if statusVal <> invalid
        if statusVal = 206 or (statusVal >= 200 and statusVal < 300)
            success = true
        end if
    end if

    successCount = toInt(repeatState?.successStreak)
    if successCount = invalid then successCount = 0
    failureCount = toInt(repeatState?.failureStreak)
    if failureCount = invalid then failureCount = 0

    if success
        repeatState["successStreak"] = successCount + 1
        repeatState["failureStreak"] = 0
    else
        repeatState["failureStreak"] = failureCount + 1
        repeatState["successStreak"] = 0
    end if

    repeatState["lastResult"] = success ? "success" : "failure"
    repeatState["lastStatus"] = statusVal
    repeatState["updatedAt"] = sabrCurrentTimestampMs()

    playbackContext["repeatRequestState"] = repeatState
end sub

function formatTypeFromFormat(format as dynamic) as string
    mimeType = format?.mimeType ?? ""
    if mimeType.inStr("audio") > -1 then return "AUDIO"
    if mimeType.inStr("video") > -1 then return "VIDEO"
    if isValid(format?.width) then return "VIDEO"
    return "AUDIO"
end function

function mediaHeaderToSegmentMetadata(mediaHeader as dynamic, coverage = invalid as dynamic) as dynamic
    if not isValid(mediaHeader) then return invalid
    formatId = mediaHeader?.formatId
    if not isValid(formatId) then return invalid

    startSequenceNumber = toInt(mediaHeader?.sequenceNumber)
    endSequenceNumber = startSequenceNumber
    sequenceNumber = startSequenceNumber
    if sequenceNumber = invalid then sequenceNumber = toInt(coverage?.sequenceNumber)
    if sequenceNumber = invalid or sequenceNumber <= 0 then sequenceNumber = 1
    if startSequenceNumber = invalid or startSequenceNumber <= 0 then startSequenceNumber = sequenceNumber
    if endSequenceNumber = invalid or endSequenceNumber <= 0 then endSequenceNumber = sequenceNumber

    durationMs = mediaHeader?.durationMs ?? ""
    if durationMs = "" then durationMs = mediaHeader?.timeRange?.durationTicks ?? ""
    timescale = toInt(mediaHeader?.timeRange?.timescale)
    if timescale = invalid then timescale = 1000

    metadata = {
        "formatId": mediaHeader.formatId
        "startSequenceNumber": startSequenceNumber
        "endSequenceNumber": endSequenceNumber
        "sequenceNumber": sequenceNumber
        "startTimeMs": mediaHeader.startMs ?? "0"
        "durationMs": durationMs ?? "0"
        "timescale": timescale
        "timeRange": mediaHeader.timeRange
    }
    defaultStartRange = mediaHeader.startRange ?? mediaHeader.start ?? ""

    if isValid(coverage)
        if isValid(coverage?.rangeStart)
            metadata["rangeStart"] = coverage.rangeStart
        else if defaultStartRange <> ""
            metadata["rangeStart"] = defaultStartRange
        end if
        if isValid(coverage?.rangeEnd)
            metadata["rangeEnd"] = coverage.rangeEnd
        end if
        covSeq = toInt(coverage?.sequenceNumber)
        if covSeq <> invalid and covSeq > 0
            metadata["sequenceNumber"] = covSeq
            metadata["startSequenceNumber"] = covSeq
            metadata["endSequenceNumber"] = covSeq
        end if
        if isValid(coverage?.headerId)
            metadata["headerId"] = coverage.headerId
        end if
        if isValid(coverage?.cacheKey)
            metadata["cacheKey"] = coverage.cacheKey
        end if
    end if

    startRangeVal = toInt(metadata?.rangeStart)
    if startRangeVal = invalid
        if defaultStartRange <> ""
            metadata["rangeStart"] = defaultStartRange
            startRangeVal = toInt(defaultStartRange)
        end if
    end if
    if startRangeVal = invalid then startRangeVal = 0

    if not metadata.DoesExist("rangeEnd")
        contentLength = toInt(mediaHeader?.contentLength)
        if contentLength <> invalid and contentLength > 0
            metadata["rangeEnd"] = startRangeVal + contentLength - 1
        end if
    end if

    if not metadata.DoesExist("rangeStart")
        metadata["rangeStart"] = defaultStartRange
    end if
    if not metadata.DoesExist("rangeEnd")
        metadata["rangeEnd"] = startRangeVal
    end if

    startIdxVal = toInt(metadata?.startSequenceNumber)
    endIdxVal = toInt(metadata?.endSequenceNumber)
    startSeqProblem = startIdxVal = invalid or startIdxVal <= 0
    endSeqProblem = endIdxVal = invalid or endIdxVal <= 0
    if not endSeqProblem and startIdxVal <> invalid
        if endIdxVal < startIdxVal
            endSeqProblem = true
        end if
    end if
    if startSeqProblem or endSeqProblem
        headerLabel = mediaHeader?.headerId ?? ""
        m.logs.printl(log_level_Type.DEBUG, `[YTSABR-Meta] Missing segment sequence metadata; headerId=${headerLabel} headerSeq=${mediaHeader?.sequenceNumber} coverageSeq=${coverage?.sequenceNumber} startSeq=${metadata?.startSequenceNumber} endSeq=${metadata?.endSequenceNumber} startType=${Type(metadata?.startSequenceNumber)} endType=${Type(metadata?.endSequenceNumber)} computedStart=${startIdxVal} computedEnd=${endIdxVal} range=${metadata?.rangeStart}-${metadata?.rangeEnd}`)
    end if

    return metadata
end function

function sabr_segmentStartMs(metadata as dynamic) as dynamic
    if not isValid(metadata) then return invalid
    startMs = toInt(metadata?.startTimeMs)
    if startMs = invalid then startMs = toInt(metadata?.startMs)
    if startMs = invalid
        startTicks = toInt(metadata?.timeRange?.startTicks)
        timescale = toInt(metadata?.timeRange?.timescale)
        if startTicks <> invalid and timescale <> invalid and timescale <> 0
            startMs = int((startTicks * 1000) / timescale)
        end if
    end if
    return startMs
end function

function segmentDurationMs(metadata as dynamic) as dynamic
    if not isValid(metadata) then return invalid
    durationMs = toInt(metadata?.durationMs)
    if durationMs = invalid or durationMs <= 0
        durationTicks = toInt(metadata?.timeRange?.durationTicks)
        timescale = toInt(metadata?.timeRange?.timescale)
        if durationTicks <> invalid and timescale <> invalid and timescale <> 0
            durationMs = int((durationTicks * 1000) / timescale)
        end if
    end if
    return durationMs
end function

function sabr_lookupRecentMetadataBySequence(playbackContext as object, format as object, sequenceNumber as dynamic, contentType = "" as string) as dynamic
    seqVal = toInt(sequenceNumber)
    if seqVal = invalid then return invalid

    formatKey = formatToKey(format)
    initializedFormats = playbackContext?.initializedFormats
    if formatKey <> "" and GetInterface(initializedFormats, "ifAssociativeArray") <> invalid and initializedFormats.DoesExist(formatKey)
        formatState = initializedFormats.Lookup(formatKey)
        candidate = formatState?.lastSegmentMetadata
        if isValid(candidate) and toInt(candidate?.sequenceNumber) = seqVal
            return candidate
        end if
        recent = formatState?.recentSegmentMetadata
        if GetInterface(recent, "ifArray") <> invalid
            for i = recent.count() - 1 to 0
                meta = recent[i]
                if isValid(meta) and toInt(meta?.sequenceNumber) = seqVal
                    return meta
                end if
            end for
        end if
    end if

    if isValid(contentType)
        if contentType = "VIDEO"
            fallback = playbackContext?.lastVideoSegmentMetadata
        else if contentType = "AUDIO"
            fallback = playbackContext?.lastAudioSegmentMetadata
        else
            fallback = invalid
        end if
        if isValid(fallback) and toInt(fallback?.sequenceNumber) = seqVal
            return fallback
        end if
    end if

    return invalid
end function

function normalizeByteRange(rawRange as object, context = invalid as dynamic) as object
    normalized = {
        startRange: ""
        endRange: ""
    }

    if isValid(rawRange)
        startLabel = `${rawRange?.startRange ?? ""}`
        if startLabel = "" then startLabel = `${rawRange?.start ?? ""}`
        endLabel = `${rawRange?.endRange ?? ""}`
        if endLabel = "" then endLabel = `${rawRange?.end ?? ""}`
        if startLabel <> "" then normalized["startRange"] = startLabel
        if endLabel <> "" then normalized["endRange"] = endLabel
    end if

    if isValid(context?.segmentIndexInfo)
        normalized["segmentIndexInfo"] = context.segmentIndexInfo
    end if
    if isValid(context?.sequenceNumber)
        normalized["sequenceNumber"] = `${context.sequenceNumber}`
    end if

    return normalized
end function

function hasCompleteByteRange(byteRange as object) as boolean
    if not isValid(byteRange) then return false
    startLabel = `${byteRange?.startRange ?? ""}`
    if startLabel = "" then startLabel = `${byteRange?.start ?? ""}`
    endLabel = `${byteRange?.endRange ?? ""}`
    if endLabel = "" then endLabel = `${byteRange?.end ?? ""}`
    return startLabel <> "" and endLabel <> ""
end function

function byteRangeToCoverage(byteRange as object) as dynamic
    startVal = invalid
    endVal = invalid

    startLabel = `${byteRange?.startRange ?? ""}`
    if startLabel = "" then startLabel = `${byteRange?.start ?? ""}`
    if startLabel <> ""
        startVal = startLabel.toInt()
    end if

    endLabel = `${byteRange?.endRange ?? ""}`
    if endLabel = "" then endLabel = `${byteRange?.end ?? ""}`
    if endLabel <> ""
        endVal = endLabel.toInt()
    end if

    if not isValid(startVal) then return invalid
    if not isValid(endVal) then return invalid
    if endVal < startVal then return invalid

    return {
        "rangeStart": startVal
        "rangeEnd": endVal
    }
end function

function rangesMatch(rangeObj as dynamic, requestRange as object) as boolean
    if not isValid(rangeObj) then return false

    expectedStart = `${rangeObj?.start ?? "0"}`
    if expectedStart = "" then expectedStart = `${rangeObj?.startRange ?? "0"}`
    expectedEnd = `${rangeObj?.end ?? "0"}`
    if expectedEnd = "" then expectedEnd = `${rangeObj?.endRange ?? "0"}`

    requestStart = `${requestRange?.startRange ?? "0"}`
    if requestStart = "" then requestStart = `${requestRange?.start ?? "0"}`
    requestEnd = `${requestRange?.endRange ?? "0"}`
    if requestEnd = "" then requestEnd = `${requestRange?.end ?? "0"}`

    if expectedStart = "" or expectedEnd = "" then return false
    if requestStart = "" or requestEnd = "" then return false
    return (expectedStart = requestStart) and (expectedEnd = requestEnd)
end function


function getDumpLabel(playbackContext as object, prefix as string, requestNumber as string, byteRange as object, contentType = "" as string, format = invalid as dynamic) as string
    if not isValid(prefix) then prefix = "dump"
    rn = requestNumber
    if rn = ""
        rn = "unknown"
    end if
    rangePart = formatRequestedRangeForPath(byteRange)
    if rangePart = "" then rangePart = "none"

    contentLabel = contentType ?? ""
    if contentLabel = "" then contentLabel = playbackContext?.lastContentType ?? ""
    if contentLabel = ""
        contentLabel = "unknown"
    end if

    playbackContext["lastContentType"] = contentLabel

    itagLabel = ""
    if isValid(format)
        itagLabel = isValid(format?.itag) ? `${format.itag}` : ""
    end if
    if itagLabel = "" and isValid(playbackContext?.lastFormat)
        itagLabel = playbackContext.lastFormat?.itag ?? ""
    end if
    if itagLabel = "" then itagLabel = "noitag"

    if isValid(format)
        playbackContext["lastFormat"] = format
    end if

    batchIndex = isValid(playbackContext?.lastDumpIndex) ? `${playbackContext.lastDumpIndex}` : ""
    if batchIndex = "" then batchIndex = isValid(playbackContext?.requestSequence) ? `${playbackContext.requestSequence}` : ""
    if batchIndex = "" then batchIndex = rn

    counter =  m.top.utilsTask.callFunc("getNextId", "sabrDumpCounterBatch")

    seqLabel = nextDumpSequence()

    return `roku-player/${zeroPadDigits(seqLabel, 6)}-${prefix}-${contentLabel}-itag${itagLabel}-${batchIndex}-${counter}-${rn}-${rangePart}`
end function

sub roku_debugUploadText(debugUploadUrl as string, relativePath as string, text as string, logs = invalid as dynamic)
    if not isValid(text) then return
    payload = text
    if not IsString(payload)
        payload = `${payload} ?? ""`
    end if
    if payload = "" then return
    roku_debugUploadContent(debugUploadUrl, relativePath, payload, true, logs)
end sub

sub roku_debugUploadBytes(debugUploadUrl as string, relativePath as string, bytes as object, logs = invalid as dynamic)
    if not isValid(bytes) then return
    if GetInterface(bytes, "ifByteArray") = invalid then return
    roku_debugUploadContent(debugUploadUrl, relativePath, bytes, false, logs)
end sub

sub roku_debugUploadContent(debugUploadUrl as string, relativePath as string, content as dynamic, isText as boolean, logs = invalid as dynamic)
    baseUrl = `${debugUploadUrl ?? ""}`
    if baseUrl = "" then return

    originalPath = `${relativePath ?? ""}`
    if originalPath = ""
        originalPath = isText ? "roku-debug-request.json" : "roku-debug-bytes.bin"
    end if

    encodedPath = roku_urlEncode(originalPath)
    if encodedPath = "" then encodedPath = originalPath

    separator = "?"
    if Instr(baseUrl, "?") > 0
        separator = "&"
    end if
    url = `${baseUrl}${separator}path=${encodedPath}`

    transfer = CreateObject("roUrlTransfer")
    if LCase(Left(url, 5)) = "https"
        transfer.SetCertificatesFile("common:/certs/ca-bundle.crt")
        transfer.InitClientCertificates()
    end if
    transfer.SetRequest("POST")
    transfer.SetUrl(url)

    success = false

    if isText
        stringPayload = content
        if not IsString(stringPayload)
            stringPayload = `${stringPayload} ?? ""`
        end if
        if isValid(stringPayload) and stringPayload <> ""
            transfer.AddHeader("Content-Type", "application/json")
            success = transfer.PostFromString(stringPayload)
        end if
    else
        transfer.AddHeader("Content-Type", "application/octet-stream")
        tempDir = "tmp:/roku-debug"
        fs = CreateObject("roFileSystem")
        fs.CreateDirectory(tempDir)
        fileName = roku_sanitizeForFilename(originalPath)
        if fileName = "" then fileName = "roku-debug-bytes.bin"
        tmpFilePath = `${tempDir}/${fileName}`

        bytesRef = content
        wrote = false
        if GetInterface(bytesRef, "ifByteArray") <> invalid
            wrote = bytesRef.WriteFile(tmpFilePath)
        else
            byteCopy = CreateObject("roByteArray")
            if IsString(bytesRef)
                byteCopy.FromAsciiString(bytesRef)
            end if
            wrote = byteCopy.WriteFile(tmpFilePath)
        end if

        if wrote
            success = transfer.PostFromFile(tmpFilePath)
            fs.Delete(tmpFilePath)
        end if
    end if

    if success = true
        if isValid(logs)
            logs.printl(log_level_Type.DEBUG, `[YTSABR-Debug] Uploaded debug payload to ${url}`)
        end if
    else
        if isValid(logs)
            logs.printl(log_level_Type.WARN, `[YTSABR-Debug] Failed to upload debug payload to ${url}`)
        end if
    end if
end sub

function roku_sanitizeForFilename(value as string) as string
    if not isValid(value) then return ""
    sanitized = ""
    for i = 1 to Len(value)
        ch = Mid(value, i, 1)
        ascii = Asc(ch)
        if ch = "." or ch = "-" or ch = "_" or ch = " "
            sanitized = sanitized + ch
        else if ascii >= 48 and ascii <= 57
            sanitized = sanitized + ch
        else if ascii >= 65 and ascii <= 90
            sanitized = sanitized + ch
        else if ascii >= 97 and ascii <= 122
            sanitized = sanitized + ch
        else
            sanitized = sanitized + "_"
        end if
    end for
    return sanitized
end function

function roku_urlEncode(value as string) as string
    if not isValid(value) then return ""
    encoder = CreateObject("roUrlTransfer")
    return encoder.Escape(value)
end function

sub deleteFileIfExists(path as dynamic)
    if not isValid(path) then return
    if not IsString(path) then return
    if path = "" then return

    fs = CreateObject("roFileSystem")
    if fs.Exists(path)
        fs.Delete(path)
    end if
end sub

function sabr_extractRequestNumber(value as dynamic) as string
    if not isValid(value) then return ""

    if GetInterface(value, "ifAssociativeArray") <> invalid
        if value.DoesExist("requestNumber")
            return sabr_extractRequestNumber(value.requestNumber)
        end if
        return ""
    end if

    return sabr_valueToLabel(value)
end function

function sabr_utilLogTag(contentType as string, requestRef = invalid as dynamic) as string
    rn = sabr_extractRequestNumber(requestRef)
    if rn = ""
        return `[YTSABR-Util-${contentType}]`
    end if
    return `[YTSABR-Util-${contentType}-${rn}]`
end function

function sabrHandleRequest(request as object, contentType as string, mediaIdHash as string, sabr as object, videoNode as object, redirectDepth = 0 as integer) as object
    ok = true

    sabrAbrUrl = ""
    playbackContext = invalid
    response = invalid

    ' load the playbackContext.json file from tmp:/${mediaIdHash}/playbackContext.json
    fileContent = getFile(`tmp:/${mediaIdHash}/playbackContext.json`)
    if fileContent = "" then
        ok = false
        m.logs.printl(log_level_Type.WARN, `[YTSABR-Util-${contentType}] No SABR playbackContext file found for mediaIdHash: ${mediaIdHash}`)
    else
        playbackContext = ParseJson(fileContent)
        if not isValid(playbackContext)
            ok = false
            m.logs.printl(log_level_Type.WARN, `[YTSABR-Util-${contentType}] Invalid SABR playbackContext file for mediaIdHash: ${mediaIdHash}`)
        else
            m.logs.printl(log_level_Type.INFO, `[YTSABR-Util-${contentType}] Loaded SABR playbackContext from file for mediaIdHash: ${mediaIdHash}`)
        end if
    end if

    if not isValid(playbackContext)
        ok = false
        m.logs.printl(log_level_Type.WARN, `[YTSABR-Util-${contentType}] No SABR playback context available`)
    ' else
        ' m.logs.printl(log_level_Type.INFO, `SABR playback mediaId: ${FormatJson(playbackContext.sabrPayload)}`)
    end if

    fatalInfo = playbackContext?.sabrFatalError
    if isValid(fatalInfo)
        fatalReason = fatalInfo?.reason ?? "SABR fatal error"
        m.logs.printl(log_level_Type.WARN, `[YTSABR-Util-${contentType}] Blocking SABR request due to fatal error: ${fatalReason}`)
        return buildErrorResponseForPlayer(502, fatalReason)
    end if

    ensureSabrInfrastructure()
    metadataManager = m.sabrRequestMetadataManager
    debugUploadUrl = m.top.debugUploadUrl ?? ""

    formats = sabr?.adaptiveFormats
    if not isValid(formats) or formats.count() = 0
        formats = sabr?.hlsFormats
        if not isValid(formats) or formats.count() = 0
            ok = false
            m.logs.printl(log_level_Type.WARN, `[YTSABR-Util-${contentType}] No SABR formats available`)
        end if
    end if
    
    sabrAbrUrl = sabr?.serverAbrStreamingUrl
    if not isValid(sabrAbrUrl) or sabrAbrUrl = ""
        ok = false
        m.logs.printl(log_level_Type.WARN, `[YTSABR-Util-${contentType}] No SABR URL provided`)
    end if

    ' increment the request number
    ' nextRequestId = generateSabrRequestNumber(playbackContext, contentType)
    nextRequestId = m.top.utilsTask.callFunc("getNextId", "sabrRequestNumber")
    playbackContext["requestNumber"] = nextRequestId
    requestLogTag = sabr_utilLogTag(contentType, nextRequestId)
    m.logs.printl(log_level_Type.INFO, `${requestLogTag} SABR playback request number: ${nextRequestId}`)

    ' update the URL's rn param (or create it) to be the request number
    regexRn = CreateObject("roRegex", "([&?])rn=[^&]*", "i")
    if regexRn.match(sabrAbrUrl).count() > 0
        sabrAbrUrl = regexRn.replaceAll(sabrAbrUrl, `\1rn=${nextRequestId}`)
    else
        sep = sabrAbrUrl.inStr("?") > -1 ? "&" : "?"
        sabrAbrUrl = `${sabrAbrUrl}${sep}rn=${nextRequestId}`
    end if
    m.logs.printl(log_level_Type.INFO, `${requestLogTag} URL: ${sabrAbrUrl}`)

    ' originalUrl = request.path
    try
        if not isValid(request.search.key) or request.search.key = ""
            ok = false
            m.logs.printl(log_level_Type.WARN, `${requestLogTag} No SABR itag key provided`)
        else
            currentKey = request.search.key.toInt()
            currentFormat = invalid
            for each format in formats
                if format.itag = currentKey
                    currentFormat = format
                    exit for
                end if
            end for
        end if
    catch e
        ok = false
        m.logs.printl(log_level_Type.WARN, `${requestLogTag} Error finding format for itag: ${request.search.key} - ${e.message}`)
    end try

    if not isValid(currentFormat)
        ok = false
        m.logs.printl(log_level_Type.WARN, `${requestLogTag} No matching format for itag: ${request.search.key}`)
    end if

    activeFormats = getActiveFormats(currentFormat, sabr, playbackContext)

    requestByteRange = getHeaderByteRange(request)
    requestByteRange = normalizeByteRange(requestByteRange, {
        "mediaIdHash": mediaIdHash
        "contentType": contentType
        "format": currentFormat
    })
    m.logs.printl(log_level_Type.DEBUG, `${requestLogTag} Normalized byteRange start=${requestByteRange?.startRange ?? ""} end=${requestByteRange?.endRange ?? ""} seq=${requestByteRange?.sequenceNumber ?? ""}`)
    streamInfoForFormat = fetchStreamInfoForFormat(playbackContext, contentType, currentFormat)
    isInitSegmentRequest = isInit(contentType, currentFormat, requestByteRange, nextRequestId)

    formatKeyForLog = formatToKey(currentFormat)
    totalsForLog = playbackContext?.deliveredDurationTotals
    totalLogValue = invalid
    if GetInterface(totalsForLog, "ifAssociativeArray") <> invalid and formatKeyForLog <> "" and totalsForLog.DoesExist(formatKeyForLog)
        totalLogValue = totalsForLog.Lookup(formatKeyForLog)
    end if
    m.logs.printl(log_level_Type.DEBUG, `${requestLogTag} Resolving segment start; init=${isInitSegmentRequest} formatKey=${formatKeyForLog} totals=${totalLogValue}`)

    bufferState = buildBufferedState(mediaIdHash, currentFormat, activeFormats, playbackContext, contentType)
    playerTimeOverride = bufferState?.playerTimeMs
    if playerTimeOverride = invalid then playerTimeOverride = resolveFallbackPlayerTimeMs(playbackContext, currentFormat)
    rangeLabelForLog = formatRequestedRangeForPath(requestByteRange)
    m.logs.printl(log_level_Type.DEBUG, `${requestLogTag} Using playerTimeMs=${playerTimeOverride} for range ${rangeLabelForLog}`)

    sabrRequestJson = createVideoPlaybackAbrRequest(request, contentType, sabr, currentFormat, activeFormats, playbackContext, playerTimeOverride, videoNode, nextRequestId)

     if isValid(currentFormat.height) 
        sabrRequestJson.clientAbrState["stickyResolution"] = currentFormat.height
        sabrRequestJson.clientAbrState["lastManualSelectedResolution"] = currentFormat.height
     end if

    formatToDiscard = applyBufferedStateToRequest(sabrRequestJson, bufferState)
    if isValid(formatToDiscard)
        ' the formatToDiscard is the one that we are faking out the youtube server to "not" send us any data.
        ' in this way, if this is a video request, we can get the video segment data but not the audio and vice versa
        ' Sabr wants to send us both audio and video segments in the same response, but we only want one or the other
        sabrRequestJson.selectedFormatIds.push(formatToDiscard)
    end if

    cacheKey = buildSabrCacheKey(mediaIdHash, contentType, currentFormat, requestByteRange, isInitSegmentRequest)

    keyParam = request.search.key
    if keyParam = "" and isValid(request.search?.itag)
        keyParam = request.search.itag
    end if

    requestMetadataEntry = {
        "requestNumber": nextRequestId
        "isInit": isInitSegmentRequest
        "byteRange": {
            "start": requestByteRange.startRange
            "end": requestByteRange.endRange
            "startRange": requestByteRange.startRange
            "endRange": requestByteRange.endRange
            "sequenceNumber": requestByteRange.DoesExist("sequenceNumber") ? requestByteRange.sequenceNumber : invalid
            "segmentIndexInfo": requestByteRange.DoesExist("segmentIndexInfo") ? requestByteRange.segmentIndexInfo : invalid
        }
        "format": currentFormat
        "contentType": contentType
        "mediaIdHash": mediaIdHash
        "cacheKey": cacheKey
        "streamInfo": streamInfoForFormat
        "timestamp": sabrCurrentTimestampMs()
        "debugUploadUrl": debugUploadUrl
        "sabrKey": keyParam
        "requestPath": request.path
    }
    if requestByteRange.DoesExist("segmentIndexInfo")
        requestMetadataEntry["segmentIndexInfo"] = requestByteRange.segmentIndexInfo
    end if
    if requestByteRange.DoesExist("sequenceNumber")
        requestMetadataEntry["sequenceNumber"] = toInt(requestByteRange.sequenceNumber)
    end if
    if isValid(metadataManager)
        metadataManager.store(metadataManager, `${nextRequestId}`, requestMetadataEntry)
    end if

    repeatGuardResponse = guardRepeatedRequests(playbackContext, contentType, currentFormat, requestMetadataEntry, `${nextRequestId}`, videoNode, mediaIdHash)
    if isValid(repeatGuardResponse)
        return repeatGuardResponse
    end if

    cacheHit = false
    cacheLookupRange = formatRequestedRangeForPath(requestMetadataEntry.byteRange)
    cacheLookupLabel = `${cacheKey ?? ""}`
    if cacheLookupLabel = "" then cacheLookupLabel = "none"
    m.logs.printl(log_level_Type.DEBUG, `${requestLogTag} Cache lookup start isInit=${isInitSegmentRequest} key=${cacheLookupLabel} range=${cacheLookupRange}`)

    cacheEntry = sabrCacheLoadSegment({
        mediaIdHash: mediaIdHash
        contentType: contentType
        itag: currentFormat?.itag
        trackId: currentFormat?.audioTrackId
        requestedStart: requestMetadataEntry.byteRange?.startRange
        requestedEnd: requestMetadataEntry.byteRange?.endRange
        isInit: isInitSegmentRequest
    })

    if GetInterface(cacheEntry, "ifAssociativeArray") <> invalid and GetInterface(cacheEntry?.data, "ifByteArray") <> invalid and cacheEntry.data.count() > 0
        if not isValid(requestMetadataEntry.streamInfo)
            storedInfo = fetchStreamInfoForFormat(playbackContext, contentType, currentFormat)
            if isValid(storedInfo)
                requestMetadataEntry.streamInfo = storedInfo
            else if isValid(playbackContext.lastSabrStreamInfo)
                requestMetadataEntry.streamInfo = playbackContext.lastSabrStreamInfo
            end if
        end if

        cachedResult = {
            data: cacheEntry.data
            done: true
            coverage: {
                rangeStart: cacheEntry.rangeStart
                rangeEnd: cacheEntry.rangeEnd
            }
        }

        response = buildSabrResponseForPlayer(requestMetadataEntry, cachedResult, currentFormat, requestByteRange, contentType)
        prefetchInfo = buildPrefetchInfo(requestMetadataEntry.streamInfo, currentFormat, requestMetadataEntry)
        maybeSchedulePrefetch(playbackContext, videoNode, prefetchInfo, contentType)
        cacheHit = true
        pathLabel = cacheEntry?.path ?? ""
        if pathLabel <> "" and pathLabel.InStr("/") >= 0
            parts = pathLabel.Split("/")
            pathLabel = parts[parts.count() - 1]
        end if
        m.logs.printl(log_level_Type.INFO, `${requestLogTag} Cache hit path=${pathLabel} range=${cacheLookupRange} bytes=${cacheEntry.data.count()}`)
    end if

    if cacheHit = false
        m.logs.printl(log_level_Type.DEBUG, `${requestLogTag} Cache miss key=${cacheLookupLabel} range=${cacheLookupRange}`)
    end if
    batchCounter =  m.top.utilsTask.callFunc("getNextId", "sabrBatchCounter")
    playbackContext["lastDumpIndex"] = batchCounter
    requestMetadataEntry["batchIndex"] = batchCounter

    if not isInitSegmentRequest and isValid(currentFormat)
        sabrRequestJson.selectedFormatIds.push(currentFormat)
    end if

    if ok and not cacheHit
        ' clone the object as the encode will add snake case object keys alongside camel case ones
        playbackContext["lastSabrRequest"] = sabrRequestJson
        if debugUploadUrl <> ""
            requestPayloadJson = FormatJson(sabrRequestJson)
            if isValid(requestPayloadJson) and requestPayloadJson <> ""
                dumpLabel = getDumpLabel(playbackContext, "sabr-request", `${nextRequestId}`, requestMetadataEntry.byteRange, contentType, currentFormat)
                roku_debugUploadText(debugUploadUrl, `${dumpLabel}.json`, requestPayloadJson, m.logs)
            end if
        end if
        encodedProto = ""
        protoBytes = invalid
        protoFilePath = ""
        responseFilePath = ""
        try
            m.logs.printl(log_level_Type.INFO, `${requestLogTag} Encoding SABR proto for itag: ${currentFormat.itag}`)
            ' m.logs.printl(log_level_Type.VERBOSE, FormatJson(sabrRequestJson))
            encodedProto = VideoPlaybackAbrRequestEncode(sabrRequestJson)
            if IsString(encodedProto) and encodedProto <> ""
                protoBytes = CreateObject("roByteArray")
                protoBytes.FromBase64String(encodedProto)
                ' sanity check on the decode
                decodedProto = VideoPlaybackAbrRequestDecode(encodedProto)
                if not isValid(decodedProto)
                    ok = false
                    m.logs.printl(log_level_Type.WARN, `${requestLogTag} Error decoding SABR proto after encode`)
                else
                    ' m.logs.printl(log_level_Type.VERBOSE, `${requestLogTag} Decoded SABR proto: ${FormatJson(decodedProto)}`)
                    if debugUploadUrl <> ""
                        requestPayloadJson = FormatJson(decodedProto)
                        if isValid(requestPayloadJson) and requestPayloadJson <> ""
                            dumpLabel = getDumpLabel(playbackContext, "sabr-request-decode", `${nextRequestId}`, requestMetadataEntry.byteRange, contentType, currentFormat)
                            roku_debugUploadText(debugUploadUrl, `${dumpLabel}.json`, requestPayloadJson, m.logs)
                        end if
                    end if
                end if
            end if
        catch e
            ok = false
            m.logs.printl(log_level_Type.WARN, `${requestLogTag} Error encoding SABR proto: ${e.message}`)
        end try

        ' prepare the SABR request now
        if ok and IsValid(protoBytes)
            m.logs.printl(log_level_Type.INFO, `${requestLogTag} proto payload`)
            if playbackContext.hasVideoParts = true
                m.logs.printl(log_level_Type.INFO, `${requestLogTag} Sending SABR video request to URL: ${sabrAbrUrl}`)
                ' write the protoBytes to a file and send that file to the SABR URL
                protoFilePath = `tmp:/${mediaIdHash}/sabrRequest-${contentType}-${nextRequestId}.bin`
                protoBytes.writeFile(protoFilePath)
                sabrRequest = {
                    url: sabrAbrUrl, ' "http://192.168.119.94:8000/sabr"
                    requestType: "proxy",
                    timeout: 10000,
                    options: {
                        method: "POST_FILE_TO_FILE_WITH_DECODINGS",
                        body: protoFilePath
                    }
                }

                m.logs.printl(log_level_Type.INFO, `[RELAY] Performing proxied request to: ${FormatJson(sabrAbrUrl)}`)
                res = makeRequest(sabrRequest)
                if not isValid(res?.status) 
                    ok = false
                    m.logs.printl(log_level_Type.WARN, `${requestLogTag} No response status from SABR UMP request`)
                    response = buildErrorResponseForPlayer(500, "SABR request failed")
                else if res.status >= 200 and res?.status <= 206
                    responseFilePath = res.body
                    sabrUmpResponse = CreateObject("roByteArray")
                    if sabrUmpResponse.readFile(responseFilePath)
                        if sabrUmpResponse.count() > 0
                            m.logs.printl(log_level_Type.INFO, `${requestLogTag} SABR UMP response size: ${sabrUmpResponse.count()} bytes`)
                            requestMetadata = {
                                "isUMP": true
                                "isSABR": true
                                "isInit": isInitSegmentRequest
                                "requestNumber": nextRequestId
                                "format": currentFormat
                                "streamInfo": {}
                                "cacheKey": cacheKey
                                "debugUploadUrl": debugUploadUrl
                                "mediaIdHash": mediaIdHash
                                "contentType": contentType
                            }

                            if isValid(requestMetadataEntry.byteRange.start) and requestMetadataEntry.byteRange.start <> "" and isValid(requestMetadataEntry.byteRange.end) and requestMetadataEntry.byteRange.end <> ""
                                requestMetadata["byteRange"] = requestMetadataEntry.byteRange
                            end if

                            fatalReason = ""
                            segmentInfo = invalid
                            umpResult = invalid
                            segmentScanSummary = invalid
                            try
                                sabrUmpProcessor = createSabrUmpProcessor(requestMetadata, m.logs)
                                umpResult = sabrUmpProcessor.processChunk(sabrUmpResponse)
                                segmentInfo = sabrUmpProcessor.getSegmentInfo()
                                if sabrUmpProcessor.DoesExist("getSegmentScanSummary")
                                    segmentScanSummary = sabrUmpProcessor.getSegmentScanSummary()
                                end if
                            catch e
                                fatalReason = e?.message ?? ""
                                if fatalReason = "" then fatalReason = `${e}`
                                if fatalReason = "" then fatalReason = "SABR init processing failed"
                            end try

                            if fatalReason <> ""
                                playbackContext["sabrFatalError"] = {
                                    reason: fatalReason
                                    requestNumber: nextRequestId
                                    timestamp: sabrCurrentTimestampMs()
                                }
                                m.logs.printl(log_level_Type.WARN, `${requestLogTag} Fatal SABR error: ${fatalReason}`)
                                if response = invalid
                                    response = buildErrorResponseForPlayer(502, fatalReason)
                                end if
                            else
                                if isValid(segmentInfo)
                                    m.logs.printl(log_level_Type.INFO, `${requestLogTag} Segment info available after processing: ${FormatJson(segmentInfo)}`)
                                end if

                                if GetInterface(segmentScanSummary?.segments, "ifArray") <> invalid
                                    segmentCount = segmentScanSummary.segments.count()
                                    matchedFlag = segmentScanSummary?.matched
                                    if matchedFlag = invalid then matchedFlag = false
                                    m.logs.printl(log_level_Type.INFO, `${requestLogTag} SABR scan summary segments=${segmentCount} matched=${matchedFlag}`)
                                    for each scanEntry in segmentScanSummary.segments
                                        headerLabel = sabr_valueToLabel(scanEntry?.headerId)
                                        seqLabel = sabr_valueToLabel(scanEntry?.sequenceNumber)
                                        startLabel = sabr_valueToLabel(scanEntry?.start)
                                        matchedLabel = scanEntry?.matched
                                        if matchedLabel = invalid then matchedLabel = false
                                        m.logs.printl(log_level_Type.DEBUG, `${requestLogTag} SABR scan header=${headerLabel} seq=${seqLabel} start=${startLabel} matched=${matchedLabel}`)
                                    end for
                                end if

                                playbackContext["lastSabrStreamInfo"] = requestMetadata.streamInfo
                                playbackCookieValue = requestMetadata.playbackCookie
                                if isValid(playbackCookieValue) and playbackCookieValue <> ""
                                    playbackContext["lastPlaybackCookie"] = playbackCookieValue
                                    if isValid(sabr)
                                        sabr.playbackCookie = playbackCookieValue
                                    end if
                                end if
                                redirectUrl = requestMetadata.streamInfo?.redirect?.url ?? ""
                                redirectTriggered = false
                                if redirectUrl <> ""
                                    if isValid(sabr)
                                        sabr.serverAbrStreamingUrl = redirectUrl
                                    end if
                                    playbackContext["serverAbrStreamingUrl"] = redirectUrl
                                    m.logs.printl(log_level_Type.INFO, `${requestLogTag} Updated SABR server URL via redirect: ${redirectUrl}`)
                                    if not isValid(umpResult?.data) or umpResult.data.count() = 0
                                        redirectTriggered = true
                                    end if
                                end if
                                requestMetadataEntry.streamInfo = requestMetadata.streamInfo



                                if redirectTriggered
                                    if redirectDepth >= 3
                                        fatalReason = "SABR redirect limit reached"
                                        m.logs.printl(log_level_Type.WARN, `${requestLogTag} ${fatalReason}`)
                                    else
                                        m.logs.printl(log_level_Type.INFO, `${requestLogTag} Following SABR redirect to ${redirectUrl}`)
                                        deleteFileIfExists(responseFilePath)
                                        deleteFileIfExists(protoFilePath)
                                        writeFile(`tmp:/${mediaIdHash}/playbackContext.json`, FormatJson(playbackContext))
                                        return sabrHandleRequest(request, contentType, mediaIdHash, sabr, videoNode, redirectDepth + 1)
                                    end if
                                end if

                                if not isValid(umpResult)
                                    pendingSummary = []
                                    processedParts = []
                                    if GetInterface(sabrUmpProcessor, "ifAssociativeArray") <> invalid
                                        if sabrUmpProcessor.DoesExist("getPendingSegmentsSummary")
                                            pendingSummary = sabrUmpProcessor.getPendingSegmentsSummary()
                                        end if
                                        if sabrUmpProcessor.DoesExist("getProcessedPartTypes")
                                            processedParts = sabrUmpProcessor.getProcessedPartTypes()
                                        end if
                                    end if

                                    streamInfoKeys = []
                                    if GetInterface(requestMetadata?.streamInfo, "ifAssociativeArray") <> invalid
                                        for each infoKey in requestMetadata.streamInfo
                                            streamInfoKeys.push(infoKey)
                                        end for
                                    end if

                                    logDetails = {
                                        requestNumber: nextRequestId
                                        requestedRange: formatRequestedRangeForPath(requestMetadataEntry?.byteRange)
                                        requestedSequence: requestMetadataEntry?.sequenceNumber ?? "0"
                                        cacheKey: cacheKey
                                        processedParts: processedParts
                                        pendingSegments: pendingSummary
                                        streamInfoKeys: streamInfoKeys
                                        redirectUrl: redirectUrl
                                    }
                                    if isValid(requestMetadataEntry?.segmentIndexInfo)
                                        logDetails["segmentIndexInfo"] = requestMetadataEntry.segmentIndexInfo
                                    end if
                                    m.logs.printl(log_level_Type.INFO, `${requestLogTag} UMP payload missing terminal part; details=${FormatJson(logDetails)}`)
                                    response = buildEmptySabrResponseForPlayer(contentType, currentFormat)
                                else
                                    if isValid(umpResult?.data)
                                        m.logs.printl(log_level_Type.INFO, `${requestLogTag} UMP result data size: ${umpResult.data.count()}`)
                                    end if
                                    response = buildSabrResponseForPlayer(requestMetadata, umpResult, currentFormat, requestByteRange, contentType)

                                    segmentPayload = response?.fullBody
                                    if not isValid(segmentPayload)
                                        segmentPayload = response?.body
                                    end if

                                    deliveredSegment = false
                                    if isValid(response?.status)
                                        if response.status >= 200 and response.status < 300 and isValid(segmentPayload) and segmentPayload.count() > 0
                                            deliveredSegment = true
                                        end if
                                    end if

                                    if cacheKey <> "" and isValid(segmentPayload) and segmentPayload.count() > 0 and isValid(response?.status) and response.status >= 200 and response.status < 300
                                        if not isInitSegmentRequest
                                            coverageMeta = createObject("roAssociativeArray")
                                            coverage = invalid
                                            if hasCompleteByteRange(requestMetadataEntry.byteRange)
                                                coverage = byteRangeToCoverage(requestMetadataEntry.byteRange)
                                            end if
                                            if isValid(coverage)
                                                coverageMeta["rangeStart"] = coverage.rangeStart
                                                coverageMeta["rangeEnd"] = coverage.rangeEnd
                                            end if
                                            inferredStart = toInt(requestMetadataEntry.byteRange?.startRange)
                                            if inferredStart = invalid then inferredStart = toInt(requestMetadataEntry.byteRange?.start)
                                            inferredEnd = toInt(requestMetadataEntry.byteRange?.endRange)
                                            if inferredEnd = invalid then inferredEnd = toInt(requestMetadataEntry.byteRange?.end)
                                            if not isValid(coverageMeta?.rangeStart) and inferredStart <> invalid
                                                coverageMeta["rangeStart"] = inferredStart
                                            end if
                                            if not isValid(coverageMeta?.rangeEnd) and inferredEnd <> invalid
                                                coverageMeta["rangeEnd"] = inferredEnd
                                            end if
                                            coverageMeta["contentType"] = contentType
                                            coverageMeta["itag"] = currentFormat?.itag
                                            coverageMeta["xtags"] = currentFormat?.xtags
                                            coverageMeta["headerId"] = requestMetadata?.streamInfo?.mediaHeader?.headerId
                                            coverageMeta["mediaIdHash"] = mediaIdHash
                                            coverageMeta["byteRange"] = requestMetadataEntry.byteRange
                                            if isValid(requestMetadataEntry.segmentIndexKey)
                                                coverageMeta["segmentIndexKey"] = requestMetadataEntry.segmentIndexKey
                                            end if
                                            if isValid(requestMetadataEntry.segmentIndexInfo)
                                                idxInfo = requestMetadataEntry.segmentIndexInfo
                                                if not isValid(coverageMeta?.rangeStart) and isValid(idxInfo?.rangeStart)
                                                    coverageMeta["rangeStart"] = toInt(idxInfo.rangeStart)
                                                end if
                                                if not isValid(coverageMeta?.rangeEnd) and isValid(idxInfo?.rangeEnd)
                                                    coverageMeta["rangeEnd"] = toInt(idxInfo.rangeEnd)
                                                end if
                                                if isValid(idxInfo?.sequenceNumber)
                                                    coverageMeta["sequenceNumber"] = toInt(idxInfo.sequenceNumber)
                                                end if
                                            end if
                                            if not isValid(coverageMeta?.sequenceNumber) and isValid(requestMetadataEntry.sequenceNumber)
                                                coverageMeta["sequenceNumber"] = requestMetadataEntry.sequenceNumber
                                            end if
                                            headerMeta = requestMetadata?.streamInfo?.mediaHeader
                                            if isValid(headerMeta)
                                                if not isValid(coverageMeta?.formatId)
                                                    coverageMeta["formatId"] = headerMeta?.formatId
                                                end if
                                                if not isValid(coverageMeta?.durationMs)
                                                    coverageMeta["durationMs"] = headerMeta?.durationMs ?? headerMeta?.timeRange?.durationTicks
                                                end if
                                                if not isValid(coverageMeta?.startTimeMs)
                                                    coverageMeta["startTimeMs"] = headerMeta?.startMs ?? headerMeta?.startTimeMs
                                                end if
                                                if not isValid(coverageMeta?.timeRange)
                                                    coverageMeta["timeRange"] = headerMeta?.timeRange
                                                end if
                                                headerSeq = toInt(headerMeta?.sequenceNumber)
                                                if headerSeq <> invalid
                                                    if not isValid(coverageMeta?.sequenceNumber)
                                                        coverageMeta["sequenceNumber"] = headerSeq
                                                    end if
                                                    if not isValid(coverageMeta?.startSequenceNumber)
                                                        coverageMeta["startSequenceNumber"] = headerSeq
                                                    end if
                                                    if not isValid(coverageMeta?.endSequenceNumber)
                                                        coverageMeta["endSequenceNumber"] = headerSeq
                                                    end if
                                                end if
                                            end if
                                            coverageStartLabel = sabr_valueToLabel(coverageMeta?.rangeStart)
                                            coverageEndLabel = sabr_valueToLabel(coverageMeta?.rangeEnd)
                                            requestedRangeLabel = formatRequestedRangeForPath(requestMetadataEntry.byteRange)
                                            segmentStartIndex = coverageMeta?.startSequenceNumber
                                            if not isValid(segmentStartIndex)
                                                segmentStartIndex = coverageMeta?.sequenceNumber
                                            end if
                                            segmentEndIndex = coverageMeta?.endSequenceNumber
                                            if not isValid(segmentEndIndex)
                                                segmentEndIndex = segmentStartIndex
                                            end if
                                            segmentStartTime = coverageMeta?.startTimeMs
                                            if not isValid(segmentStartTime)
                                                segmentStartTime = coverageMeta?.startMs
                                            end if
                                            segmentDuration = coverageMeta?.durationMs
                                            segmentTimescale = coverageMeta?.timeRange?.timescale
                                            if not isValid(segmentTimescale)
                                                segmentTimescale = coverageMeta?.timescale
                                            end if
                                            segmentStartTicks = coverageMeta?.timeRange?.startTicks
                                            segmentDurationTicks = coverageMeta?.timeRange?.durationTicks

                                            startTimeInt = toInt(segmentStartTime)
                                            durationInt = toInt(segmentDuration)
                                            timescaleInt = toInt(segmentTimescale)
                                            if segmentStartTicks = invalid and startTimeInt <> invalid and timescaleInt <> invalid and timescaleInt > 0
                                                segmentStartTicks = int((startTimeInt * timescaleInt) / 1000)
                                            end if
                                            if segmentDurationTicks = invalid and durationInt <> invalid and timescaleInt <> invalid and timescaleInt > 0
                                                segmentDurationTicks = int((durationInt * timescaleInt) / 1000)
                                            end if

                                            storagePath = sabrCacheBuildFilename(
                                                mediaIdHash,
                                                contentType,
                                                currentFormat?.itag,
                                                currentFormat?.audioTrackId ?? "",
                                                isInitSegmentRequest,
                                                coverageMeta?.rangeStart,
                                                coverageMeta?.rangeEnd
                                            )
                                            storageLabel = storagePath
                                            if storageLabel <> "" and storageLabel.InStr("/") >= 0
                                                parts = storageLabel.Split("/")
                                                storageLabel = parts[parts.count() - 1]
                                        end if
                                        if not isValid(segmentStartIndex)
                                            segmentStartIndex = coverageMeta?.sequenceNumber
                                        end if
                                        if not isValid(segmentEndIndex)
                                            segmentEndIndex = coverageMeta?.endSequenceNumber
                                            if not isValid(segmentEndIndex)
                                                segmentEndIndex = segmentStartIndex
                                            end if
                                        end if
                                        storeOptions = {
                                            mediaIdHash: mediaIdHash
                                            contentType: contentType
                                            itag: currentFormat?.itag
                                            trackId: currentFormat?.audioTrackId
                                            rangeStart: coverageMeta?.rangeStart
                                            rangeEnd: coverageMeta?.rangeEnd
                                            isInit: isInitSegmentRequest
                                            bytes: segmentPayload
                                            startSegmentIndex: segmentStartIndex
                                            endSegmentIndex: segmentEndIndex
                                            sequenceNumber: coverageMeta?.sequenceNumber
                                            startTimeMs: segmentStartTime
                                            durationMs: segmentDuration
                                            timescale: segmentTimescale
                                            startTicks: segmentStartTicks
                                            durationTicks: segmentDurationTicks
                                            formatId: formatToFormatId(currentFormat)
                                        }
                                        if storeOptions.itag = invalid and isValid(currentFormat?.formatId)
                                            storeOptions.itag = currentFormat.formatId?.itag
                                        end if
                                        if storeOptions.sequenceNumber = invalid and isValid(segmentStartIndex)
                                            storeOptions.sequenceNumber = segmentStartIndex
                                        end if
                                        if isInitSegmentRequest
                                            storeOptions.rangeStart = 0
                                            storeOptions.rangeEnd = segmentPayload.count() - 1
                                        end if
                                        storeResult = sabrCacheStoreSegment(storeOptions)
                                        storagePath = storeResult?.path ?? storagePath
                                        storageLabel = storagePath
                                        if storageLabel <> "" and storageLabel.InStr("/") >= 0
                                            parts = storageLabel.Split("/")
                                            storageLabel = parts[parts.count() - 1]
                                        end if
                                        m.logs.printl(log_level_Type.DEBUG, `${requestLogTag} Coverage stored path=${storageLabel} requested=${requestedRangeLabel} coverage=${coverageStartLabel}-${coverageEndLabel} bytes=${segmentPayload.count()} itag=${currentFormat?.itag}`)
                                        requestMetadataEntry.cacheKey = storagePath
                                        cacheKey = storagePath
                                            deliveredSegment = true
                                            logCoverageDiagnostics({
                                                logTag: requestLogTag
                                                cacheKey: storageLabel
                                                requested: requestMetadataEntry.byteRange
                                                coverage: coverageMeta
                                            })
                                            if isValid(requestMetadata.streamInfo) and GetInterface(requestMetadata.streamInfo, "ifAssociativeArray") <> invalid
                                                requestMetadata.streamInfo["deliveredCoverage"] = coverageMeta
                                            end if
                                        end if
                                        m.logs.printl(log_level_Type.INFO, `${requestLogTag} Cached SABR response under key: ${cacheKey}`)
                                    end if

                                    if isValid(metadataManager)
                                        metadataManager.store(metadataManager, `${nextRequestId}`, requestMetadataEntry)
                                    end if

                                    prefetchInfo = buildPrefetchInfo(requestMetadataEntry.streamInfo, currentFormat, requestMetadataEntry)
                                    maybeSchedulePrefetch(playbackContext, videoNode, prefetchInfo, contentType)

                                    applyStreamInfoUpdates(playbackContext, requestMetadata.streamInfo, contentType, deliveredSegment, requestMetadataEntry)
                                    if deliveredSegment = true
                                        storeStreamInfoForFormat(playbackContext, contentType, currentFormat, requestMetadata.streamInfo)
                                        ' if isValid(requestMetadata.streamInfo)
                                        '     updateEstimatedPlayerTime(playbackContext, requestMetadata.streamInfo)
                                        ' end if
                                    end if
                                    if isValid(requestMetadata.streamInfo) and GetInterface(requestMetadata.streamInfo, "ifAssociativeArray") <> invalid
                                        if requestMetadata.streamInfo.DoesExist("deliveredCoverage")
                                            requestMetadata.streamInfo.Delete("deliveredCoverage")
                                        end if
                                    end if
                                end if
                            end if
                        else
                            m.logs.printl(log_level_Type.WARN, `${requestLogTag} SABR UMP response was empty`)
                            response = buildErrorResponseForPlayer(502, "Empty SABR response")
                        end if
                    else
                        m.logs.printl(log_level_Type.WARN, `${requestLogTag} Failed to read SABR UMP response file`)
                        response = buildErrorResponseForPlayer(500, "Failed to read SABR response")
                    end if
                else
                    m.logs.printl(log_level_Type.WARN, `${requestLogTag} SABR UMP request failed with status: ${res?.status}`)
                    response = buildErrorResponseForPlayer(`${res?.status ?? 0}`.toInt(), `SABR request failed`)
                end if
            else
                m.logs.printl(log_level_Type.INFO, `${requestLogTag} ignoring audio SABR request for now`)
            end if
        else
            m.logs.printl(log_level_Type.WARN, `${requestLogTag} No valid SABR proto bytes to send`)
        end if

        deleteFileIfExists(responseFilePath)
        deleteFileIfExists(protoFilePath)

    end if

    if debugUploadUrl <> "" and isValid(response) and isValid(response.body)
        bytesCount = 0
        if GetInterface(response.body, "ifByteArray") <> invalid
            bytesCount = response.body.count()
        end if
        m.logs.printl(log_level_Type.INFO, `${requestLogTag} Response body size=${bytesCount} bytes for request ${nextRequestId}`)
        dumpBase = getDumpLabel(playbackContext, "response", `${nextRequestId}`, requestByteRange, contentType, currentFormat)
        roku_debugUploadBytes(debugUploadUrl, dumpBase + "-bytes", response.body, m.logs)

        responseInfo = {
            "status": response.status
            "headers": response.headers
            "cacheKey": cacheKey
            "isInit": isInitSegmentRequest
            "requestNumber": nextRequestId
            "contentType": contentType
        }
        roku_debugUploadText(debugUploadUrl, dumpBase + "-meta.json", FormatJson(responseInfo), m.logs)
    end if

    recordRepeatResult(playbackContext, requestMetadataEntry, response)

    if GetInterface(response.headers, "ifAssociativeArray") <> invalid and not response.headers.DoesExist("Content-Range")
        response.headers["X-Cache-Range"] = formatRequestedRangeForPath(requestByteRange)
    end if

    ' write the playbackContext to the playbackContext.json file to preserve state
    m.logs.printl(log_level_Type.INFO, `${requestLogTag} Storing SABR playbackContext to file for mediaIdHash: ${mediaIdHash}`)
    ' m.logs.printl(log_level_Type.VERBOSE, FormatJson(playbackContext))
    writeFile(`tmp:/${mediaIdHash}/playbackContext.json`, FormatJson(playbackContext))

    return response

end function

function getActiveFormats(currentFormat as object, sabr as object, playbackContext as object) as object
    formats = sabr.adaptiveFormats
    videoFormat = invalid
    audioFormat = invalid

    mimeType = currentFormat?.mimeType ?? ""
    if mimeType.inStr("video") > -1 or isValid(currentFormat?.width)
        videoFormat = currentFormat
    else if mimeType.inStr("audio") > -1 or not isValid(currentFormat?.width)
        audioFormat = currentFormat
    end if

    if not isValid(videoFormat)
        videoFormat = playbackContext?.lastVideoFormat
    end if
    if not isValid(audioFormat)
        audioFormat = playbackContext?.lastAudioFormat
    end if

    if not isValid(videoFormat)
        videoFormat = pickBestFormat(formats, "video")
    end if
    if not isValid(audioFormat)
        audioFormat = pickBestFormat(formats, "audio")
    end if

    if isValid(videoFormat)
        playbackContext["lastVideoFormat"] = videoFormat
    end if
    if isValid(audioFormat)
        playbackContext["lastAudioFormat"] = audioFormat
    end if

    return {
        "videoFormat": videoFormat,
        "audioFormat": audioFormat
    }
end function

function pickBestFormat(formats as dynamic, mediaType as string) as dynamic
    if not isValid(formats) then return invalid
    bestFormat = invalid
    bestBitrate = 0
    targetKeyword = mediaType = "audio" ? "audio" : "video"

    for each format in formats
        mimeType = format?.mimeType ?? ""
        if mimeType.inStr(targetKeyword) > -1
            bitrate = toInt(format?.bitrate)
            if bitrate = invalid then bitrate = toInt(format?.averageBitrate)
            if bitrate <> invalid and bitrate > bestBitrate
                bestBitrate = bitrate
                bestFormat = format
            end if
        end if
    end for

    return bestFormat
end function

function pickMeasuredBitrate(info as dynamic) as dynamic
    if not isValid(info) then return invalid
    if isValid(info.measuredBitrate) and info.measuredBitrate > 0 then return info.measuredBitrate
    if isValid(info.streamBitrate) and info.streamBitrate > 0 then return info.streamBitrate
    return invalid
end function

function createVideoPlaybackAbrRequest(request as object, contentType as string, sabr as object, currentFormat as object, activeFormats as object, playbackContext as object, playerTimeOverride as dynamic, videoNode as object, requestRef = invalid as dynamic) as object
    ' Create the ABR request object
    logTag = sabr_utilLogTag(contentType, requestRef)
    if not isValid(sabr.ustreamerConfig)
        m.logs.printl(log_level_Type.WARN, `${logTag} No SABR ustreamerConfig available`)
        return {}
    end if

    streamerContext = {
        "poToken": sabr.poToken,
        "playbackCookie": invalid, ' the playbackContext.lastPlaybackCookie will be set on handling the response nextRequestPolicy.playbackCookie
        "clientInfo": sabr.clientInfo,
        "sabrContexts": [],
        "unsentSabrContexts": [],
    }

    if isValid(playbackContext.lastPlaybackCookie)
        streamerContext["playbackCookie"] = playbackContext.lastPlaybackCookie
    end if

    if isValid(playbackContext.sabrContexts)
        streamerContext["sabrContexts"] = []
        for each key in playbackContext.sabrContexts
            streamerContext.sabrContexts.push(playbackContext.sabrContexts[key])
        end for
    end if

    playbackContext["lastPlayerTimeSecs"] = videoNode.position

    m.logs.printl(log_level_Type.INFO, `${logTag} streamingSegment : ${FormatJson(videoNode.streamingSegment)}`)

    bandwidthEstimate = pickMeasuredBitrate(videoNode.completedStreamInfo)
    if not isValid(bandwidthEstimate)
        bandwidthEstimate = pickMeasuredBitrate(videoNode.streamInfo)
    end if
    if not isValid(bandwidthEstimate) and isValid(videoNode.streamingSegment) and isValid(videoNode.streamingSegment.segBitrateBps)
        bandwidthEstimate = videoNode.streamingSegment.segBitrateBps
    end if
    if not isValid(bandwidthEstimate) and isValid(videoNode.segment) and isValid(videoNode.segment.bandwidth)
        bandwidthEstimate = videoNode.segment.bandwidth
    end if
    if not isValid(bandwidthEstimate) or bandwidthEstimate <= 0
        bandwidthEstimate = currentFormat?.bitrate ?? 0
    end if

    AUDIO_ONLY = 1
    VIDEO_ONLY = 2

    overrideMs = toInt(playerTimeOverride)
    overrideUsed = overrideMs <> invalid
    desiredPlayerTimeMs = overrideMs
    if desiredPlayerTimeMs = invalid or desiredPlayerTimeMs < 0
        desiredPlayerTimeMs = resolveFallbackPlayerTimeMs(playbackContext, currentFormat)
        overrideUsed = false
    end if
    if desiredPlayerTimeMs = invalid or desiredPlayerTimeMs < 0 then desiredPlayerTimeMs = 0

    playbackContext["lastRequestedPlayerTimeMs"] = desiredPlayerTimeMs
    playbackContext["lastPlayerTimeSecs"] = videoNode.position

    ' include the request byte range in the log
    overrideNote = overrideUsed ? " (derived from byte range)" : " (fallback)"
    m.logs.printl(log_level_Type.INFO, `${logTag} Creating SABR ABR request with playerTimeMs=${desiredPlayerTimeMs}, byteRange=${FormatJson(request.search)}, bandwidthEstimate=${bandwidthEstimate}${overrideNote}`)

    req = {
        "clientAbrState": {
            "playbackRate": videoNode.playbackSpeed ?? 1.0,
            "playerTimeMs": desiredPlayerTimeMs.toStr(),
            "clientViewportIsFlexible": false,
            "bandwidthEstimate": bandwidthEstimate.toStr(),
            "drcEnabled": currentFormat.isDrc ?? false,
            "enabledTrackTypesBitfield": isValid(currentFormat.width) ? VIDEO_ONLY : AUDIO_ONLY,
            "audioTrackId": currentFormat.audioTrackId
        },
        "bufferedRanges": [],
        "selectedFormatIds": [],
        "preferredAudioFormatIds": [ activeFormats.audioFormat ?? {} ],
        "preferredVideoFormatIds": [ activeFormats.videoFormat ?? {} ],
        "preferredSubtitleFormatIds": [],
        "videoPlaybackUstreamerConfig": sabr.ustreamerConfig,
        "streamerContext": streamerContext,
        "field1000": []
    }

    return req

end function

function resolveFallbackPlayerTimeMs(playbackContext as object, format as object) as dynamic
    if not isValid(playbackContext) then return 0

    formatKey = formatToKey(format)
    totals = playbackContext?.deliveredDurationTotals
    if GetInterface(totals, "ifAssociativeArray") <> invalid and formatKey <> "" and totals.DoesExist(formatKey)
        candidate = toInt(totals.Lookup(formatKey))
        if candidate <> invalid and candidate >= 0 then return candidate
    end if

    previous = toInt(playbackContext?.lastRequestedPlayerTimeMs)
    if previous <> invalid and previous >= 0 then return previous

    estimate = toInt(playbackContext?.estimatedPlayerTimeMs)
    if estimate <> invalid and estimate >= 0 then return estimate

    return 0
end function

' function ensureInitializedFormatMap(playbackContext as object) as object
'     initializedFormats = playbackContext.initializedFormats

'     if not isValid(initializedFormats)
'         initializedFormats = {}
'     else if not IsAssociativeArray(initializedFormats) = false
'         converted = {}
'         if GetInterface(initializedFormats, "ifArray") <> invalid
'             for each entry in initializedFormats
'                 if GetInterface(entry, "ifAssociativeArray") <> invalid
'                     key = invalid
'                     value = invalid
'                     if entry.DoesExist("key")
'                         key = entry.Lookup("key")
'                     else if isValid(entry.key)
'                         key = entry.key
'                     end if

'                     if entry.DoesExist("value")
'                         value = entry.Lookup("value")
'                     else if isValid(entry.value)
'                         value = entry.value
'                     end if

'                     if isValid(key) and isValid(value)
'                         converted.AddReplace(key, value)
'                     end if
'                 end if
'             end for
'         end if
'         initializedFormats = converted
'     end if

'     playbackContext["initializedFormats"] = initializedFormats
'     return initializedFormats
' end function

function formatToKey(format as dynamic) as string
    if not isValid(format) then return ""

    itagPart = ""
    if isValid(format.itag)
        itagPart = `${format.itag}`
    end if

    xtagsPart = ""
    if isValid(format.xtags)
        xtagsPart = `${format.xtags}`
    end if

    return `${itagPart}:${xtagsPart}`
end function

' function getAssociativeValue(source as dynamic, key as string) as dynamic
'     if GetInterface(source, "ifAssociativeArray") <> invalid and source.DoesExist(key)
'         return source.Lookup(key)
'     end if
'     return invalid
' end function

function cloneObject(value as dynamic) as dynamic
    if not isValid(value) then return invalid
    json = ""
    clone = invalid
    try
        json = FormatJson(value)
        if isValid(json) and json <> ""
            clone = ParseJson(json)
        end if
    catch e
        clone = invalid
    end try
    if not isValid(clone) then clone = value
    return clone
end function

function formatToFormatId(format as object) as object
    if not isValid(format) then return {}

    return {
        "itag": format.itag,
        "xtags": format.xtags,
        "lastModified": format.lastModified
    }
end function

' create a bogus full buffer range with max int32 values so we fake out the youtube server to think we already have all this data in the buffer
' as we don't want it (this is how we can still get either "just" video or "just" audio segments based on the player's dash requests)
function createFullBufferRange(format as object) as object
    MAX_INT32_VALUE = 2147483647
    return {
        "formatId": formatToFormatId(format),
        "durationMs": MAX_INT32_VALUE,
        "startTimeMs": "0",
        "startSegmentIndex": MAX_INT32_VALUE,
        "endSegmentIndex": MAX_INT32_VALUE,
        "timeRange": {
            "durationTicks": MAX_INT32_VALUE,
            "startTicks": "0",
            "timescale": 1000
        }
    }
end function

function buildBufferedRangeFromMetadata(originalMetadata as dynamic) as dynamic
    if not isValid(originalMetadata) then return invalid
    metadata = cloneObject(originalMetadata)
    if not isValid(metadata) then metadata = originalMetadata
    if GetInterface(metadata, "ifAssociativeArray") = invalid then return invalid

    normalizeSegmentTiming(metadata)

    durationMsStr = `${metadata?.durationMs ?? 0}`
    if durationMsStr = "" then durationMsStr = "0"

    startSequenceNumber = toInt(metadata?.startSequenceNumber)
    if startSequenceNumber = invalid or startSequenceNumber < 0
        startSequenceNumber = toInt(metadata?.sequenceNumber)
    end if
    if startSequenceNumber = invalid or startSequenceNumber < 0 then startSequenceNumber = 0

    endSequenceNumber = toInt(metadata?.endSequenceNumber)
    if endSequenceNumber = invalid or endSequenceNumber < startSequenceNumber
        endSequenceNumber = startSequenceNumber
    end if

    startTimeMsStr = `${metadata?.startTimeMs ?? 0}`
    if startTimeMsStr = "" then startTimeMsStr = `${metadata?.startMs ?? 0}`
    if startTimeMsStr = "" then startTimeMsStr = "0"

    timeRangeInfo = metadata?.timeRange
    timeRangeScale = toInt(timeRangeInfo?.timescale)
    if timeRangeScale = invalid or timeRangeScale <= 0 then timeRangeScale = metadata?.timescale ?? 1000
    if timeRangeScale = invalid or timeRangeScale <= 0 then timeRangeScale = 1000

    durationTicksVal = toInt(timeRangeInfo?.durationTicks)
    if durationTicksVal = invalid
        durationTicksVal = toInt(durationMsStr)
        if durationTicksVal <> invalid and timeRangeScale <> 1000
            durationTicksVal = int(durationTicksVal * timeRangeScale / 1000)
        end if
    end if
    durationTicksStr = `${durationTicksVal ?? 0}`
    if durationTicksStr = "" then durationTicksStr = durationMsStr

    startTicksVal = toInt(timeRangeInfo?.startTicks)
    if startTicksVal = invalid
        startTimeVal = toInt(startTimeMsStr)
        if startTimeVal <> invalid and timeRangeScale <> 1000
            startTicksVal = int(startTimeVal * timeRangeScale / 1000)
        else
            startTicksVal = startTimeVal
        end if
    end if
    startTicksStr = `${startTicksVal ?? 0}`
    if startTicksStr = "" then startTicksStr = startTimeMsStr

    formatted = {
        "formatId": metadata.formatId,
        "startSegmentIndex": startSequenceNumber,
        "durationMs": durationMsStr,
        "startTimeMs": startTimeMsStr,
        "endSegmentIndex": endSequenceNumber,
        "timeRange": {
            "timescale": timeRangeScale,
            "startTicks": startTicksStr,
            "durationTicks": durationTicksStr
        }
    }

    rangeStartVal = toInt(metadata?.rangeStart)
    if rangeStartVal = invalid
        rangeStartVal = toInt(metadata?.startRange)
    end if
    if rangeStartVal <> invalid then formatted["rangeStart"] = `${rangeStartVal ?? ""}`
    rangeEndVal = toInt(metadata?.rangeEnd)
    if rangeEndVal = invalid
        rangeEndVal = toInt(metadata?.endRange)
    end if
    if rangeEndVal <> invalid then formatted["rangeEnd"] = `${rangeEndVal ?? ""}`

    return formatted
end function

sub normalizeSegmentTiming(metadata as object)
    if GetInterface(metadata, "ifAssociativeArray") = invalid then return

    timeRange = metadata?.timeRange
    if GetInterface(timeRange, "ifAssociativeArray") = invalid
        timeRange = {}
    end if

    timescale = toInt(timeRange?.timescale)
    if timescale = invalid or timescale <= 0
        timescale = toInt(metadata?.timescale)
    end if
    if timescale = invalid or timescale <= 0 then timescale = 1000

    startMsVal = toInt(metadata?.startTimeMs)
    if startMsVal = invalid then startMsVal = toInt(metadata?.startMs)
    if startMsVal = invalid
        startTicks = toInt(timeRange?.startTicks)
        if startTicks <> invalid
            startMsVal = int((startTicks * 1000) / timescale)
        end if
    end if
    if startMsVal <> invalid
        metadata["startTimeMs"] = startMsVal.toStr()
        metadata["startMs"] = startMsVal.toStr()
        timeRange["startTicks"] = int((startMsVal * timescale) / 1000)
    end if

    durationMsVal = toInt(metadata?.durationMs)
    if durationMsVal = invalid or durationMsVal <= 0
        durationTicks = toInt(timeRange?.durationTicks)
        if durationTicks <> invalid and durationTicks > 0
            durationMsVal = int((durationTicks * 1000) / timescale)
        end if
    end if
    if durationMsVal = invalid or durationMsVal <= 0
        durationMsVal = segmentDurationMs(metadata)
    end if
    if durationMsVal <> invalid and durationMsVal >= 0
        metadata["durationMs"] = durationMsVal.toStr()
        timeRange["durationTicks"] = int((durationMsVal * timescale) / 1000)
    end if

    metadata["timeRange"] = timeRange
end sub

function buildSabrResponseForPlayer(requestMetadata as object, umpResult as dynamic, currentFormat as object, requestByteRange as object, contentType as string) as object
    headers = CreateObject("roAssociativeArray")
    itagLabelForHeader = sabr_valueToLabel(currentFormat?.itag)
    if itagLabelForHeader = "" then itagLabelForHeader = `${requestMetadata?.format?.itag ?? ""}`
    if itagLabelForHeader <> ""
        headers["X-Cache-Itag"] = itagLabelForHeader
    end if
    body = CreateObject("roByteArray")
    fullBody = invalid
    status = 204

    if isValid(umpResult) and isValid(umpResult.data)
        fullBody = umpResult.data
        body = fullBody

        fullPayloadLength = 0
        if GetInterface(fullBody, "ifByteArray") <> invalid
            fullPayloadLength = fullBody.count()
        end if

        mimeType = currentFormat?.mimeType
        if not isValid(mimeType) or mimeType = ""
            mimeType = contentType = "VIDEO" ? "video/mp4" : "audio/mp4"
        end if
        headers["Content-Type"] = mimeType
        headers["Accept-Ranges"] = "bytes"
        status = 200

        requestCoverage = byteRangeToCoverage(requestByteRange)
        requestedStart = requestCoverage?.rangeStart
        requestedEnd = requestCoverage?.rangeEnd

        if not isValid(requestedStart)
            startLabel = `${requestByteRange?.startRange ?? 0}`
            if startLabel = "" then startLabel = `${requestByteRange?.start ?? "0"}`
            if startLabel <> "" then requestedStart = startLabel.toInt()
        end if

        if not isValid(requestedEnd)
            endLabel = `${requestByteRange?.endRange ?? ""}`
            if endLabel = "" then endLabel = `${requestByteRange?.end ?? ""}`
            if endLabel <> "" then requestedEnd = endLabel.toInt()
        end if

        coverageStart = invalid
        coverageEnd = invalid

        if requestMetadata?.isInit = true
            coverageStart = 0
            if fullPayloadLength > 0
                coverageEnd = fullPayloadLength - 1
            else
                coverageEnd = -1
            end if
        end if

        resultCoverage = invalid
        if GetInterface(umpResult, "ifAssociativeArray") <> invalid
            resultCoverage = umpResult.Lookup("coverage")
            if not isValid(resultCoverage)
                covStart = umpResult.Lookup("coverageStart")
                covEnd = umpResult.Lookup("coverageEnd")
                if isValid(covStart) and isValid(covEnd)
                    resultCoverage = {
                        "rangeStart": covStart
                        "rangeEnd": covEnd
                    }
                end if
            end if
        end if
        if isValid(resultCoverage) and GetInterface(resultCoverage, "ifAssociativeArray") <> invalid
            covStartVal = resultCoverage.Lookup("rangeStart")
            if not isValid(covStartVal) then covStartVal = resultCoverage.Lookup("start")
            covEndVal = resultCoverage.Lookup("rangeEnd")
            if not isValid(covEndVal) then covEndVal = resultCoverage.Lookup("end")

            if IsString(covStartVal)
                covStartVal = covStartVal.toInt()
            end if
            if IsString(covEndVal)
                covEndVal = covEndVal.toInt()
            end if

            if isValid(covStartVal)
                coverageStart = covStartVal
            end if
            if isValid(covEndVal)
                coverageEnd = covEndVal
            end if
        end if

        metadataCoverage = byteRangeToCoverage(requestMetadata?.byteRange)
        if not isValid(coverageStart) and isValid(metadataCoverage)
            coverageStart = metadataCoverage.rangeStart
        end if
        if not isValid(coverageEnd) and isValid(metadataCoverage)
            coverageEnd = metadataCoverage.rangeEnd
        end if

        if not isValid(coverageStart) and isValid(requestedStart)
            coverageStart = requestedStart
        end if
        if isValid(coverageStart) and not isValid(coverageEnd) and fullPayloadLength > 0
            coverageEnd = coverageStart + fullPayloadLength - 1
        end if
        if isValid(coverageStart) and isValid(coverageEnd) and coverageEnd < coverageStart
            coverageEnd = invalid
        end if

        if fullPayloadLength > 0 and isValid(requestedStart)
            if not isValid(coverageStart)
                coverageStart = requestedStart
                if not isValid(coverageEnd)
                    coverageEnd = coverageStart + fullPayloadLength - 1
                end if
            end if

            sliceOffset = requestedStart - coverageStart
            if sliceOffset < 0 then sliceOffset = 0

            maxIndex = fullPayloadLength - 1
            if sliceOffset > maxIndex
                body = CreateObject("roByteArray")
            else
                desiredLength = invalid
                if isValid(requestedEnd)
                    sliceEndIndex = requestedEnd - coverageStart
                    if isValid(coverageEnd)
                        maxCoverageIndex = coverageEnd - coverageStart
                        if sliceEndIndex > maxCoverageIndex
                            sliceEndIndex = maxCoverageIndex
                        end if
                    end if
                    if sliceEndIndex > maxIndex then sliceEndIndex = maxIndex
                    if sliceEndIndex < sliceOffset
                        desiredLength = 0
                    else
                        desiredLength = sliceEndIndex - sliceOffset + 1
                    end if
                else
                    desiredLength = fullPayloadLength - sliceOffset
                end if

                if desiredLength = invalid then desiredLength = fullPayloadLength - sliceOffset
                if desiredLength < 0 then desiredLength = 0
                maxAvailable = fullPayloadLength - sliceOffset
                if desiredLength > maxAvailable then desiredLength = maxAvailable

                if sliceOffset <> 0 or desiredLength <> fullPayloadLength
                    sliced = CreateObject("roByteArray")
                    if desiredLength > 0
                        sliced[desiredLength - 1] = 0
                        destIndex = 0
                        limitIndex = sliceOffset + desiredLength - 1
                        for i = sliceOffset to limitIndex
                            sliced[destIndex] = fullBody[i]
                            destIndex = destIndex + 1
                        end for
                    end if
                    body = sliced
                end if
            end if
        end if

        resourceLength = body.count()

        rangeStartForHeaders = requestedStart
        if not isValid(rangeStartForHeaders)
            if isValid(coverageStart)
                rangeStartForHeaders = coverageStart
            else
                rangeStartForHeaders = 0
            end if
        end if

        if resourceLength > 0
            actualEnd = rangeStartForHeaders + resourceLength - 1
        else if isValid(requestedEnd)
            actualEnd = requestedEnd
        else if isValid(coverageEnd)
            actualEnd = coverageEnd
        else
            actualEnd = rangeStartForHeaders - 1
        end if

        if isValid(requestedEnd) and actualEnd > requestedEnd
            actualEnd = requestedEnd
        end if

        totalLengthVal = toInt(currentFormat?.contentLength)
        if not isValid(totalLengthVal)
            totalLengthVal = toInt(requestMetadata?.format?.contentLength)
        end if

        if not isValid(totalLengthVal)
            mediaHeader = requestMetadata?.streamInfo?.mediaHeader
            startRangeVal = toInt(mediaHeader?.startRange)
            if startRangeVal = invalid then startRangeVal = toInt(mediaHeader?.start)
            contentLengthVal = toInt(mediaHeader?.contentLength)
            if isValid(startRangeVal) and isValid(contentLengthVal)
                totalLengthVal = startRangeVal + contentLengthVal
            end if
        end if

        if not isValid(totalLengthVal) and isValid(coverageEnd)
            totalLengthVal = coverageEnd + 1
        end if

        if not isValid(totalLengthVal)
            if resourceLength > 0
                totalLengthVal = actualEnd + 1
            else
                totalLengthVal = fullPayloadLength
            end if
        end if

        if isValid(totalLengthVal) and isValid(actualEnd) and totalLengthVal <= actualEnd
            totalLengthVal = actualEnd + 1
        end if

        totalLengthStr = ""
        if isValid(totalLengthVal) then totalLengthStr = totalLengthVal.toStr()
        if totalLengthStr = "" then totalLengthStr = "*"

        if isValid(requestedStart)
            status = 206
            headers["Content-Range"] = `bytes ${rangeStartForHeaders}-${actualEnd}/${totalLengthStr}`
        end if

        headers["Content-Length"] = resourceLength.toStr()

        responseObj = {
            status: status
            headers: headers
            body: body
        }
        responseObj["fullBody"] = fullBody
        return responseObj
    else if isValid(requestMetadata?.error)
        status = 500
        headers["Content-Type"] = "text/plain"
        headers["Content-Length"] = "0"
    else if isValid(requestMetadata?.streamInfo?.redirect?.url)
        status = 302
        headers["Location"] = requestMetadata.streamInfo.redirect.url
        headers["Content-Type"] = "text/plain"
        headers["Content-Length"] = "0"
    else
        headers["Content-Type"] = "text/plain"
        headers["Content-Length"] = "0"
    end if

    if headers.DoesExist("Connection") = false
        headers["Connection"] = "close"
    end if

    return {
        status: status
        headers: headers
        body: body
    }
end function

function buildEmptySabrResponseForPlayer(contentType as string, currentFormat as object) as object
    body = CreateObject("roByteArray")

    mimeType = currentFormat?.mimeType ?? ""
    if mimeType = ""
        if contentType = "VIDEO"
            mimeType = "video/mp4"
        else if contentType = "AUDIO"
            mimeType = "audio/mp4"
        else
            mimeType = "application/octet-stream"
        end if
    end if

    headers = {
        "Content-Length": "0"
        "Accept-Ranges": "bytes"
        "Cache-Control": "no-store"
        "Content-Type": mimeType
    }

    return {
        status: 204
        headers: headers
        body: body
    }
end function

function buildErrorResponseForPlayer(status as integer, message as string) as object
    body = CreateObject("roByteArray")
    if isValid(message) and message <> ""
        body.FromAsciiString(message)
    end if

    headers = {
        "Content-Type": "text/plain"
        "Content-Length": body.count().toStr()
        "Connection": "close"
    }

    return {
        status: status
        headers: headers
        body: body
    }
end function

sub applyStreamInfoUpdates(playbackContext as object, streamInfo as object, contentType as string, deliveredSegment = true as boolean, requestMetadataEntry = invalid as dynamic)
    if not isValid(streamInfo) then return

    if isValid(streamInfo.nextRequestPolicy)
        playbackContext["nextRequestPolicy"] = streamInfo.nextRequestPolicy
        if isValid(streamInfo.nextRequestPolicy.playbackCookie)
            playbackContext["lastPlaybackCookie"] = PlaybackCookieEncode(streamInfo.nextRequestPolicy.playbackCookie)
        end if
        playbackContext["backoffTimeMs"] = streamInfo.nextRequestPolicy.backoffTimeMs
    end if

    if isValid(streamInfo.sabrContextSendingPolicy)
        playbackContext["sabrContextSendingPolicy"] = streamInfo.sabrContextSendingPolicy
    end if

    if isValid(streamInfo.sabrContextUpdate)
        contexts = playbackContext["sabrContexts"]
        if not isValid(contexts)
            contexts = CreateObject("roAssociativeArray")
        end if
        contextType = streamInfo.sabrContextUpdate.type
        if isValid(contextType)
            contexts.AddReplace(contextType.toStr(), streamInfo.sabrContextUpdate)
        end if
        playbackContext["sabrContexts"] = contexts
    end if

    if isValid(streamInfo.mediaHeader)
        initializedFormats = playbackContext.initializedFormats
        formatId = streamInfo.mediaHeader.formatId
        formatKey = formatToKey({ itag: formatId?.itag, xtags: formatId?.xtags })
        initializedFormat = {}
        if initializedFormats.DoesExist(formatKey)
            initializedFormat = initializedFormats.Lookup(formatKey)
        end if

        coverageData = streamInfo?.deliveredCoverage
        if isValid(coverageData)
            streamInfo["segmentCoverage"] = coverageData
        end if
        metadataFromHeader = mediaHeaderToSegmentMetadata(streamInfo.mediaHeader, coverageData)
        if isValid(metadataFromHeader)
            if deliveredSegment = true
                initializedFormat["lastSegmentMetadata"] = metadataFromHeader
                recentSegments = initializedFormat?.recentSegmentMetadata
                if GetInterface(recentSegments, "ifArray") = invalid
                    recentSegments = []
                end if
                recentSegments.push(metadataFromHeader)
                if recentSegments.count() > 6
                    trimmed = []
                    total = recentSegments.count()
                    startIndex = total - 6
                    for idx = startIndex to total - 1
                        trimmed.push(recentSegments[idx])
                    end for
                    recentSegments = trimmed
                end if
                initializedFormat["recentSegmentMetadata"] = recentSegments
                initializedFormats.AddReplace(formatKey, initializedFormat)
                playbackContext["initializedFormats"] = initializedFormats

                if streamInfo.mediaHeader.isInitSeg <> true
                    if contentType = "VIDEO"
                        playbackContext["lastVideoSegmentMetadata"] = metadataFromHeader
                    else if contentType = "AUDIO"
                        playbackContext["lastAudioSegmentMetadata"] = metadataFromHeader
                    end if
                end if

                if isValid(requestMetadataEntry?.format)
                    updateDeliveredDurationTotals(playbackContext, contentType, requestMetadataEntry.format, metadataFromHeader)
                end if
            end if
            recordSegmentMetadata(playbackContext, contentType, formatKey, metadataFromHeader)
        end if
    end if

    if isValid(streamInfo.formatInitMetadata)
        playbackContext["formatInitializationMetadata"] = streamInfo.formatInitMetadata
    end if

    if isValid(streamInfo.streamProtectionStatus)
        playbackContext["streamProtectionStatus"] = streamInfo.streamProtectionStatus
    end if

    if GetInterface(streamInfo, "ifAssociativeArray") <> invalid and streamInfo.DoesExist("deliveredCoverage")
        streamInfo.Delete("deliveredCoverage")
    end if
end sub

function getSegmentMetadataByRange(playbackContext as object, contentType as string, format as object, createIfMissing = false as boolean) as dynamic
    formatKey = formatToKey(format)
    return getSegmentMetadataByRangeKey(playbackContext, contentType, formatKey, createIfMissing)
end function

function getSegmentMetadataByRangeKey(playbackContext as object, contentType as string, formatKey as string, createIfMissing = false as boolean) as dynamic
    if not isValid(playbackContext) then return invalid
    if formatKey = "" then return invalid

    catalog = playbackContext?.segmentMetadataByRange
    if not IsAssociativeArray(catalog)
        if not createIfMissing then return invalid
        catalog = {}
    end if

    typeKey = contentType ?? ""
    if typeKey = "" then typeKey = "UNKNOWN"
    if not catalog.DoesExist(typeKey)
        if not createIfMissing then return invalid
        catalog[typeKey] = {}
    end if

    byFormat = catalog[typeKey]
    if not IsAssociativeArray(byFormat)
        if not createIfMissing then return invalid
        byFormat = {}
        catalog[typeKey] = byFormat
    end if

    if not byFormat.DoesExist(formatKey)
        if not createIfMissing then return invalid
        byFormat[formatKey] = {}
    end if

    playbackContext["segmentMetadataByRange"] = catalog
    return byFormat[formatKey]
end function

sub recordSegmentMetadata(playbackContext as object, contentType as string, formatKey as string, metadata as dynamic)
    if not isValid(metadata) then return
    startRangeVal = toInt(metadata?.startRange)
    if startRangeVal = invalid then return

    byRange = getSegmentMetadataByRangeKey(playbackContext, contentType, formatKey, true)
    if GetInterface(byRange, "ifAssociativeArray") = invalid then return

    byRange[startRangeVal.toStr()] = metadata
end sub

sub updateDeliveredDurationTotals(playbackContext as object, contentType as string, format as object, metadata as dynamic)
    if not isValid(playbackContext) then return
    if not isValid(format) then return
    if not isValid(metadata) then return
    if metadata?.isInitSeg = true then return

    formatKey = formatToKey(format)
    if formatKey = "" then return

    durationVal = segmentDurationMs(metadata)
    if durationVal = invalid or durationVal <= 0 then return

    tracker = playbackContext?.deliveredSegmentTracking
    if GetInterface(tracker, "ifAssociativeArray") = invalid
        tracker = {}
    end if

    formatTracker = tracker.Lookup(formatKey)
    if GetInterface(formatTracker, "ifAssociativeArray") = invalid
        formatTracker = {}
    end if

    segmentId = ""
    seqVal = toInt(metadata?.sequenceNumber)
    if seqVal <> invalid and seqVal >= 0
        segmentId = `seq:${seqVal}`
    else
        rangeLabel = sabr_valueToLabel(metadata?.rangeStart)
        if rangeLabel <> "" then segmentId = `range:${rangeLabel}`
    end if
    if segmentId = "" then segmentId = `ts:${sabr_valueToLabel(metadata?.startTimeMs)}`
    if segmentId = "" then segmentId = `id:${durationVal.toStr()}`

    if formatTracker.DoesExist(segmentId) then return

    formatTracker[segmentId] = durationVal
    tracker[formatKey] = formatTracker
    playbackContext["deliveredSegmentTracking"] = tracker

    totals = playbackContext?.deliveredDurationTotals
    if GetInterface(totals, "ifAssociativeArray") = invalid
        totals = {}
    end if

    currentTotal = toInt(totals.Lookup(formatKey))
    if currentTotal = invalid then currentTotal = 0
    totals[formatKey] = currentTotal + durationVal
    playbackContext["deliveredDurationTotals"] = totals

    logTag = sabr_utilLogTag(contentType, playbackContext?.requestNumber)
    m.logs.printl(log_level_Type.DEBUG, `${logTag} Recorded segment duration ${durationVal}ms for ${formatKey}; cumulative=${totals[formatKey]}`)
end sub

' function sabr_lookupStartMsForRange(metadataByRange as object, requestedStart as integer) as dynamic
'     if GetInterface(metadataByRange, "ifAssociativeArray") = invalid then return invalid

'     key = requestedStart.toStr()
'     if metadataByRange.DoesExist(key)
'         metadata = metadataByRange.Lookup(key)
'         exactStart = sabr_segmentStartMs(metadata)
'         if exactStart <> invalid then return exactStart
'     end if

'     nearestStart = invalid
'     nearestMetadata = invalid

'     for each entryKey in metadataByRange
'         entryMetadata = metadataByRange.Lookup(entryKey)
'         entryStart = sabr_toInt(entryKey)
'         if entryStart = invalid
'             entryStart = sabr_toInt(entryMetadata?.startRange)
'         end if

'         if entryStart <> invalid and entryStart <= requestedStart
'             if nearestStart = invalid or entryStart > nearestStart
'                 nearestStart = entryStart
'                 nearestMetadata = entryMetadata
'             end if
'         end if
'     end for

'     if nearestMetadata <> invalid
'         baseStart = sabr_segmentStartMs(nearestMetadata)
'         duration = segmentDurationMs(nearestMetadata)
'         if baseStart <> invalid and duration <> invalid
'             prediction = baseStart + duration
'             if prediction >= 0 then return prediction
'         end if
'     end if

'     return invalid
' end function
