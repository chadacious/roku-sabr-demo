import "pkg:/source/ytproto/generated/messages/VideoPlaybackAbrRequest.brs"
import "pkg:/source/ytproto/generated/messages/ClientAbrState.brs"
import "pkg:/source/ytproto/generated/messages/FormatId.brs"
import "pkg:/source/ytproto/generated/messages/StreamerContext.brs"
import "pkg:/source/ytproto/generated/messages/ClientInfo.brs"
import "pkg:/source/ytproto/generated/messages/TimeRange.brs"
import "pkg:/source/ytproto/generated/messages/BufferedRange.brs"
import "pkg:/source/ytproto/generated/messages/SabrContext.brs"
import "pkg:/source/ytproto/generated/messages/GLDeviceInfo.brs"
import "pkg:/source/ytproto/generated/messages/MediaCapabilities.brs"
import "pkg:/source/ytproto/generated/messages/VideoFormatCapability.brs"
import "pkg:/source/ytproto/generated/messages/AudioFormatCapability.brs"
import "pkg:/source/ytproto/generated/messages/PlaybackAuthorization.brs"
import "pkg:/source/ytproto/generated/messages/AuthorizedFormat.brs"
import "pkg:/source/ytproto/generated/messages/Range.brs"
import "pkg:/source/ytproto/generated/messages/PlaybackCookie.brs"
import "pkg:/source/ytproto/generated/messages/UnknownInnerMessage.brs"
import "pkg:/source/ytproto/generated/messages/UnknownInnerMessage1.brs"
import "pkg:/source/ytproto/generated/messages/UnknownMessage3.brs"
import "pkg:/source/ytproto/generated/messages/VideoStreamingBufferedRangeUnknownMessage1.brs"
import "pkg:/source/ytproto/generated/messages/VideoStreamingBufferedRangeUnknownMessage2.brs"
import "pkg:/source/ytproto/generated/messages/VideoStreamingStreamerContextUnknownMessage1.brs"
import "pkg:/source/ytproto/generated/messages/VideoStreamingUnknownMessage1.brs"
import "pkg:/source/ytproto/generated/messages/VideoStreamingUnknownMessage2.brs"
import "pkg:/source/SabrUmpProcessor.bs"
import "pkg:/source/httpRequest.bs"
import "pkg:/source/SabrUtils.bs"
import "pkg:/source/SabrDebug.bs"
import "pkg:/source/SabrMp4Parser.bs"
import "pkg:/source/taskUtils.bs"

'------------------------------------------------------------------------------
' Entry: sabr_handleRequest
' Purpose: minimal SABR adapter that streams each request directly from the
'          SABR spool pipeline, caching only init segments on disk.
'------------------------------------------------------------------------------
function sabr_handleRequest(request as object, contentType as string, mediaIdHash as string, sabr as object, videoNode as object, queuedAtMs = invalid as dynamic, redirectDepth = 0 as integer, scopeKey = "root" as string) as object
    parsedKey = sabr_parseScopedKey(request?.search?.key)
    if IsAssociativeArray(parsedKey)
        scopedLabel = sabr_toSafeString(parsedKey?.scope)
        if scopedLabel <> "" then scopeKey = scopedLabel
    end if

    playbackContext = sabr_loadPlaybackContext(mediaIdHash, scopeKey)
    requestNumber = sabr_nextRequestId(playbackContext)
    logTag = `[YTSABR-${contentType}-${requestNumber}]`
    sabr_pruneOtherMediaDirs(mediaIdHash)
    sabr_ensureMediaDir(mediaIdHash)

    requestByteRange = sabr_getHeaderByteRange(request)
    requestByteRange = sabr_normalizeByteRange(requestByteRange, {
        "mediaIdHash": mediaIdHash
        "contentType": contentType
    })

    itagKey = request.search.key
    currentFormat = sabr_findFormatForKey(itagKey, sabr, contentType, logTag)
    if not isValid(currentFormat)
        return sabr_buildErrorResponseForPlayer(404, "missing format")
    end if

    activeFormats = sabr_getActiveFormats(currentFormat, sabr, playbackContext)

    isInitRequest = sabr_isInit(contentType, currentFormat, requestByteRange, logTag)

    streamResult = invalid
    servedFromCache = false
    if isInitRequest
        initResponse = sabr_tryServeCachedInitSegment(playbackContext, mediaIdHash, contentType, itagKey, requestByteRange, true, logTag)
        if IsAssociativeArray(initResponse)
            streamResult = initResponse
            streamResult["servedFromInitCache"] = true
            servedFromCache = true
        end if
    end if

    if not IsAssociativeArray(streamResult)
        sabrRequest = sabr_prepareProtoRequest(request, contentType, sabr, currentFormat, activeFormats, requestByteRange, playbackContext, videoNode, isInitRequest, logTag, requestNumber)
        if not isValid(sabrRequest)
            return sabr_buildErrorResponseForPlayer(500, "proto build failed")
        end if
        streamResult = sabr_streamViaUMP(sabrRequest, mediaIdHash, contentType, currentFormat, requestByteRange, itagKey, isInitRequest, playbackContext, sabr, logTag, requestNumber)
    end if
    redirectUrl = sabr_toSafeString(streamResult?.__redirectUrl)
    if redirectUrl <> ""
        streamResult.Delete("__redirectUrl")
        if redirectDepth >= 3
            sabr_log(m.logs, log_level_Type.WARN, `${logTag} Redirect limit reached for ${redirectUrl}`, false)
            return sabr_buildErrorResponseForPlayer(502, "redirect limit reached")
        end if
        sabr_log(m.logs, log_level_Type.INFO, `${logTag} Following SABR redirect to ${redirectUrl}`)
        sabr_savePlaybackContext(mediaIdHash, playbackContext, scopeKey)
        return sabr_handleRequest(request, contentType, mediaIdHash, sabr, videoNode, queuedAtMs, redirectDepth + 1, scopeKey)
    end if
    if not IsAssociativeArray(streamResult)
        return sabr_buildErrorResponseForPlayer(500, "SABR stream failed")
    end if

    response = sabr_buildResponseForPlayer({
        "byteRange": requestByteRange
    }, streamResult, currentFormat, requestByteRange, contentType)
    if servedFromCache = true
        response["servedFromInitCache"] = true
    end if
    sabr_debugDumpResponse(playbackContext, response, requestByteRange, contentType, currentFormat, logTag, requestNumber)

    sabr_savePlaybackContext(mediaIdHash, playbackContext, scopeKey)
    return response
end function

'------------------------------------------------------------------------------
' SABR request building
'------------------------------------------------------------------------------
'------------------------------------------------------------------------------
' Function : sabr_prepareProtoRequest
' Purpose  : Assemble and encode the protobuf payload sent to SABR, wiring up
'            a stream tap so we can capture the spool response.
'------------------------------------------------------------------------------
function sabr_prepareProtoRequest(request as object, contentType as string, sabr as object, currentFormat as object, activeFormats as object, requestByteRange as object, playbackContext as object, videoNode as object, isInitRequest as boolean, logTag as string, requestNumber as string) as object
    payload = sabr_createVideoPlaybackAbrRequest(request, contentType, sabr, currentFormat, activeFormats, requestByteRange, playbackContext, 0, videoNode, 0, isInitRequest)
    if not IsAssociativeArray(payload) then return invalid

    sabr_debugDumpRequestPayload(playbackContext, payload, requestByteRange, contentType, currentFormat, logTag, requestNumber)

    encoded = VideoPlaybackAbrRequestEncode(payload)
    if not IsString(encoded) or encoded = "" then return invalid

    protoBytes = CreateObject("roByteArray")
    protoBytes.FromBase64String(encoded)
    scopeLabel = sabr_sanitizeForFilename(sabr_toSafeString(playbackContext?.scope))
    if scopeLabel = "" then scopeLabel = "root"
    protoPath = `${sabr_mediaDir(playbackContext.mediaIdHash)}/sabrRequest-${contentType}-${scopeLabel}-${sabr_sanitizeForFilename(logTag)}.bin`
    protoBytes.WriteFile(protoPath)

    destPath = `${protoPath}-res`
    tap = sabr_createStreamTap({
        "destPath": destPath
        "keyParam": request.search.key
        "targetItag": sabr_toInt(currentFormat?.itag)
        "targetRangeStart": requestByteRange.startRange
        "targetRangeEnd": requestByteRange.endRange
        "isInitRequest": isInitRequest
        "contentType": contentType
        "mediaIdHash": playbackContext.mediaIdHash
    })

    optionsPayload = {
        "method": "POST_FILE_TO_FILE_TAP"
        "body": protoPath
        "responseFilePath": destPath
    }
    if IsAssociativeArray(tap)
        optionsPayload["streamTap"] = tap
    end if

    return {
        "url": sabr.serverAbrStreamingUrl
        "requestType": "proxy"
        "timeout": 10000
        "options": optionsPayload
    }
end function

'------------------------------------------------------------------------------
' Stream SABR response and build player response object
'------------------------------------------------------------------------------
'------------------------------------------------------------------------------
' Function : sabr_streamViaUMP
' Purpose  : Fire the prepared SABR request, read the resulting spool data, and
'            normalize it into a Roku player response structure.
'------------------------------------------------------------------------------
function sabr_streamViaUMP(sabrRequest as object, mediaIdHash as string, contentType as string, currentFormat as object, requestByteRange as object, keyParam as string, isInitRequest as boolean, playbackContext as object, sabr as object, logTag as string, requestNumber as string) as dynamic
    sabr_log(m.logs, log_level_Type.INFO, `${logTag} Performing proxied request`)
    protoCleanupPath = sabr_toSafeString(sabrRequest?.options?.body)
    res = makeRequest(sabrRequest)
    sabr_deleteFileIfExists(protoCleanupPath)
    if res?.status < 200 or res?.status > 206
        sabr_log(m.logs, log_level_Type.WARN, `${logTag} SABR request failed ${res?.status}`)
        return invalid
    end if

    spoolPath = sabr_toSafeString(res?.body)
    if spoolPath = "" and IsAssociativeArray(res?.streamTapResult)
        spoolPath = sabr_toSafeString(res.streamTapResult.path)
    end if
    if spoolPath = "" then return invalid

    streamTapResult = res?.streamTapResult
    ' Always parse the spool to capture control parts even if no media chunk was matched.
    spoolMap = sabr_ump_buildSpoolPartMap(spoolPath, 16, keyParam)
    tapControlEffects = invalid
    if IsAssociativeArray(streamTapResult)
        tapControlEffects = streamTapResult.Lookup("controlEffects")
    end if
    spoolControlEffects = invalid
    if IsAssociativeArray(spoolMap)
        spoolControlEffects = spoolMap.Lookup("controlEffects")
    end if
    controlEffects = sabr_mergeControlEffects(spoolControlEffects, tapControlEffects)
    effectInfo = sabr_applyControlEffects(playbackContext, sabr, controlEffects, contentType, logTag)
    redirectUrl = sabr_toSafeString(effectInfo?.redirectUrl)

    tapEntry = sabr_extractSegmentEntryFromTap(streamTapResult, spoolPath)
    if not IsAssociativeArray(tapEntry)
        tapEntry = sabr_loadSegmentEntryFromSpool(playbackContext, spoolPath, requestByteRange, keyParam, logTag, contentType, currentFormat, requestNumber, spoolMap)
    end if
    if not IsAssociativeArray(tapEntry)
        sabr_log(m.logs, log_level_Type.WARN, `${logTag} No segment entry available for ${spoolPath}`)
        sabr_deleteFileIfExists(spoolPath)
        if redirectUrl <> ""
            return {
                "__redirectUrl": redirectUrl
            }
        end if
        return invalid
    end if

    response = sabr_buildStreamResponse(tapEntry, spoolPath, requestByteRange, isInitRequest)
    if not IsAssociativeArray(response)
        sabr_deleteFileIfExists(spoolPath)
        if redirectUrl <> ""
            return {
                "__redirectUrl": redirectUrl
            }
        end if
        return invalid
    end if

    if tapEntry?.isInitSeg = true
        scopeKey = sabr_toSafeString(playbackContext?.scope)
        if scopeKey = "" then scopeKey = "root"
        sabr_materializeInitSegment(tapEntry, spoolPath, mediaIdHash, contentType, keyParam, scopeKey)
        sidxUpdate = tapEntry.Lookup("sidxIndex")
        if not IsAssociativeArray(sidxUpdate)
            sidxUpdate = sabr_ump_extractSidxFromSpool(spoolPath, tapEntry)
        end if
        if IsAssociativeArray(sidxUpdate)
            sabr_storeSidxIndexUpdate(playbackContext, contentType, currentFormat, sidxUpdate, tapEntry)
        end if
    end if

    if IsAssociativeArray(playbackContext)
        playbackContext["lastStartSegmentIndex"] = sabr_toInt(response.Lookup("sequenceIndex"))
    end if

    return response
end function

'------------------------------------------------------------------------------
' Function : sabr_createStreamTap
' Purpose  : Configure a YT stream tap to capture SABR UMP responses to disk.
'------------------------------------------------------------------------------
function sabr_createStreamTap(config as object) as dynamic
    if not IsAssociativeArray(config) then return invalid
    return sabr_ump_createStreamTap(config)
end function

'------------------------------------------------------------------------------
' Function : sabr_extractSegmentEntryFromTap
' Purpose  : Build a normalized segment entry from the tap's metadata so later
'            code can reason about ranges without rereading the spool file.
'------------------------------------------------------------------------------
function sabr_extractSegmentEntryFromTap(tapResult as dynamic, spoolPath as string) as dynamic
    if not IsAssociativeArray(tapResult) then return invalid
    entry = tapResult.Lookup("segmentEntry")
    if not IsAssociativeArray(entry) then return invalid
    entry["path"] = spoolPath
    return entry
end function

'------------------------------------------------------------------------------
' Function : sabr_loadSegmentEntryFromSpool
' Purpose  : Parse the spool map emitted by SABR and locate the segment that
'            satisfies the caller's requested byte range.
'------------------------------------------------------------------------------
function sabr_loadSegmentEntryFromSpool(playbackContext as object, spoolPath as string, requestByteRange as object, keyParam as string, logTag as string, contentType as string, currentFormat as object, requestNumber as string, existingSpoolMap = invalid as dynamic) as dynamic
    spoolMap = existingSpoolMap
    if not IsAssociativeArray(spoolMap)
        spoolMap = sabr_ump_buildSpoolPartMap(spoolPath, 16, keyParam)
    end if
    if not IsAssociativeArray(spoolMap) then return invalid
    segment = sabr_selectSpoolSegmentFromMap(spoolMap, requestByteRange, keyParam)
    sabr_debugUploadSpool(playbackContext, requestNumber, contentType, currentFormat, requestByteRange, spoolMap)
    if not IsAssociativeArray(segment) then return invalid
    entry = segment.spooledSegment
    if not IsAssociativeArray(entry) then return invalid
    if IsAssociativeArray(playbackContext)
        playbackContext["lastStartSegmentIndex"] = sabr_toInt(entry?.mediaHeader?.sequenceNumber)
    end if
    entry["path"] = spoolPath
    return entry
end function

'------------------------------------------------------------------------------
' Function : sabr_buildStreamResponse
' Purpose  : Convert a resolved segment entry plus spool path into the payload
'            structure consumed by the Roku player.
'------------------------------------------------------------------------------
function sabr_buildStreamResponse(segmentEntry as object, spoolPath as string, requestByteRange as object, isInitRequest as boolean) as dynamic
    plan = sabr_planChunksForRequest(segmentEntry, requestByteRange, isInitRequest)
    if not IsAssociativeArray(plan) then return invalid

    coverage = sabr_byteRangeToCoverage(requestByteRange)
    if not IsAssociativeArray(coverage)
        coverage = {
            "rangeStart": sabr_toInt(segmentEntry?.startRange)
            "rangeEnd": sabr_toInt(segmentEntry?.endRange)
        }
    end if
    if plan.totalBytes > 0 and sabr_toInt(coverage?.rangeEnd) = invalid
        coverage["rangeEnd"] = sabr_toInt(coverage?.rangeStart) + plan.totalBytes - 1
    end if

    sequenceIndex = sabr_toInt(segmentEntry?.mediaHeader?.sequenceNumber)
    if sequenceIndex = invalid
        sequenceIndex = sabr_toInt(segmentEntry?.mediaHeader?.startSegmentIndex)
    end if

    response = {
        "path": spoolPath
        "chunks": plan.chunks
        "totalBytes": plan.totalBytes
        "coverage": coverage
        "sequenceIndex": sequenceIndex
        "cleanupPath": spoolPath
    }
    if segmentEntry?.isInitSeg = true
        response["isInitSeg"] = true
    end if
    return response
end function

'------------------------------------------------------------------------------
' Function : sabr_selectSpoolSegmentFromMap
' Purpose  : Given the spool summary, choose the entry whose key/range overlaps
'            the incoming player byte-range request.
'------------------------------------------------------------------------------
function sabr_selectSpoolSegmentFromMap(spoolMap as object, requestByteRange as object, keyParam as string) as dynamic
    segmentIndex = spoolMap?.segmentIndex
    if not IsAssociativeArray(segmentIndex) then return invalid
    startTarget = sabr_toInt(requestByteRange?.startRange)
    endTarget = sabr_toInt(requestByteRange?.endRange)
    fallbackEntry = invalid
    fallbackKey = ""
    for each segKey in segmentIndex.Keys()
        entry = segmentIndex.Lookup(segKey)
        if not IsAssociativeArray(entry) then continue for
        entryStart = sabr_toInt(entry?.startRange)
        if entryStart = invalid and IsAssociativeArray(entry?.mediaHeader)
            entryStart = sabr_toInt(entry.mediaHeader?.startRange)
            if entryStart = invalid then entryStart = sabr_toInt(entry.mediaHeader?.start)
        end if
        entryEnd = sabr_toInt(entry?.endRange)
        if entryEnd = invalid and IsAssociativeArray(entry?.mediaHeader)
            contentLength = sabr_toInt(entry.mediaHeader?.contentLength)
            if entryStart <> invalid and contentLength <> invalid and contentLength > 0
                entryEnd = entryStart + contentLength - 1
            end if
        end if
        matchesRange = false
        if entryStart = startTarget and (endTarget = invalid or entryEnd = endTarget or (entryEnd <> invalid and endTarget <= entryEnd))
            matchesRange = true
        else if startTarget <> invalid and entryStart <> invalid and entryEnd <> invalid
            if startTarget >= entryStart and (endTarget = invalid or endTarget <= entryEnd)
                matchesRange = true
            end if
        end if
        if matchesRange
            return {
                "spooledSegment": entry
                "spoolKey": `${entryStart}:${sabr_toSafeString(keyParam)}`
            }
        end if
        if fallbackEntry = invalid
            fallbackEntry = entry
            fallbackKey = segKey
        end if
    end for
    if IsAssociativeArray(fallbackEntry)
        entryStart = sabr_toInt(fallbackEntry?.startRange)
        if entryStart = invalid
            entryStart = sabr_toInt(fallbackEntry?.mediaHeader?.startRange)
        end if
        spoolKey = fallbackKey <> "" ? fallbackKey : `${entryStart}:${sabr_toSafeString(keyParam)}`
        return {
            "spooledSegment": fallbackEntry
            "spoolKey": spoolKey
        }
    end if
    return invalid
end function

'------------------------------------------------------------------------------
' Function : sabr_planChunksForRequest
' Purpose  : Determine which chunk offsets we truly need to read from the spool,
'            trimming out-of-range data and respecting init caching rules.
'------------------------------------------------------------------------------
function sabr_planChunksForRequest(segmentEntry as object, requestByteRange as object, isInitRequest as boolean) as dynamic
    chunks = segmentEntry?.chunks
    if not IsArray(chunks) or chunks.count() = 0 then return invalid

    needsTrim = isInitRequest
    requestStartVal = sabr_toInt(requestByteRange?.startRange)
    requestEndVal = sabr_toInt(requestByteRange?.endRange)
    segmentStartVal = sabr_toInt(segmentEntry?.startRange)
    segmentEndVal = sabr_toInt(segmentEntry?.endRange)
    if needsTrim <> true
        if requestStartVal <> invalid and segmentStartVal <> invalid and requestStartVal > segmentStartVal
            needsTrim = true
        end if
        if requestEndVal <> invalid and segmentEndVal <> invalid and requestEndVal < segmentEndVal
            needsTrim = true
        end if
    end if

    if needsTrim and requestStartVal <> invalid and requestEndVal <> invalid
        trimmed = sabr_trimSegmentChunksForRange(chunks, segmentStartVal, requestByteRange)
        if IsAssociativeArray(trimmed) then return trimmed
    end if

    totalBytes = sabr_toInt(segmentEntry?.totalBytes)
    if totalBytes = invalid or totalBytes <= 0
        totalBytes = 0
        for each chunk in chunks
            lenVal = sabr_toInt(chunk?.length)
            if lenVal <> invalid then totalBytes = totalBytes + lenVal
        end for
    end if
    return {
        "chunks": chunks
        "totalBytes": totalBytes
    }
end function

'------------------------------------------------------------------------------
' Function : sabr_trimSegmentChunksForRange
' Purpose  : Clip the SABR provided chunk list down to the requested byte range.
'------------------------------------------------------------------------------
function sabr_trimSegmentChunksForRange(chunks as object, segmentStart as dynamic, requestRange as object) as dynamic
    if not IsArray(chunks) then return invalid
    segmentStartVal = sabr_toInt(segmentStart)
    if segmentStartVal = invalid then return invalid
    requestStartVal = sabr_toInt(requestRange?.startRange)
    requestEndVal = sabr_toInt(requestRange?.endRange)
    if requestStartVal = invalid or requestEndVal = invalid then return invalid
    if requestEndVal < requestStartVal then return invalid

    offsetToSkip = requestStartVal - segmentStartVal
    if offsetToSkip < 0 then offsetToSkip = 0
    bytesNeeded = (requestEndVal - requestStartVal) + 1
    if bytesNeeded <= 0 then return invalid

    trimmedChunks = []
    remaining = bytesNeeded
    skip = offsetToSkip

    for each chunk in chunks
        chunkOffset = sabr_toInt(chunk?.offset)
        chunkLength = sabr_toInt(chunk?.length)
        if chunkOffset = invalid or chunkLength = invalid or chunkLength <= 0 then continue for

        if skip >= chunkLength
            skip = skip - chunkLength
            continue for
        end if

        effectiveOffset = chunkOffset + skip
        effectiveLength = chunkLength - skip
        if effectiveLength > remaining then effectiveLength = remaining

        if effectiveLength > 0
            trimmedChunks.push({
                "offset": effectiveOffset
                "length": effectiveLength
            })
            remaining = remaining - effectiveLength
        end if

        skip = 0
        if remaining <= 0 then exit for
    end for

    trimmedTotal = bytesNeeded - remaining
    if trimmedTotal <= 0 then return invalid

    return {
        "chunks": trimmedChunks
        "totalBytes": trimmedTotal
    }
end function

'------------------------------------------------------------------------------
' Function : sabr_byteRangeToCoverage
' Purpose  : Convert a byte-range request into numeric start/end coverage,
'            tolerating a variety of SABR byte-range formats.
'------------------------------------------------------------------------------
function sabr_byteRangeToCoverage(byteRange as object) as dynamic
    if not IsAssociativeArray(byteRange) then return invalid
    startLabel = `${byteRange?.startRange ?? byteRange?.start ?? ""}`
    endLabel = `${byteRange?.endRange ?? byteRange?.end ?? ""}`
    if startLabel = "" or endLabel = "" then return invalid
    startVal = sabr_toInt(startLabel)
    endVal = sabr_toInt(endLabel)
    if startVal = invalid or endVal = invalid or endVal < startVal then return invalid
    return {
        "rangeStart": startVal
        "rangeEnd": endVal
    }
end function

'------------------------------------------------------------------------------
' Function : sabr_getActiveFormats
' Purpose  : Build the list of formats the player considers viable right now,
'            falling back to cached context when SABR omits data.
'------------------------------------------------------------------------------
function sabr_getActiveFormats(currentFormat as object, sabr as object, playbackContext as object) as object
    formats = {
        "videoFormat": invalid
        "audioFormat": invalid
    }
    if IsAssociativeArray(currentFormat) and isValid(currentFormat?.width)
        formats.videoFormat = currentFormat
    else
        formats.audioFormat = currentFormat
    end if

    if not isValid(formats.videoFormat)
        formats.videoFormat = sabr_findFirstFormatOfType(sabr?.adaptiveFormats, true)
    end if
    if not isValid(formats.audioFormat)
        formats.audioFormat = sabr_findFirstFormatOfType(sabr?.adaptiveFormats, false)
    end if
    return formats
end function

'------------------------------------------------------------------------------
' Function : sabr_findFirstFormatOfType
' Purpose  : Utility to select the first audio/video format in a mixed array.
'------------------------------------------------------------------------------
function sabr_findFirstFormatOfType(formatList as object, wantsVideo as boolean) as dynamic
    if not IsArray(formatList) then return invalid
    for each fmt in formatList
        if wantsVideo and isValid(fmt?.width) then return fmt
        if not wantsVideo and not isValid(fmt?.width) then return fmt
    end for
    return invalid
end function

'------------------------------------------------------------------------------
' Playback context persistence
'------------------------------------------------------------------------------
'------------------------------------------------------------------------------
' Function : sabr_loadPlaybackContext
' Purpose  : Materialize (or initialize) the persisted playback context cache
'            keyed by mediaIdHash.
'------------------------------------------------------------------------------
function sabr_loadPlaybackContext(mediaIdHash as string, scopeKey = "root" as string) as object
    path = sabr_playbackContextPath(mediaIdHash, scopeKey)
    if not fileExists(path)
        ctx = {}
        ctx["mediaIdHash"] = mediaIdHash
        ctx["scope"] = scopeKey
        return ctx
    end if
    data = ParseJson(getFile(path))
    if not IsAssociativeArray(data)
        data = {}
        data["mediaIdHash"] = mediaIdHash
        data["scope"] = scopeKey
    else
        storedHash = sabr_toSafeString(data.Lookup("mediaIdHash"))
        if storedHash = ""
            data["mediaIdHash"] = mediaIdHash
        end if
        if not isValid(data?.scope) or sabr_toSafeString(data.scope) = ""
            data["scope"] = scopeKey
        end if
        if data.DoesExist("sidxIndexByFormat")
            data.Delete("sidxIndexByFormat")
        end if
    end if
    return data
end function

sub sabr_savePlaybackContext(mediaIdHash as string, playbackContext as object, scopeKey = "root" as string)
    path = sabr_playbackContextPath(mediaIdHash, scopeKey)
    if IsAssociativeArray(playbackContext) and playbackContext.DoesExist("sidxIndexByFormat")
        playbackContext.Delete("sidxIndexByFormat")
    end if
    writeFile(path, FormatJson(playbackContext))
end sub

function sabr_playbackContextPath(mediaIdHash as string, scopeKey = "root" as string) as string
    safeScope = sabr_sanitizeForFilename(sabr_toSafeString(scopeKey))
    if safeScope = "" then safeScope = "root"
    return `${sabr_mediaDir(mediaIdHash)}/playbackContext-${safeScope}.json`
end function

'------------------------------------------------------------------------------
' Request helpers
'------------------------------------------------------------------------------
'------------------------------------------------------------------------------
' Function : sabr_findFormatForKey
' Purpose  : Map the itag/format key coming from the player request back to the
'            SABR provided format metadata.
'------------------------------------------------------------------------------
function sabr_findFormatForKey(keyParam as string, sabr as object, contentType as string, logTag as string) as dynamic
    if not isValid(keyParam) or keyParam = "" return invalid
    parsed = sabr_parseScopedKey(keyParam)
    itag = parsed?.itag
    xTags = parsed?.xtags
    ' if IsAssociativeArray(parsed)
    '     scopedLabel = sabr_toSafeString(parsed?.scope)
    '     if scopedLabel <> "" and IsAssociativeArray(m?.logs)
    '         sabr_log(m.logs, log_level_Type.DEBUG, `[SIDX] request scoped key=${keyParam} scope=${scopedLabel}`)
    '     end if
    ' end if
    if itag = invalid
        ' fall back to legacy two-part parsing as a safety net
        parts = keyParam.Split(":")
        itag = sabr_toInt(parts[0])
        xTags = parts.count() > 1 ? parts[1] : ""
    end if
    candidates = sabr?.adaptiveFormats
    if not isValid(candidates) or candidates.count() = 0
        candidates = sabr?.hlsFormats
    end if
    if not IsArray(candidates) then return invalid
    for each format in candidates
        formatItag = sabr_toInt(format?.itag)
        formatXTags = sabr_toSafeString(format?.xTags)
        if formatItag = itag and formatXTags = xTags
            return format
        end if
    end for
    sabr_log(m.logs, log_level_Type.WARN, `${logTag} No matching format for ${keyParam}`, false)
    return invalid
end function

'------------------------------------------------------------------------------
' Function : sabr_getHeaderByteRange
' Purpose  : Parse the HTTP range header Roku sends for media requests.
'------------------------------------------------------------------------------
function sabr_getHeaderByteRange(request as object) as object
    startRange = "0"
    endRange = ""
    headerRange = ""
    if isValid(request?.headers?.Range)
        headerRange = request.headers.Range
    else if isValid(request?.headers?.range)
        headerRange = request.headers.range
    end if
    if headerRange <> ""
        pieces = headerRange.Split("=")
        if pieces.count() = 2
            setParts = pieces[1].Split("-")
            if setParts.count() = 2
                startRange = setParts[0]
                endRange = setParts[1]
            end if
        end if
    end if
    return {
        "startRange": startRange
        "endRange": endRange
    }
end function

'------------------------------------------------------------------------------
' Function : sabr_normalizeByteRange
' Purpose  : Clean up partial/degenerate range objects so downstream code can
'            assume consistent fields.
'------------------------------------------------------------------------------
function sabr_normalizeByteRange(byteRange as object, context = invalid as dynamic) as object
    startVal = sabr_toInt(byteRange?.startRange)
    endVal = sabr_toInt(byteRange?.endRange)
    if startVal = invalid then startVal = 0
    normalized = {
        "startRange": startVal
        "endRange": endVal
    }
    return normalized
end function

'------------------------------------------------------------------------------
' Function : sabr_isInit
' Purpose  : Decide if the incoming request targets an init segment (we treat
'            them very differently for caching/reporting).
'------------------------------------------------------------------------------
function sabr_isInit(contentType as string, format as object, requestByteRange as object, requestRef = invalid as dynamic) as boolean
    logTag = sabr_utilLogTag(contentType, requestRef)
    if sabr_rangesMatch(format?.initRange, requestByteRange)
        sabr_log(m.logs, log_level_Type.INFO, `${logTag} SABR format itag ${format.itag} init range requested: ${FormatJson(requestByteRange)}`)
        return true
    end if
    if sabr_rangesMatch(format?.indexRange, requestByteRange)
        sabr_log(m.logs, log_level_Type.INFO, `${logTag} SABR format itag ${format.itag} index range requested: ${FormatJson(requestByteRange)}`)
        return true
    end if
    return false
end function

'------------------------------------------------------------------------------
' Function : sabr_tryServeCachedInitSegment
' Purpose  : Return a cached init segment if we have a byte-for-byte match on
'            range, avoiding a SABR round-trip.
'------------------------------------------------------------------------------
function sabr_tryServeCachedInitSegment(playbackContext as object, mediaIdHash as string, contentType as string, keyParam as string, requestByteRange as object, isInitRequest as boolean, logTag = "" as string) as dynamic
    if not isInitRequest then return invalid
    scopeKey = sabr_toSafeString(playbackContext?.scope)
    if scopeKey = "" then scopeKey = "root"
    path = sabr_computeInitSegmentPath(mediaIdHash, contentType, keyParam, scopeKey)
    fs = CreateObject("roFileSystem")
    if fs.Exists(path) <> true then return invalid
    rangeStart = sabr_toInt(requestByteRange?.startRange)
    if rangeStart = invalid or rangeStart < 0 then rangeStart = 0
    rangeEnd = sabr_toInt(requestByteRange?.endRange)
    fileStat = fs.Stat(path)
    totalSize = sabr_toInt(fileStat?.size)
    if rangeEnd = invalid or rangeEnd >= totalSize then rangeEnd = totalSize - 1
    if rangeEnd < rangeStart or totalSize <= 0 then return invalid
    length = (rangeEnd - rangeStart) + 1
    bytes = CreateObject("roByteArray")
    if bytes.ReadFile(path, rangeStart, length) <> true then return invalid
    if logTag <> ""
        rangeLabel = sabr_formatRequestedRangeForPath(requestByteRange)
        sabr_log(m.logs, log_level_Type.INFO, `${logTag} Serving init/index from cache path=${path} range=${rangeLabel}`)
    end if
    return {
        "data": bytes
        "totalBytes": length
        "coverage": {
            "rangeStart": rangeStart
            "rangeEnd": rangeEnd
        }
        "isInitSeg": true
        "path": path
    }
end function

'------------------------------------------------------------------------------
' Function : sabr_computeInitSegmentPath
' Purpose  : Produce the canonical cache path for an init segment on disk.
'------------------------------------------------------------------------------
function sabr_computeInitSegmentPath(mediaIdHash as string, contentType as string, keyParam as string, scopeKey = "root" as string) as string
    baseDir = sabr_mediaDir(mediaIdHash)
    typeLabel = sabr_sanitizeForFilename(LCase(sabr_toSafeString(contentType)))
    rawKey = sabr_toSafeString(keyParam)
    scopeLabel = sabr_sanitizeForFilename(sabr_toSafeString(scopeKey))
    scopeSuffix = scopeLabel <> "" ? `:${scopeLabel}` : ""
    if rawKey <> "" and scopeSuffix <> "" and Right(rawKey, Len(scopeSuffix)) = scopeSuffix
        rawKey = Left(rawKey, Len(rawKey) - Len(scopeSuffix))
    end if
    keyLabel = sabr_sanitizeForFilename(rawKey)
    scopeLabel = sabr_sanitizeForFilename(sabr_toSafeString(scopeKey))
    if typeLabel = "" then typeLabel = "unknown"
    if keyLabel = "" then keyLabel = "nokey"
    if scopeLabel = "" then scopeLabel = "root"
    return `${baseDir}/init-${typeLabel}-${scopeLabel}-${keyLabel}.bin`
end function

sub sabr_materializeInitSegment(entry as object, spoolPath as string, mediaIdHash as string, contentType as string, keyParam as string, scopeKey = "root" as string)
    if not IsAssociativeArray(entry) then return
    targetPath = sabr_computeInitSegmentPath(mediaIdHash, contentType, keyParam, scopeKey)
    fs = CreateObject("roFileSystem")
    if fs.Exists(targetPath) then return
    chunkBytes = sabr_ump_readChunksFromSpool(spoolPath, entry?.chunks, sabr_toInt(entry?.totalBytes))
    if GetInterface(chunkBytes, "ifByteArray") = invalid or chunkBytes.count() = 0 then return
    chunkBytes.WriteFile(targetPath)
end sub

'------------------------------------------------------------------------------
' SABR proto + buffered ranges
'------------------------------------------------------------------------------
'------------------------------------------------------------------------------
' Function : sabr_createVideoPlaybackAbrRequest
' Purpose  : Populate the protobuf fields SABR expects for a proxied media pull.
'------------------------------------------------------------------------------
function sabr_createVideoPlaybackAbrRequest(request as object, contentType as string, sabr as object, currentFormat as object, activeFormats as object, requestByteRange as object, playbackContext as object, playerTimeOverride as dynamic, videoNode as object, requestRef = invalid as dynamic, isInitRequest = false as boolean) as object
    logTag = sabr_utilLogTag(contentType, requestRef)
    if not isValid(sabr?.ustreamerConfig) then return {}

    streamerContext = {
        "poToken": sabr.poToken
        "clientInfo": sabr.clientInfo
        "sabrContexts": []
        "unsentSabrContexts": []
    }
    if isValid(playbackContext?.lastPlaybackCookie)
        streamerContext["playbackCookie"] = playbackContext.lastPlaybackCookie
    end if

    bandwidthEstimate = sabr_pickMeasuredBitrate(videoNode?.completedStreamInfo)
    if bandwidthEstimate = invalid
        bandwidthEstimate = sabr_pickMeasuredBitrate(videoNode?.streamInfo)
    end if
    if bandwidthEstimate = invalid then bandwidthEstimate = sabr_toInt(currentFormat?.bitrate)
    if bandwidthEstimate = invalid or bandwidthEstimate <= 0 then bandwidthEstimate = 2000000

    rangePlayerInfo = sabr_resolvePlayerTimeFromRequest(playbackContext, contentType, currentFormat, requestByteRange)

    desiredPlayerTimeMs = sabr_toInt(rangePlayerInfo?.playerTimeMs)
    if desiredPlayerTimeMs = invalid or desiredPlayerTimeMs < 0
        desiredPlayerTimeMs = 0
    end if
    previousPlayerTimeMs = sabr_toInt(playbackContext.Lookup("lastRequestedPlayerTimeMs"))
    seekBackActive = sabr_detectSeekBack(previousPlayerTimeMs, desiredPlayerTimeMs)
    playbackContext["lastRequestedPlayerTimeMs"] = desiredPlayerTimeMs
    seqIdxDebug = sabr_toInt(rangePlayerInfo?.sequenceIndex)
    if seqIdxDebug <> invalid then playbackContext["lastStartSegmentIndex"] = seqIdxDebug
    playbackContext["lastPlayerTimeMs"] = desiredPlayerTimeMs

    AUDIO_ONLY = 1
    VIDEO_ONLY = 2

    req = {
        "clientAbrState": {
            "playbackRate": videoNode?.playbackSpeed ?? 1.0
            "playerTimeMs": desiredPlayerTimeMs.toStr()
            "clientViewportIsFlexible": false
            "bandwidthEstimate": bandwidthEstimate.toStr()
            "drcEnabled": currentFormat?.isDrc ?? false
            "enabledTrackTypesBitfield": isValid(currentFormat?.width) ? VIDEO_ONLY : AUDIO_ONLY
            "audioTrackId": currentFormat?.audioTrackId
        }
        "bufferedRanges": []
        "selectedFormatIds": []
        "preferredAudioFormatIds": []
        "preferredVideoFormatIds": []
        "preferredSubtitleFormatIds": []
        "videoPlaybackUstreamerConfig": sabr.ustreamerConfig
        "streamerContext": streamerContext
        "field1000": []
    }

    bufferedRanges = sabr_buildBufferedRanges(playbackContext, activeFormats, contentType, currentFormat, requestByteRange, desiredPlayerTimeMs, seekBackActive, isInitRequest, rangePlayerInfo)
    for each br in bufferedRanges
        req.bufferedRanges.push(br)
    end for

    if isInitRequest <> true
        sabr_pushFormatIfMissing(req.selectedFormatIds, currentFormat)
    end if
    if IsAssociativeArray(activeFormats?.audioFormat)
        req.preferredAudioFormatIds.push(activeFormats.audioFormat)
        if isInitRequest <> true or not sabr_formatsEqual(activeFormats.audioFormat, currentFormat)
            sabr_pushFormatIfMissing(req.selectedFormatIds, activeFormats.audioFormat)
        end if
    end if
    if IsAssociativeArray(activeFormats?.videoFormat)
        req.preferredVideoFormatIds.push(activeFormats.videoFormat)
        if isInitRequest <> true or not sabr_formatsEqual(activeFormats.videoFormat, currentFormat)
            sabr_pushFormatIfMissing(req.selectedFormatIds, activeFormats.videoFormat)
        end if
    end if
    return req
end function

'------------------------------------------------------------------------------
' Function : sabr_buildBufferedRanges
' Purpose  : Describe Roku's current buffer state so SABR can make bitrate
'            decisions consistent with the player.
'------------------------------------------------------------------------------
function sabr_buildBufferedRanges(playbackContext as object, activeFormats as object, contentType as string, currentFormat as object, requestByteRange as object, playerTimeMs as dynamic, seekBackActive as boolean, isInitRequest as boolean, rangeInfo = invalid as dynamic) as object
    ranges = []
    if not IsAssociativeArray(playbackContext) then playbackContext = {}

    if seekBackActive <> true and isInitRequest <> true
        previousRange = sabr_buildBufferedRangeFromSidx(playbackContext, contentType, currentFormat, playerTimeMs, rangeInfo)
        if IsAssociativeArray(previousRange) then ranges.push(previousRange)
    end if

    sentinelFormat = sabr_pickSentinelFormat(activeFormats, playbackContext, contentType)
    if IsAssociativeArray(sentinelFormat)
        ranges.push(sabr_createFullBufferRange(sentinelFormat))
    end if
    return ranges
end function

'------------------------------------------------------------------------------
' Function : sabr_pickSentinelFormat
' Purpose  : Choose a representative format when SABR does not include the one
'            Roku is actively streaming.
'------------------------------------------------------------------------------
function sabr_pickSentinelFormat(activeFormats as object, playbackContext as object, contentType as string) as dynamic
    sentinelType = UCase(contentType) = "AUDIO" ? "VIDEO" : "AUDIO"
    if sentinelType = "AUDIO"
        candidate = activeFormats?.audioFormat
    else
        candidate = activeFormats?.videoFormat
    end if
    if not isValid(candidate)
        candidate = sabr_pickBestFormat(playbackContext, sentinelType)
    end if
    if isValid(candidate) then return candidate
    return {
        "itag": sentinelType = "AUDIO" ? -100 : -200
        "xtags": "sentinel"
        "contentType": LCase(sentinelType)
    }
end function

'------------------------------------------------------------------------------
' Function : sabr_pickBestFormat
' Purpose  : Select the preferred format of a given type from previously cached
'            SABR responses.
'------------------------------------------------------------------------------
function sabr_pickBestFormat(playbackContext as object, formatType as string) as dynamic
    if not IsAssociativeArray(playbackContext) then return invalid
    history = playbackContext.Lookup("recentSegments")
    if not IsAssociativeArray(history) then return invalid
    for each key in history
        parts = key.Split("|")
        if parts.count() = 2 and parts[0] = UCase(formatType)
            current = history[key]?.current
            if IsAssociativeArray(current) and IsAssociativeArray(current?.format)
                return current.format
            end if
        end if
    end for
    return invalid
end function

'------------------------------------------------------------------------------
' Function : sabr_resolvePlayerTimeFromRequest
' Purpose  : Estimate the player's playback position when the request lacks the
'            timestamp data SABR expects.
'------------------------------------------------------------------------------
function sabr_resolvePlayerTimeFromRequest(playbackContext as object, contentType as string, currentFormat as object, requestByteRange as object) as dynamic
    entriesInfo = sabr_lookupSidxEntries(playbackContext, contentType, currentFormat)
    
    entries = entriesInfo?.entries
    if not IsArray(entries) or entries.count() = 0 then return invalid

    requestStart = sabr_toInt(requestByteRange?.startRange)
    if requestStart = invalid then return invalid

    matchedEntry = invalid

    totalEntries = entries.count()
    for idx = 0 to totalEntries - 1
        entry = entries[idx]
        if not IsAssociativeArray(entry) then continue for
        rangeStart = sabr_toInt(entry?.rangeStart)
        rangeEnd = sabr_toInt(entry?.rangeEnd)
        if rangeStart = invalid or rangeEnd = invalid then continue for

        ' Only accept an actual overlap with the requested start.
        if requestStart >= rangeStart and requestStart <= rangeEnd
            matchedEntry = entry
            exit for
        end if
    end for

    if not IsAssociativeArray(matchedEntry) then return invalid

    playerTimeMs = sabr_toInt(matchedEntry?.startTimeMs)
    if playerTimeMs = invalid then playerTimeMs = 0

    ' Instrumentation: log which SIDX entry we used for this range.
    scopeKey = sabr_toSafeString(playbackContext?.scope)
    mediaIdHash = sabr_toSafeString(playbackContext?.mediaIdHash)
    formatKey = sabr_formatKey(currentFormat)
    matchedStart = sabr_toInt(matchedEntry?.rangeStart)
    matchedEnd = sabr_toInt(matchedEntry?.rangeEnd)
    seqIndex = sabr_toInt(matchedEntry?.sequenceIndex)
    if isValid(m?.logs)
        sabr_log(m.logs, log_level_Type.DEBUG, `[SIDX] resolvePlayerTime scope=${scopeKey} media=${mediaIdHash} type=${contentType} format=${formatKey} reqStart=${requestStart} matchedRange=${matchedStart}-${matchedEnd} seq=${seqIndex} startMs=${playerTimeMs}`)
    end if

    info = {
        "playerTimeMs": playerTimeMs
        "sequenceIndex": sabr_toInt(matchedEntry?.sequenceIndex)
    }
    return info
end function

'------------------------------------------------------------------------------
' Function : sabr_detectSeekBack
' Purpose  : Identify rewind/seek-back behavior so SABR can adjust buffering.
'------------------------------------------------------------------------------
function sabr_detectSeekBack(previousPlayerTimeMs as dynamic, currentPlayerTimeMs as dynamic) as boolean
    currentVal = sabr_toInt(currentPlayerTimeMs)
    previousVal = sabr_toInt(previousPlayerTimeMs)
    if currentVal = invalid or currentVal < 0 then return false
    if previousVal = invalid or previousVal < 0 then return false
    toleranceMs = 750
    return currentVal + toleranceMs < previousVal
end function

'------------------------------------------------------------------------------
' Function : sabr_formatKey
' Purpose  : Build a stable key for cached format metadata.
'------------------------------------------------------------------------------
function sabr_formatKey(format as dynamic) as string
    if not IsAssociativeArray(format) then return ""
    itagLabel = sabr_toSafeString(format?.itag)
    xtagLabel = sabr_toSafeString(format?.xTags)
    if xtagLabel = "" then xtagLabel = sabr_toSafeString(format?.xtags)
    if itagLabel = "" and xtagLabel = "" then return ""
    if itagLabel = "" then return xtagLabel
    if xtagLabel = "" then return `${itagLabel}:`
    return `${itagLabel}:${xtagLabel}`
end function

'------------------------------------------------------------------------------
' Function : sabr_formatsEqual
' Purpose  : Compare two format structures ignoring incidental fields.
'------------------------------------------------------------------------------
function sabr_formatsEqual(left as dynamic, right as dynamic) as boolean
    return sabr_formatKey(left) = sabr_formatKey(right)
end function

sub sabr_pushFormatIfMissing(targetList as object, format as object)
    if not IsArray(targetList) then return
    if not IsAssociativeArray(format) then return
    newKey = sabr_formatKey(format)
    if newKey = "" then newKey = `${sabr_toSafeString(format?.itag)}:${sabr_toSafeString(format?.xTags)}`
    for each existing in targetList
        if sabr_formatKey(existing) = newKey
            return
        end if
    end for
    targetList.push(format)
end sub

'------------------------------------------------------------------------------
' Function : sabr_sidxIndexKey
' Purpose  : Derive cache key used to store parsed SIDX entries by content type.
'------------------------------------------------------------------------------
function sabr_sidxIndexKey(contentType as string, format as object, overrideKey = "" as string, scopeKey = "root" as string, mediaIdHash = "" as string) as string
    typeLabel = UCase(sabr_toSafeString(contentType))
    scopeLabel = UCase(sabr_toSafeString(scopeKey))
    mediaLabel = UCase(sabr_toSafeString(mediaIdHash))
    if typeLabel = "" then typeLabel = "UNKNOWN"
    if scopeLabel = "" then scopeLabel = "ROOT"
    if mediaLabel = "" then mediaLabel = "GLOBAL"
    formatKey = overrideKey
    if formatKey = "" then formatKey = sabr_formatKey(format)
    if formatKey = "" then formatKey = "default"
    return `${mediaLabel}|${scopeLabel}|${typeLabel}|${formatKey}`
end function

'------------------------------------------------------------------------------
' Function : sabr_lastSidxCacheForKey
' Purpose  : Provide single-entry module-scoped SIDX cache keyed by type/format/scope/media.
'------------------------------------------------------------------------------
function sabr_lastSidxCacheForKey(cacheKey as string) as dynamic
    lookupKey = sabr_toSafeString(cacheKey)
    if lookupKey = "" then return invalid
    cache = invalid
    if IsAssociativeArray(m) and m.DoesExist("lastSidxCache")
        cache = m.lastSidxCache
    end if
    if IsAssociativeArray(cache) and sabr_toSafeString(cache.Lookup("key")) = lookupKey
        info = cache.Lookup("info")
        if IsAssociativeArray(info) then return info
    end if
    return invalid
end function

sub sabr_setLastSidxCache(cacheKey as string, info as object)
    lookupKey = sabr_toSafeString(cacheKey)
    if lookupKey = "" or not IsAssociativeArray(info)
        m.lastSidxCache = invalid
        return
    end if
    ' Single-entry hot cache to avoid re-reading/parsing the same init SIDX repeatedly.
    m.lastSidxCache = {
        "key": lookupKey
        "info": info
    }
end sub

'------------------------------------------------------------------------------
' Function : sabr_reloadSidxEntriesFromInit
' Purpose  : Re-parse a cached init segment when SABR lacks fresh SIDX data.
'------------------------------------------------------------------------------
function sabr_reloadSidxEntriesFromInit(playbackContext as object, contentType as string, format as object, indexKey as string) as dynamic
    if not IsAssociativeArray(playbackContext) then return invalid
    if not IsAssociativeArray(format) then return invalid
    mediaIdHash = sabr_toSafeString(playbackContext.Lookup("mediaIdHash"))
    if mediaIdHash = "" then return invalid
    scopeKey = sabr_toSafeString(playbackContext.Lookup("scope"))
    if scopeKey = "" then scopeKey = "root"
    ' Use the scoped format key so we match the init filename we wrote (itag:xtags:scope).
    scopedFormatKey = sabr_formatKey(format)
    if scopedFormatKey = "" then return invalid
    initPath = sabr_computeInitSegmentPath(mediaIdHash, contentType, scopedFormatKey, scopeKey)
    fs = CreateObject("roFileSystem")
    readStartMs = CreateObject("roTimespan")
    readStartMs.Mark()
    if isValid(m?.logs)
        sabr_log(m.logs, log_level_Type.DEBUG, `[SIDX] init-path key=${indexKey} scope=${scopeKey} contentType=${contentType} format=${scopedFormatKey} path=${initPath}`)
    end if
    if fs.Exists(initPath) <> true
        if isValid(m?.logs)
            sabr_log(m.logs, log_level_Type.INFO, `[SIDX] init-missing path=${initPath} key=${indexKey}`)
        end if
        return invalid
    end if
    stat = fs.Stat(initPath)
    fileSize = sabr_toInt(stat?.size)
    if fileSize = invalid or fileSize <= 0 then return invalid

    bytes = CreateObject("roByteArray")
    if bytes.ReadFile(initPath, 0, fileSize) <> true then return invalid
    elapsedMs = 0
    if GetInterface(readStartMs, "ifTimespan") <> invalid
        elapsedMs = readStartMs.TotalMilliseconds()
    end if
    if isValid(m?.logs)
        sabr_log(m.logs, log_level_Type.INFO, `[SIDX] init-read path=${initPath} bytes=${fileSize} elapsedMs=${elapsedMs}`)
    end if

    formatInfo = sabr_formatToFormatId(format)
    if IsAssociativeArray(formatInfo)
        formatInfo["contentType"] = LCase(sabr_toSafeString(contentType))
    end if
    itagValue = sabr_toInt(format?.itag)
    xtagValue = sabr_toSafeString(format?.xtags)
    if xtagValue = "" then xtagValue = sabr_toSafeString(format?.xTags)
    mediaHeader = {
        "contentType": LCase(sabr_toSafeString(contentType))
        "formatId": formatInfo
        "format": {
            "itag": itagValue
            "xtags": xtagValue
            "contentType": LCase(sabr_toSafeString(contentType))
        }
        "itag": itagValue
        "xtags": xtagValue
        "startSegmentIndex": 0
    }
    update = sabr_ump_buildSidxIndexUpdate(invalid, mediaHeader, bytes)
    if not IsAssociativeArray(update) then return invalid

    fakeSegmentEntry = {
        "mediaHeader": {
            "startSegmentIndex": 0
        }
    }
    cacheInfo = sabr_storeSidxIndexUpdate(playbackContext, contentType, format, update, fakeSegmentEntry)
    if IsAssociativeArray(cacheInfo) and isValid(m?.logs)
        entryCount = IsArray(cacheInfo.entries) ? cacheInfo.entries.count() : 0
        sabr_log(m.logs, log_level_Type.INFO, `[SIDX] loaded-from-disk key=${indexKey} path=${initPath} entries=${entryCount}`)
    end if
    sabr_setLastSidxCache(indexKey, cacheInfo)
    return cacheInfo
end function

function sabr_storeSidxIndexUpdate(playbackContext as object, contentType as string, currentFormat as object, update as object, segmentEntry as object) as dynamic
    if not IsAssociativeArray(playbackContext) then return invalid
    if not IsAssociativeArray(update) then return invalid
    entries = update?.entries
    if not IsArray(entries) or entries.count() = 0 then return invalid

    formatKey = sabr_toSafeString(update?.formatKey)
    if formatKey = "" and IsAssociativeArray(segmentEntry?.mediaHeader?.formatId)
        formatKey = sabr_formatKey(segmentEntry.mediaHeader.formatId)
    end if
    if formatKey = "" and IsAssociativeArray(segmentEntry?.mediaHeader)
        formatKey = sabr_formatKey(segmentEntry.mediaHeader)
    end if
    scopeKey = sabr_toSafeString(playbackContext?.scope)
    if scopeKey = "" then scopeKey = "root"
    mediaIdHash = sabr_toSafeString(playbackContext?.mediaIdHash)
    key = sabr_sidxIndexKey(contentType, currentFormat, formatKey, scopeKey, mediaIdHash)

    sequenceBase = sabr_toInt(segmentEntry?.mediaHeader?.startSegmentIndex)
    if sequenceBase = invalid then sequenceBase = 0

    normalizedEntries = []
    idx = 0
    for each entry in entries
        if not IsAssociativeArray(entry) then
            idx = idx + 1
            continue for
        end if
        rangeStart = sabr_toInt(entry?.rangeStart)
        rangeEnd = sabr_toInt(entry?.rangeEnd)
        if rangeStart = invalid or rangeEnd = invalid
            idx = idx + 1
            continue for
        end if
        durationMs = sabr_toInt(entry?.durationMs)
        startTimeMs = sabr_toInt(entry?.startTimeMs)
        normalizedEntries.push({
            "rangeStart": rangeStart
            "rangeEnd": rangeEnd
            "durationMs": durationMs
            "startTimeMs": startTimeMs
            "sequenceIndex": sequenceBase + idx
        })
        idx = idx + 1
    end for
    if normalizedEntries.count() = 0 then return invalid

    cacheInfo = {
        "entries": normalizedEntries
        "sequenceBase": sequenceBase
    }
    scopeKey = sabr_toSafeString(playbackContext?.scope)
    if scopeKey = "" then scopeKey = "root"

    ' Debug: log the SIDX summary we just cached to confirm parsing correctness.
    if isValid(m?.logs)
        firstEntry = normalizedEntries[0]
        lastEntry = normalizedEntries[normalizedEntries.count() - 1]
        sabr_log(m.logs, log_level_Type.DEBUG, `[SIDX] cached scope=${scopeKey} media=${mediaIdHash} type=${contentType} format=${formatKey} timescale=${sabr_toInt(update?.timescale)} entries=${normalizedEntries.count()} firstRange=${sabr_toInt(firstEntry?.rangeStart)}-${sabr_toInt(firstEntry?.rangeEnd)} firstStartMs=${sabr_toInt(firstEntry?.startTimeMs)} lastRange=${sabr_toInt(lastEntry?.rangeStart)}-${sabr_toInt(lastEntry?.rangeEnd)} lastStartMs=${sabr_toInt(lastEntry?.startTimeMs)}`)
    end if
    sabr_setLastSidxCache(key, cacheInfo)
    return cacheInfo
end function

'------------------------------------------------------------------------------
' Function : sabr_lookupSidxEntries
' Purpose  : Wrapper that checks the in-memory cache before rebuilding SIDX
'            entries from scratch.
'------------------------------------------------------------------------------
function sabr_lookupSidxEntries(playbackContext as object, contentType as string, format as object) as dynamic
    scopeKey = sabr_toSafeString(playbackContext?.scope)
    if scopeKey = "" then scopeKey = "root"
    mediaIdHash = sabr_toSafeString(playbackContext?.mediaIdHash)
    key = sabr_sidxIndexKey(contentType, format, "", scopeKey, mediaIdHash)
    ' Fast path: reuse last SIDX if the key matches current scope/format/media.
    cached = sabr_lastSidxCacheForKey(key)
    if IsAssociativeArray(cached)
        if isValid(m?.logs)
            entryCount = IsArray(cached.entries) ? cached.entries.count() : 0
            sabr_log(m.logs, log_level_Type.INFO, `[SIDX] hit-last-cache key=${key} entries=${entryCount}`)
        end if
        return cached
    end if
    reloaded = sabr_reloadSidxEntriesFromInit(playbackContext, contentType, format, key)
    if IsAssociativeArray(reloaded) then return reloaded
    return invalid
end function

'------------------------------------------------------------------------------
' Function : sabr_buildBufferedRangeFromSidx
' Purpose  : Translate SIDX timing info into Roku buffered-range records.
'------------------------------------------------------------------------------
function sabr_buildBufferedRangeFromSidx(playbackContext as object, contentType as string, format as object, playerTimeMs as dynamic, rangeInfo = invalid as dynamic) as dynamic
    entriesInfo = sabr_lookupSidxEntries(playbackContext, contentType, format)
    entries = entriesInfo?.entries
    if not IsArray(entries) or entries.count() = 0 then return invalid

    sequenceIndex = invalid
    if IsAssociativeArray(rangeInfo)
        sequenceIndex = sabr_toInt(rangeInfo.Lookup("sequenceIndex"))
    end if

    previousEntry = invalid
    if sequenceIndex = invalid then return invalid
    sequenceBase = sabr_toInt(entriesInfo?.sequenceBase)
    if sequenceBase = invalid then sequenceBase = 0
    priorSequence = sequenceIndex - 1
    if priorSequence < sequenceBase then return invalid

    candidateIndex = priorSequence - sequenceBase
    if candidateIndex < 0 or candidateIndex >= entries.count() then return invalid
    candidate = entries[candidateIndex]
    if not IsAssociativeArray(candidate) then return invalid
    previousEntry = candidate

    if not IsAssociativeArray(previousEntry) then return invalid

    rangeStart = sabr_toInt(previousEntry?.rangeStart)
    rangeEnd = sabr_toInt(previousEntry?.rangeEnd)
    if rangeStart = invalid or rangeEnd = invalid then return invalid
    seqIndex = sabr_toInt(previousEntry?.sequenceIndex)
    if seqIndex = invalid then seqIndex = 0
    seqIndex1 = seqIndex + 1
    if seqIndex1 < 1 then seqIndex1 = 1
    durationMs = sabr_toInt(previousEntry?.durationMs)
    if durationMs = invalid then durationMs = 0
    startMs = sabr_toInt(previousEntry?.startTimeMs)
    if startMs = invalid then startMs = 0

    ' Instrumentation: log which buffered-range entry we derive from SIDX.
    scopeKey = sabr_toSafeString(playbackContext?.scope)
    mediaIdHash = sabr_toSafeString(playbackContext?.mediaIdHash)
    formatKey = sabr_formatKey(format)
    if isValid(m?.logs)
        sabr_log(m.logs, log_level_Type.DEBUG, `[SIDX] bufferedRange scope=${scopeKey} media=${mediaIdHash} type=${contentType} format=${formatKey} seq=${seqIndex} range=${rangeStart}-${rangeEnd} durationMs=${durationMs} startMs=${startMs}`)
    end if

    return {
        "rangeStart": rangeStart
        "rangeEnd": rangeEnd
        "formatId": sabr_formatToFormatId(format)
        "startSegmentIndex": seqIndex1
        "endSegmentIndex": seqIndex1
        "durationMs": durationMs
        "timeRange": {
            "timescale": 1000
            "startTicks": `${startMs}`
            "durationTicks": durationMs
        }
    }
end function

'------------------------------------------------------------------------------
' Function : sabr_applyControlEffects
' Purpose  : Apply SABR instructions such as redirects, context reloads, and
'            error reporting to the current playback context.
'------------------------------------------------------------------------------
function sabr_applyControlEffects(playbackContext as object, sabr as object, controlEffects as object, contentType as string, logTag as string) as dynamic
    info = {}
    if not IsAssociativeArray(controlEffects) then return info

    if IsAssociativeArray(playbackContext) <> true
        playbackContext = {}
    end if

    if IsAssociativeArray(controlEffects.nextRequestPolicy)
        playbackContext["nextRequestPolicy"] = controlEffects.nextRequestPolicy
        cookieProto = controlEffects.nextRequestPolicy?.playbackCookie
        if isValid(cookieProto)
            playbackContext["lastPlaybackCookie"] = cookieProto
        end if
    end if

    if IsAssociativeArray(controlEffects.sabrContextUpdate)
        playbackContext["lastSabrContextUpdate"] = controlEffects.sabrContextUpdate
    end if

    if IsAssociativeArray(controlEffects.redirect)
        redirectUrl = sabr_toSafeString(controlEffects.redirect?.url)
        if redirectUrl = "" then redirectUrl = sabr_toSafeString(controlEffects.redirect?.endpoint)
        if sabr_updateServerRedirect(playbackContext, sabr, redirectUrl, logTag)
            info["redirectUrl"] = redirectUrl
        end if
    end if

    if IsAssociativeArray(controlEffects.reloadPlaybackContext)
        playbackContext["lastReloadPlaybackContext"] = controlEffects.reloadPlaybackContext
        reloadInfo = sabr_handleReloadPlaybackContext(playbackContext, sabr, controlEffects.reloadPlaybackContext, logTag)
        if IsAssociativeArray(reloadInfo) and reloadInfo.Count() > 0
            info["reloadPlaybackContextResult"] = reloadInfo
        end if
    end if

    return info
end function

'------------------------------------------------------------------------------
' Function : sabr_mergeControlEffects
' Purpose  : Combine control effects discovered via stream tap and spool scan,
'            preferring later overlays when keys collide.
'------------------------------------------------------------------------------
function sabr_mergeControlEffects(spoolEffects as dynamic, tapEffects as dynamic) as dynamic
    hasSpool = IsAssociativeArray(spoolEffects)
    hasTap = IsAssociativeArray(tapEffects)
    if not hasSpool and not hasTap then return invalid

    merged = createObject("roAssociativeArray")
    if hasSpool
        for each key in spoolEffects.Keys()
            merged[key] = spoolEffects.Lookup(key)
        end for
    end if
    if hasTap
        for each key in tapEffects.Keys()
            merged[key] = tapEffects.Lookup(key)
        end for
    end if
    if merged.Count() = 0 then return invalid
    return merged
end function

'------------------------------------------------------------------------------
' Function : sabr_pickMeasuredBitrate
' Purpose  : Helper used when SABR returns multiple bitrate measurements.
'------------------------------------------------------------------------------
function sabr_pickMeasuredBitrate(info as object) as dynamic
    if not IsAssociativeArray(info) then return invalid
    bitrate = sabr_toInt(info?.bitrateMeasuredBps)
    if bitrate = invalid or bitrate <= 0
        bitrate = sabr_toInt(info?.bitrateTargetBps)
    end if
    return bitrate
end function

'------------------------------------------------------------------------------
' Function : sabr_createFullBufferRange
' Purpose  : Build a dummy buffer range that indicates "fully buffered".
'------------------------------------------------------------------------------
function sabr_createFullBufferRange(format as object) as object
    MAX_INT32_VALUE = 2147483647
    return {
        "formatId": sabr_formatToFormatId(format)
        "durationMs": MAX_INT32_VALUE
        "startTimeMs": "0"
        "startSegmentIndex": MAX_INT32_VALUE
        "endSegmentIndex": MAX_INT32_VALUE
        "timeRange": {
            "timescale": 1000
            "startTicks": "0"
            "durationTicks": MAX_INT32_VALUE
        }
    }
end function

'------------------------------------------------------------------------------
' Function : sabr_handleReloadPlaybackContext
' Purpose  : Merge SABR-provided playback context data into our cache.
'------------------------------------------------------------------------------
function sabr_handleReloadPlaybackContext(playbackContext as object, sabr as object, reloadContext as object, logTag as string) as dynamic
    if not IsAssociativeArray(reloadContext) then return invalid
    updates = {}

    newConfig = reloadContext.Lookup("ustreamerConfig")
    if isValid(newConfig)
        updates["ustreamerConfig"] = newConfig
        if isValid(sabr) then sabr.ustreamerConfig = newConfig
        if IsAssociativeArray(playbackContext) then playbackContext["ustreamerConfig"] = newConfig
    end if

    serverUrl = sabr_toSafeString(reloadContext.Lookup("serverAbrStreamingUrl"))
    if serverUrl = "" and IsAssociativeArray(reloadContext?.serverAbrStreamingEndpoint)
        serverUrl = sabr_toSafeString(reloadContext.serverAbrStreamingEndpoint.Lookup("url"))
    end if
    if serverUrl <> ""
        updates["serverAbrStreamingUrl"] = serverUrl
        sabr_updateServerRedirect(playbackContext, sabr, serverUrl, logTag)
    end if

    if updates.Count() > 0 and isValid(m?.logs)
        sabr_log(m.logs, log_level_Type.INFO, `${logTag} Applied reload playback updates ${FormatJson(updates)}`)
    end if
    return updates
end function

'------------------------------------------------------------------------------
' Function : sabr_updateServerRedirect
' Purpose  : Track server-provided redirect URLs and expose them to callers.
'------------------------------------------------------------------------------
function sabr_updateServerRedirect(playbackContext as object, sabr as object, redirectUrl as string, logTag as string) as boolean
    target = sabr_toSafeString(redirectUrl)
    if target = "" then return false
    if isValid(sabr)
        sabr.serverAbrStreamingUrl = target
    end if
    if IsAssociativeArray(playbackContext)
        playbackContext["serverAbrStreamingUrl"] = target
    end if
    sabr_log(m.logs, log_level_Type.INFO, `${logTag} Updated SABR server URL via redirect: ${target}`)
    return true
end function

'------------------------------------------------------------------------------
' Response helpers
'------------------------------------------------------------------------------
'------------------------------------------------------------------------------
' Function : sabr_buildResponseForPlayer
' Purpose  : Convert the SABR spool payload into the Roku player response the
'            SceneGraph video node expects.
'------------------------------------------------------------------------------
function sabr_buildResponseForPlayer(requestMetadata as object, umpResult as dynamic, currentFormat as object, requestByteRange as object, contentType as string) as object
    headers = CreateObject("roAssociativeArray")
    mimeType = currentFormat?.mimeType
    if not isValid(mimeType) or mimeType = ""
        mimeType = LCase(contentType) = "audio" ? "audio/mp4" : "video/mp4"
    end if
    headers["Content-Type"] = mimeType
    headers["Accept-Ranges"] = "bytes"

    chunkPlan = umpResult?.chunks
    chunkPath = sabr_toSafeString(umpResult?.path)
    if IsArray(chunkPlan) and chunkPath <> ""
        totalBytes = sabr_toInt(umpResult?.totalBytes)
        if totalBytes = invalid or totalBytes <= 0
            totalBytes = 0
            for each chunkEntry in chunkPlan
                lenVal = sabr_toInt(chunkEntry?.length)
                if lenVal <> invalid then totalBytes = totalBytes + lenVal
            end for
        end if

        coverage = umpResult?.coverage
        coverageStart = sabr_toInt(coverage?.rangeStart)
        coverageEnd = sabr_toInt(coverage?.rangeEnd)
        if coverageStart = invalid then coverageStart = sabr_toInt(requestByteRange?.startRange)
        if coverageEnd = invalid and totalBytes > 0
            coverageEnd = coverageStart + totalBytes - 1
        end if
        headers["Content-Length"] = totalBytes.toStr()
        headers["Content-Range"] = `bytes ${coverageStart}-${coverageEnd}/${coverageEnd + 1}`

        response = {
            "status": 206
            "headers": headers
            "path": chunkPath
            "chunks": chunkPlan
            "totalBytes": totalBytes
        }
        if IsAssociativeArray(umpResult?.coverage)
            response["coverage"] = umpResult.coverage
        end if
        if umpResult?.isInitSeg = true
            response["isInitSeg"] = true
        end if
        cleanupPath = sabr_toSafeString(umpResult?.cleanupPath)
        if cleanupPath <> ""
            response["cleanupPath"] = cleanupPath
        end if
        return response
    end if

    dataBlob = umpResult?.data
    if GetInterface(dataBlob, "ifByteArray") <> invalid and dataBlob.count() > 0
        coverage = umpResult?.coverage
        coverageStart = sabr_toInt(coverage?.rangeStart)
        coverageEnd = sabr_toInt(coverage?.rangeEnd)
        if coverageStart = invalid then coverageStart = sabr_toInt(requestByteRange?.startRange)
        if coverageEnd = invalid
            coverageEnd = coverageStart + dataBlob.count() - 1
        end if
        headers["Content-Length"] = dataBlob.count().toStr()
        headers["Content-Range"] = `bytes ${coverageStart}-${coverageEnd}/${coverageEnd + 1}`
        response = {
            "status": 206
            "headers": headers
            "data": dataBlob
            "coverage": {
                "rangeStart": coverageStart
                "rangeEnd": coverageEnd
            }
        }
        if umpResult?.isInitSeg = true
            response["isInitSeg"] = true
        end if
        return response
    end if

    return sabr_buildErrorResponseForPlayer(500, "empty body")
end function

'------------------------------------------------------------------------------
' Function : sabr_buildErrorResponseForPlayer
' Purpose  : Minimal helper for translating fatal SABR failures into HTTP
'            responses the Roku player can understand.
'------------------------------------------------------------------------------
function sabr_buildErrorResponseForPlayer(status as integer, message as string) as object
    return {
        "status": status
        "headers": {
            "Content-Type": "text/plain"
            "Content-Length": len(message).toStr()
        }
        "body": message
    }
end function

sub sabr_debugUploadSpool(playbackContext as object, requestNumber as string, contentType as string, currentFormat as object, requestByteRange as object, spoolMap as object)
    debugUploadUrl = m.top?.debugUploadUrl
    if debugUploadUrl = "" then return
    try
        label = sabr_debugBuildDumpLabel(playbackContext, "sabr-request", requestNumber, sabr_formatRequestedRangeForPath(requestByteRange), contentType, currentFormat, invalid)
        sabr_debugUploadText(debugUploadUrl, `${LCase(contentType)}/${label}-spool.json`, FormatJson(spoolMap), m.logs)
    catch e
        ' swallow debug upload failures
    end try
end sub

sub sabr_debugDumpRequestPayload(playbackContext as object, payload as object, requestByteRange as object, contentType as string, currentFormat as object, logTag as string, requestNumber as string)
    debugUploadUrl = m.top?.debugUploadUrl
    if debugUploadUrl = "" then return
    if not IsAssociativeArray(payload) then return
    rangeLabel = sabr_formatRequestedRangeForPath(requestByteRange)
    label = sabr_debugBuildDumpLabel(playbackContext, "abr-request", requestNumber, rangeLabel, contentType, currentFormat, invalid)
    try
        serialized = FormatJson(payload)
        if serialized <> ""
            sabr_debugUploadText(debugUploadUrl, `${LCase(contentType)}/${label}.json`, serialized, m.logs)
        end if
    catch e
        sabr_log(m.logs, log_level_Type.WARN, `${logTag} Failed to serialize SABR request payload`, false)
    end try
end sub

sub sabr_debugDumpResponse(playbackContext as object, response as object, requestByteRange as object, contentType as string, currentFormat as object, logTag as string, requestNumber as string)
    debugUploadUrl = m.top?.debugUploadUrl
    if debugUploadUrl = "" then return
    if not IsAssociativeArray(response) then return
    chunks = response.Lookup("chunks")
    bytes = invalid
    if IsArray(chunks) and chunks.count() > 0
        spoolPath = sabr_toSafeString(response?.path)
        if spoolPath = "" then return
        totalBytes = sabr_toInt(response?.totalBytes)
        bytes = sabr_ump_readChunksFromSpool(spoolPath, chunks, totalBytes)
    else
        bytes = response.Lookup("data")
    end if
    if GetInterface(bytes, "ifByteArray") = invalid or bytes.count() = 0 then return

    sabr_debugValidateMp4Bytes(bytes, logTag, contentType)

    rangeLabel = sabr_formatRequestedRangeForPath(requestByteRange)
    if rangeLabel = "" and IsAssociativeArray(response?.coverage)
        coverageRange = {
            "startRange": response.coverage.Lookup("rangeStart")
            "endRange": response.coverage.Lookup("rangeEnd")
        }
        rangeLabel = sabr_formatRequestedRangeForPath(coverageRange)
    end if

    label = sabr_debugBuildDumpLabel(playbackContext, "player-response", requestNumber, rangeLabel, contentType, currentFormat, invalid)
    relativePath = `${LCase(contentType)}/${label}.bin`
    sabr_debugUploadBytes(debugUploadUrl, relativePath, bytes, m.logs)
end sub

sub sabr_debugValidateMp4Bytes(bytes as object, logTag as string, contentType as string)
    boxes = sabr_mp4_parseBoxes(bytes, 8)
    if not IsArray(boxes) or boxes.count() = 0
        sabr_log(m.logs, log_level_Type.WARN, `${logTag} ${contentType} unable to parse MP4 boxes for debug dump`, false)
        return
    end if
    summary = []
    for each boxInfo in boxes
        boxType = sabr_toSafeString(boxInfo?.type)
        boxSize = sabr_toInt(boxInfo?.size)
        summary.push(`${boxType}:${boxSize}`)
    end for
    sabr_log(m.logs, log_level_Type.INFO, `${logTag} ${contentType} MP4 boxes ${summary.Join(" ")}`)
end sub

sub sabr_deleteFileIfExists(path as dynamic)
    if not IsString(path) or path = "" then return
    fs = CreateObject("roFileSystem")
    if fs.Exists(path)
        fs.Delete(path)
    end if
end sub

'------------------------------------------------------------------------------
' Function : fileExists
' Purpose  : Tiny wrapper that tolerates invalid values before touching disk.
'------------------------------------------------------------------------------
function fileExists(path as dynamic) as boolean
    if not IsString(path) or path = "" then return false
    fs = CreateObject("roFileSystem")
    return fs.Exists(path)
end function

'------------------------------------------------------------------------------
' Function : sabr_rangesMatch
' Purpose  : Compare two range objects irrespective of which optional fields
'            were populated.
'------------------------------------------------------------------------------
function sabr_rangesMatch(rangeObj as dynamic, requestRange as object) as boolean
    if not isValid(rangeObj) then return false
    expectedStart = `${rangeObj?.start ?? rangeObj?.startRange ?? ""}`
    expectedEnd = `${rangeObj?.end ?? rangeObj?.endRange ?? ""}`
    requestStart = `${requestRange?.startRange ?? requestRange?.start ?? ""}`
    requestEnd = `${requestRange?.endRange ?? requestRange?.end ?? ""}`
    if expectedStart = "" or expectedEnd = "" or requestStart = "" or requestEnd = "" then return false
    return expectedStart = requestStart and expectedEnd = requestEnd
end function

'------------------------------------------------------------------------------
' Function : sabr_utilLogTag
' Purpose  : Provide consistent log prefixes when helper functions emit logs.
'------------------------------------------------------------------------------
function sabr_utilLogTag(contentType as string, requestRef = invalid as dynamic) as string
    typeLabel = sabr_toSafeString(contentType)
    if typeLabel = "" then typeLabel = "UNKNOWN"
    refLabel = ""
    if requestRef <> invalid
        refLabel = sabr_toSafeString(requestRef)
    end if
    if refLabel = ""
        return `[YTSABR-${typeLabel}]`
    end if
    return `[YTSABR-${typeLabel}-${refLabel}]`
end function

'------------------------------------------------------------------------------
' Function : sabr_nextRequestId
' Purpose  : Increment-and-return the rolling request counter per media session.
'------------------------------------------------------------------------------
function sabr_nextRequestId(playbackContext as object) as string
    ' nextRequestId = m.top.utilsTask.callFunc("getNextId", "sabrRequestNumber")
    globalAA = GetGlobalAA()
    seq = sabr_toInt(globalAA.Lookup("sabrGlobalRequestSequence"))
    if seq = invalid or seq < 0 then seq = 0
    seq = seq + 1
    globalAA["sabrGlobalRequestSequence"] = seq
    if IsAssociativeArray(playbackContext)
        playbackContext["requestSequence"] = seq
    end if
    return seq.toStr()
end function
