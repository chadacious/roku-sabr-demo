import "pkg:/source/ytproto/generated/runtime.brs"
import "pkg:/source/ytproto/generated/messages/VideoPlaybackAbrRequest.brs"
import "pkg:/source/ytproto/generated/messages/ClientAbrState.brs"
import "pkg:/source/ytproto/generated/messages/FormatId.brs"
import "pkg:/source/ytproto/generated/messages/StreamerContext.brs"
import "pkg:/source/ytproto/generated/messages/ClientInfo.brs"
import "pkg:/source/ytproto/generated/messages/TimeRange.brs"
import "pkg:/source/ytproto/generated/messages/BufferedRange.brs"
import "pkg:/source/ytproto/generated/messages/StreamerContext.brs"  
import "pkg:/source/ytproto/generated/messages/SabrContext.brs"
import "pkg:/source/ytproto/generated/messages/GLDeviceInfo.brs"
import "pkg:/source/ytproto/generated/messages/MediaCapabilities.brs"
import "pkg:/source/ytproto/generated/messages/VideoFormatCapability.brs"
import "pkg:/source/ytproto/generated/messages/AudioFormatCapability.brs"
import "pkg:/source/ytproto/generated/messages/PlaybackAuthorization.brs"
import "pkg:/source/ytproto/generated/messages/AuthorizedFormat.brs"
import "pkg:/source/ytproto/generated/messages/Range.brs"
import "pkg:/source/ytproto/generated/messages/PlaybackCookie.brs"
import "pkg:/source/ytproto/generated/messages/UnknownInnerMessage.brs"
import "pkg:/source/ytproto/generated/messages/UnknownInnerMessage1.brs"
import "pkg:/source/ytproto/generated/messages/UnknownMessage3.brs"
import "pkg:/source/ytproto/generated/messages/VideoStreamingBufferedRangeUnknownMessage1.brs"
import "pkg:/source/ytproto/generated/messages/VideoStreamingBufferedRangeUnknownMessage2.brs"
import "pkg:/source/ytproto/generated/messages/VideoStreamingStreamerContextUnknownMessage1.brs"
import "pkg:/source/ytproto/generated/messages/VideoStreamingUnknownMessage1.brs"
import "pkg:/source/ytproto/generated/messages/VideoStreamingUnknownMessage2.brs"
import "pkg:/source/SabrUmpProcessor.bs"
import "pkg:/source/SabrSimpleCache.bs"
import "pkg:/source/SabrRequestMetadataManager.bs"
import "pkg:/source/isItem.bs"
import "pkg:/source/httpRequest.bs"
import "pkg:/source/taskUtils.bs"

const SABR_REPEAT_SEGMENT_THRESHOLD = 4
const SABR_REPEAT_SEGMENT_WINDOW_MS = 5000
const SABR_UMP_STREAM_CHUNK_SIZE = 131072
const SABR_CHUNK_BUFFER_POOL_LIMIT = 6
const MAX_BUFFERED_RANGES_PER_TYPE = 1

const PLAYER_TIME_STRATEGY_SIDX = "sidx"
const PLAYER_TIME_STRATEGY_METADATA = "metadata"
const PLAYER_TIME_STRATEGY_HYBRID = "hybrid"
const DEFAULT_PLAYER_TIME_STRATEGY = PLAYER_TIME_STRATEGY_HYBRID

function sabr_getHeaderByteRange(request as object) as object
    range = "bytes=0-"
    if isValid(request.headers.Range)
        range = request.headers.Range
    else if isValid(request.headers.range)
        range = request.headers.range
    end if
    ' split the range into start and end
    parts = range.Split("=")[1].Split("-")
    if parts.count() = 2
        startRange = parts[0]
        endRange = parts[1]
    end if
    return { "startRange": startRange, "endRange": endRange }
end function

function sabr_collectBufferedRangesForFormat(mediaIdHash as string, formatType as string, activeFormat as object) as object
    ranges = []
    if not isValid(activeFormat) then return ranges
    if not isValid(mediaIdHash) or mediaIdHash = "" then return ranges

    entries = sabr_cacheListEntries(mediaIdHash, formatType, activeFormat?.itag, activeFormat?.audioTrackId ?? "")
    if not IsArray(entries) or entries.count() = 0 then return ranges

    segmentEntries = []
    for each entry in entries
        if entry?.isInit = true then continue for
        segmentEntries.push(entry)
    end for
    if segmentEntries.count() = 0 then return ranges

    sortedEntries = sabr_sortCacheEntriesBySegment(segmentEntries)
    newest = []
    seen = {}
    total = sortedEntries.count()
    for idx = total - 1 to 0 step -1
        entry = sortedEntries[idx]
        metadata = sabr_buildMetadataFromCacheEntry(entry, activeFormat, formatType)
        rangeEntry = sabr_buildBufferedRangeFromMetadata(metadata)
        if isValid(rangeEntry)
            startKey = rangeEntry?.startSegmentIndex
            if startKey = invalid then startKey = rangeEntry?.rangeStart
            label = `${startKey ?? ""}`
            if label <> ""
                if seen.DoesExist(label)
                    continue for
                end if
                seen[label] = true
            end if
            newest.push(rangeEntry)
            if newest.count() >= MAX_BUFFERED_RANGES_PER_TYPE
                exit for
            end if
        end if
    end for

    if newest.count() > 0
        for idx = newest.count() - 1 to 0 step -1
            ranges.push(newest[idx])
        end for
    end if

    return ranges
end function

function sabr_currentPlayerPositionMs(videoNode as object, playbackContext as object) as dynamic
    positionSeconds = invalid
    if isValid(videoNode) and isValid(videoNode.position)
        positionSeconds = videoNode.position
    end if
    if positionSeconds = invalid and isValid(playbackContext?.lastPlayerTimeSecs)
        positionSeconds = playbackContext.lastPlayerTimeSecs
    end if
    if positionSeconds = invalid then return invalid
    return int((positionSeconds ?? 0) * 1000)
end function

function sabr_buildBufferedState(mediaIdHash as string, currentFormat as object, activeFormats as object, playbackContext as object, requestedFormatType as string) as object
    rangesByType = {}
    rangesByType["AUDIO"] = []
    rangesByType["VIDEO"] = []

    state = {
        "formatToDiscard": invalid
        "rangesByType": rangesByType
    }

    currentFormatKey = sabr_formatToKey(currentFormat)
    activeFormatKeys = [ "audioFormat", "videoFormat" ]

    for each fieldName in activeFormatKeys
        format = activeFormats[fieldName]
        if not isValid(format)
            if fieldName = "audioFormat" and isValid(activeFormats.audioFormat)
                format = activeFormats.audioFormat
            else if fieldName = "videoFormat" and isValid(activeFormats.videoFormat)
                format = activeFormats.videoFormat
            end if
        end if

        if not isValid(format) then continue for

        formatType = sabr_formatTypeFromFormat(format)
        if formatType = "" then formatType = "UNKNOWN"

        if not state.rangesByType.DoesExist(formatType)
            state.rangesByType[formatType] = []
        end if

        shouldDiscard = sabr_formatToKey(format) <> currentFormatKey
        bufferedRanges = []
        if shouldDiscard
            bufferedRanges = [ sabr_createFullBufferRange(format) ]
            if not isValid(state["formatToDiscard"])
                state["formatToDiscard"] = format
            end if
        else
            bufferedRanges = sabr_collectBufferedRangesForFormat(mediaIdHash, formatType, format)
        end if

        if IsArray(bufferedRanges)
            for each bufferedRange in bufferedRanges
                if isValid(bufferedRange)
                    state.rangesByType[formatType].push(bufferedRange)
                end if
            end for
        else if isValid(bufferedRanges)
            state.rangesByType[formatType].push(bufferedRanges)
        end if
    end for

    return state
end function

function sabr_applyBufferedStateToRequest(videoPlaybackAbrRequest as object, bufferState as object) as dynamic
    if not IsAssociativeArray(bufferState) then return invalid

    rangeMap = bufferState?.rangesByType
    if IsAssociativeArray(rangeMap)
        for each rangeType in rangeMap
            ranges = rangeMap[rangeType]
            if IsArray(ranges)
                for each bufferedRange in ranges
                    if isValid(bufferedRange)
                        videoPlaybackAbrRequest.bufferedRanges.push(bufferedRange)
                    end if
                end for
            end if
        end for
    end if

    return bufferState?.formatToDiscard
end function


sub sabr_ensurePlayerTimeStrategy(playbackContext as object) as void
    if not IsAssociativeArray(playbackContext) then return
    current = playbackContext?.playerTimeStrategy
    if isValid(current) and current <> "" then return

    defaultStrategy = DEFAULT_PLAYER_TIME_STRATEGY
    override = invalid
    if isValid(m?.top?.playerTimeStrategy)
        override = `${m.top.playerTimeStrategy}`
    end if
    if isValid(override) and override <> ""
        defaultStrategy = LCase(override)
    end if
    playbackContext["playerTimeStrategy"] = defaultStrategy
end sub

function sabr_determinePlayerTimeStrategy(playbackContext as object) as string
    if not IsAssociativeArray(playbackContext) then return DEFAULT_PLAYER_TIME_STRATEGY
    sabr_ensurePlayerTimeStrategy(playbackContext)
    strategy = playbackContext?.playerTimeStrategy
    if not isValid(strategy) or strategy = "" then return DEFAULT_PLAYER_TIME_STRATEGY
    normalized = LCase(`${strategy}`)
    if normalized = PLAYER_TIME_STRATEGY_SIDX or normalized = PLAYER_TIME_STRATEGY_METADATA or normalized = PLAYER_TIME_STRATEGY_HYBRID
        return normalized
    end if
    return DEFAULT_PLAYER_TIME_STRATEGY
end function

function sabr_globalSidxIndexMap() as object
    if not IsAssociativeArray(m?.sidxIndexCache)
        m.sidxIndexCache = {}
    end if
    return m.sidxIndexCache
end function

function sabr_requestedByteStart(byteRange as object) as dynamic
    if not IsAssociativeArray(byteRange) then return invalid
    startVal = sabr_toInt(byteRange?.startRange)
    if startVal = invalid then startVal = sabr_toInt(byteRange?.start)
    if startVal = invalid
        label = ""
        if byteRange.DoesExist("startRange") then label = `${byteRange.startRange}`
        if label = "" and byteRange.DoesExist("start") then label = `${byteRange.start}`
        if label <> ""
            startVal = Val(label)
        end if
    end if
    if startVal = invalid and byteRange.DoesExist("segmentIndexInfo")
        info = byteRange.segmentIndexInfo
        if IsAssociativeArray(info)
            startVal = sabr_toInt(info?.rangeStart)
            if startVal = invalid and isValid(info?.rangeStart)
                startLabel = `${info.rangeStart}`
                if startLabel <> ""
                    startVal = Val(startLabel)
                end if
            end if
        end if
    end if
    return startVal
end function

function sabr_resolvePlayerTimeMsForRequest(playbackContext as object, contentType as string, currentFormat as object, requestByteRange as object, videoNode as object) as object
    sabr_ensurePlayerTimeStrategy(playbackContext)

    strategy = sabr_determinePlayerTimeStrategy(playbackContext)
    attempts = []
    if strategy = PLAYER_TIME_STRATEGY_SIDX
        attempts = [ PLAYER_TIME_STRATEGY_SIDX ]
    else if strategy = PLAYER_TIME_STRATEGY_METADATA
        attempts = [ PLAYER_TIME_STRATEGY_METADATA ]
    else
        attempts = [ PLAYER_TIME_STRATEGY_SIDX, PLAYER_TIME_STRATEGY_METADATA ]
    end if

    if isValid(m?.logs)
        entryStatus = "none"
        globalKeys = []
        globalMap = sabr_globalSidxIndexMap()
        if IsAssociativeArray(globalMap)
            for each keyName in globalMap
                globalKeys.push(keyName)
            end for
            entryStatus = `global:${globalKeys.count()}${FormatJson(globalKeys)}`
        end if
        contextKeys = []
        contextMap = playbackContext?.sidxIndexByFormat
        if IsAssociativeArray(contextMap)
            for each ctxKey in contextMap
                contextKeys.push(ctxKey)
            end for
            entryStatus = `${entryStatus}|context:${contextKeys.count()}${FormatJson(contextKeys)}`
        end if
        m.logs.printl(log_level_Type.DEBUG, `[YTSABR-PlayerTime] Strategy ${strategy} sidxIndex=${entryStatus}`)
    end if

    for each attempt in attempts
        result = invalid
        if attempt = PLAYER_TIME_STRATEGY_SIDX
            result = sabr_lookupPlayerTimeMsFromSidx(playbackContext, contentType, currentFormat, requestByteRange)
        else if attempt = PLAYER_TIME_STRATEGY_METADATA
            result = sabr_lookupPlayerTimeMsFromMetadata(playbackContext, contentType, currentFormat, requestByteRange)
        end if

        candidate = sabr_toInt(result?.value)
        if candidate <> invalid and candidate >= 0
            label = result?.source
            if not isValid(label) or label = "" then label = attempt
            return {
                "value": candidate
                "source": label
            }
        end if
    end for

    actualPositionMs = sabr_currentPlayerPositionMs(videoNode, playbackContext)
    if actualPositionMs <> invalid and actualPositionMs >= 0
        return {
            "value": actualPositionMs
            "source": "playerPosition"
        }
    end if

    fallbackInfo = sabr_resolveFallbackPlayerTimeMsInfo(playbackContext, currentFormat)
    fallbackValue = sabr_toInt(fallbackInfo?.value)
    if fallbackValue = invalid then fallbackValue = 0
    fallbackSource = fallbackInfo?.source
    if not isValid(fallbackSource) or fallbackSource = "" then fallbackSource = "default"
    return {
        "value": fallbackValue
        "source": `fallback:${fallbackSource}`
    }
end function

function sabr_buildPlayerTimeIndexKey(contentType as string, format as object) as string
    typeLabel = `${contentType ?? ""}`
    if typeLabel = "" then typeLabel = sabr_formatTypeFromFormat(format)
    if typeLabel = "" then typeLabel = "UNKNOWN"
    return `${typeLabel}|${sabr_formatToKey(format)}`
end function

function sabr_parseFormatKey(formatKey as string) as object
    info = {
        "itag": invalid
        "xtags": ""
    }
    if not isValid(formatKey) then return info
    parts = formatKey.Split(":")
    if parts.count() >= 1
        info.itag = sabr_toInt(parts[0])
    end if
    if parts.count() >= 2
        info.xtags = `${parts[1]}`
    end if
    return info
end function

sub sabr_seedMetadataFromSidx(playbackContext as object, contentType as string, formatKey as string, sidxEntry as object)
    if not IsAssociativeArray(playbackContext) then return
    if not IsAssociativeArray(sidxEntry) then return

    entries = sidxEntry?.entries
    if not IsArray(entries) or entries.count() = 0 then return

    byRange = sabr_getSegmentMetadataByRangeKey(playbackContext, contentType, formatKey, true)
    if not IsAssociativeArray(byRange) then return

    formatInfo = sabr_parseFormatKey(formatKey)

    for each entry in entries
        startVal = sabr_toInt(entry?.rangeStart)
        if startVal = invalid then startVal = sabr_toInt(entry?.rangeStartLabel)
        endVal = sabr_toInt(entry?.rangeEnd)
        if endVal = invalid then endVal = sabr_toInt(entry?.rangeEndLabel)
        if startVal = invalid or endVal = invalid then continue for

        startTimeMs = sabr_toInt(entry?.startTimeMs)
        durationMs = sabr_toInt(entry?.durationMs)

        meta = {
            "formatId": {}
            "rangeStart": startVal
            "rangeEnd": endVal
            "startTimeMs": `${startTimeMs <> invalid ? startTimeMs : 0}`
            "durationMs": `${durationMs <> invalid ? durationMs : 0}`
            "timeRange": {
                "timescale": 1000
                "startTicks": startTimeMs <> invalid ? startTimeMs : 0
                "durationTicks": durationMs <> invalid ? durationMs : 0
            }
        }

        if isValid(formatInfo.itag)
            meta.formatId["itag"] = formatInfo.itag
        end if
        if formatInfo.xtags <> ""
            meta.formatId["xtags"] = formatInfo.xtags
        end if

        byRange[`${startVal}`] = meta
    end for

end sub

function sabr_lookupPlayerTimeMsFromSidx(playbackContext as object, contentType as string, currentFormat as object, requestByteRange as object) as object
    result = {
        "value": invalid
        "source": "sidx"
    }
    if not IsAssociativeArray(playbackContext) then return result

    indexMap = sabr_globalSidxIndexMap()
    if not IsAssociativeArray(indexMap)
        indexMap = {}
    end if

    key = sabr_buildPlayerTimeIndexKey(contentType, currentFormat)
    if key = "" then return result

    entrySource = "global"
    indexEntry = invalid
    if IsAssociativeArray(indexMap) and indexMap.DoesExist(key)
        indexEntry = indexMap.Lookup(key)
    end if

    if not IsAssociativeArray(indexEntry)
        playbackMap = playbackContext?.sidxIndexByFormat
        if IsAssociativeArray(playbackMap) and playbackMap.DoesExist(key)
            indexEntry = playbackMap.Lookup(key)
            entrySource = "context"
        end if
    end if

    if not IsAssociativeArray(indexEntry) then return result

    if indexEntry.DoesExist("unsupportedReason")
        reasonLabel = `${indexEntry.Lookup("unsupportedReason") ?? ""}`
        if reasonLabel <> ""
            result["source"] = `sidx:unsupported:${reasonLabel}`
            if isValid(m?.logs)
                m.logs.printl(log_level_Type.DEBUG, `[YTSABR-PlayerTime] SIDX unsupported for ${key} source=${entrySource} reason=${reasonLabel}`)
            end if
            return result
        end if
    end if

    entries = indexEntry?.entries
    if not IsArray(entries) or entries.count() = 0 then return result

    targetStart = sabr_requestedByteStart(requestByteRange)
    if targetStart = invalid then return result
    targetValue = targetStart

    if isValid(m?.logs)
        firstEntry = entries[0]
        m.logs.printl(log_level_Type.DEBUG, `[YTSABR-PlayerTime] SIDX lookup ${key} source=${entrySource} target=${targetValue} entries=${entries.count()} firstStart=${firstEntry?.rangeStart} duration=${firstEntry?.durationMs}`)
    end if

    matchEntry = invalid
    lowerEntry = invalid

    for each entry in entries
        startVal = sabr_toInt(entry?.rangeStart)
        if startVal = invalid and entry.DoesExist("rangeStartLabel")
            labelStart = `${entry.rangeStartLabel ?? ""}`
            if labelStart <> ""
                startVal = sabr_toInt(labelStart)
                if startVal = invalid
                    startVal = Val(labelStart)
                end if
            end if
        end if
        endVal = sabr_toInt(entry?.rangeEnd)
        if endVal = invalid and entry.DoesExist("rangeEndLabel")
            labelEnd = `${entry.rangeEndLabel ?? ""}`
            if labelEnd <> ""
                endVal = sabr_toInt(labelEnd)
                if endVal = invalid
                    endVal = Val(labelEnd)
                end if
            end if
        end if
        if startVal = invalid then continue for
        if targetValue = startVal
            matchEntry = entry
            exit for
        end if
        if endVal <> invalid and targetValue >= startVal and targetValue <= endVal
            matchEntry = entry
            exit for
        end if
        if targetValue > startVal
            if not IsAssociativeArray(lowerEntry)
                lowerEntry = entry
            else
                lowerStart = lowerEntry?.rangeStart
                if lowerStart = invalid
                    lowerStart = sabr_toInt(lowerEntry?.rangeStart)
                end if
                if lowerStart = invalid and lowerEntry.DoesExist("rangeStartLabel")
                    lowerLabel = `${lowerEntry.rangeStartLabel ?? ""}`
                    if lowerLabel <> ""
                        lowerStart = Val(lowerLabel)
                    end if
                end if
                if lowerStart = invalid or startVal > lowerStart
                    lowerEntry = entry
                end if
            end if
        end if
    end for

    candidateEntry = matchEntry
    label = "sidx"
    if not IsAssociativeArray(candidateEntry)
        candidateEntry = lowerEntry
        if IsAssociativeArray(candidateEntry)
            label = "sidx:nearest"
        end if
    else
        label = "sidx:exact"
    end if

    if not IsAssociativeArray(candidateEntry)
        if isValid(m?.logs)
            m.logs.printl(log_level_Type.DEBUG, `[YTSABR-PlayerTime] SIDX lookup miss for ${key} target=${targetValue}`)
        end if
        return result
    end if

    predicted = sabr_predictPlayerTimeFromSidxEntry(candidateEntry, targetStart)
    if predicted = invalid then return result

    if isValid(m?.logs)
        logMsg = `[YTSABR-PlayerTime] SIDX match ${label} start=${candidateEntry?.rangeStart ?? candidateEntry?.rangeStartLabel} `
        logMsg = `${logMsg}end=${candidateEntry?.rangeEnd ?? candidateEntry?.rangeEndLabel} startMs=${candidateEntry?.startTimeMs ?? "?"} durationMs=${candidateEntry?.durationMs ?? "?"} predicted=${predicted}`
        m.logs.printl(log_level_Type.DEBUG, logMsg)
    end if

    result["value"] = predicted
    result["source"] = label
    return result
end function

function sabr_predictPlayerTimeFromSidxEntry(entry as object, targetStart as dynamic) as dynamic
    if not IsAssociativeArray(entry) then return invalid
    startMs = sabr_toInt(entry?.startTimeMs)
    if startMs = invalid then return invalid

    durationMs = sabr_toInt(entry?.durationMs)
    rangeStart = sabr_toInt(entry?.rangeStart)
    if rangeStart = invalid and entry.DoesExist("rangeStartLabel")
        labelStart = `${entry.rangeStartLabel ?? ""}`
        if labelStart <> ""
            rangeStart = sabr_toInt(labelStart)
            if rangeStart = invalid
                rangeStart = Val(labelStart)
            end if
        end if
    end if
    rangeEnd = sabr_toInt(entry?.rangeEnd)
    if rangeEnd = invalid and entry.DoesExist("rangeEndLabel")
        labelEnd = `${entry.rangeEndLabel ?? ""}`
        if labelEnd <> ""
            rangeEnd = sabr_toInt(labelEnd)
            if rangeEnd = invalid
                rangeEnd = Val(labelEnd)
            end if
        end if
    end if
    if durationMs = invalid or rangeStart = invalid or rangeEnd = invalid then return startMs

    span = rangeEnd - rangeStart + 1
    if span <= 0 then return startMs

    targetValue = targetStart * 1.0
    offset = targetStart - rangeStart
    if offset <= 0 then return startMs

    return startMs + int((offset * durationMs) / span)
end function

function sabr_lookupPlayerTimeMsFromMetadata(playbackContext as object, contentType as string, currentFormat as object, requestByteRange as object) as object
    result = {
        "value": invalid
        "source": "metadata"
    }
    if not IsAssociativeArray(playbackContext) then return result

    targetStart = sabr_requestedByteStart(requestByteRange)
    if targetStart = invalid then return result

    metadataByRange = sabr_getSegmentMetadataByRange(playbackContext, contentType, currentFormat, false)
    if not IsAssociativeArray(metadataByRange) or metadataByRange.Count() = 0
        key = sabr_buildPlayerTimeIndexKey(contentType, currentFormat)
        indexMap = sabr_globalSidxIndexMap()
        if key <> "" and IsAssociativeArray(indexMap) and indexMap.DoesExist(key)
            sabr_seedMetadataFromSidx(playbackContext, contentType, sabr_formatToKey(currentFormat), indexMap.Lookup(key))
            metadataByRange = sabr_getSegmentMetadataByRange(playbackContext, contentType, currentFormat, false)
        end if
    end if
    if not IsAssociativeArray(metadataByRange) or metadataByRange.Count() = 0 then return result

    if isValid(m?.logs)
        m.logs.printl(log_level_Type.DEBUG, `[YTSABR-PlayerTime] Metadata lookup ${sabr_buildPlayerTimeIndexKey(contentType, currentFormat)} entries=${metadataByRange.Count()}`)
    end if

    exactKey = `${targetStart}`
    meta = invalid
    if metadataByRange.DoesExist(exactKey)
        meta = metadataByRange.Lookup(exactKey)
    else
        smallerKey = invalid
        for each key in metadataByRange
            startVal = sabr_toInt(key)
            if startVal = invalid then startVal = sabr_toInt(metadataByRange.Lookup(key)?.rangeStart)
            if startVal <> invalid and startVal <= targetStart
                if smallerKey = invalid or startVal > sabr_toInt(smallerKey)
                    smallerKey = key
                end if
            end if
        end for
        if isValid(smallerKey)
            meta = metadataByRange.Lookup(smallerKey)
        end if
    end if

    if IsAssociativeArray(meta)
        predicted = sabr_predictPlayerTimeFromMetadata(meta, targetStart)
        if predicted <> invalid
            if isValid(m?.logs)
                m.logs.printl(log_level_Type.DEBUG, `[YTSABR-PlayerTime] Metadata exact start=${meta?.rangeStart ?? meta?.startRange} end=${meta?.rangeEnd ?? meta?.endRange} startMs=${meta?.startTimeMs ?? "?"} durationMs=${meta?.durationMs ?? "?"} predicted=${predicted}`)
            end if
            result["value"] = predicted
            result["source"] = "metadata:exact"
            return result
        end if
    end if

    bestCandidate = invalid
    bestLabel = "metadata:nearest"
    bestStart = -2147483647

    for each key in metadataByRange
        meta = metadataByRange.Lookup(key)
        startVal = sabr_toInt(meta?.rangeStart)
        if startVal = invalid then startVal = sabr_toInt(meta?.startRange)
        endVal = sabr_toInt(meta?.rangeEnd)
        if endVal = invalid then endVal = sabr_toInt(meta?.endRange)
        if startVal = invalid then continue for

        if endVal <> invalid and targetStart >= startVal and targetStart <= endVal
            predicted = sabr_predictPlayerTimeFromMetadata(meta, targetStart)
            if predicted <> invalid
                if isValid(m?.logs)
                    m.logs.printl(log_level_Type.DEBUG, `[YTSABR-PlayerTime] Metadata within start=${startVal} end=${endVal} startMs=${meta?.startTimeMs ?? "?"} durationMs=${meta?.durationMs ?? "?"} predicted=${predicted}`)
                end if
                result["value"] = predicted
                result["source"] = "metadata:within"
                return result
            end if
        end if

        if targetStart >= startVal and startVal > bestStart
            bestStart = startVal
            bestCandidate = meta
        end if
    end for

    if not IsAssociativeArray(bestCandidate) then return result

    predicted = sabr_predictPlayerTimeFromMetadata(bestCandidate, targetStart)
    if predicted = invalid then return result

    if isValid(m?.logs)
        m.logs.printl(log_level_Type.DEBUG, `[YTSABR-PlayerTime] Metadata nearest start=${bestCandidate?.rangeStart ?? bestCandidate?.startRange} end=${bestCandidate?.rangeEnd ?? bestCandidate?.endRange} startMs=${bestCandidate?.startTimeMs ?? "?"} durationMs=${bestCandidate?.durationMs ?? "?"} predicted=${predicted}`)
    end if

    result["value"] = predicted
    result["source"] = bestLabel
    return result
end function

function sabr_predictPlayerTimeFromMetadata(metadata as object, targetStart as integer) as dynamic
    if not IsAssociativeArray(metadata) then return invalid

    startMs = sabr_segmentStartMs(metadata)
    if startMs = invalid then startMs = sabr_toInt(metadata?.startTimeMs)
    if startMs = invalid then return invalid

    durationMs = sabr_segmentDurationMs(metadata)
    rangeStart = sabr_toInt(metadata?.rangeStart)
    if rangeStart = invalid then rangeStart = sabr_toInt(metadata?.startRange)
    rangeEnd = sabr_toInt(metadata?.rangeEnd)
    if rangeEnd = invalid then rangeEnd = sabr_toInt(metadata?.endRange)

    if durationMs = invalid or rangeStart = invalid or rangeEnd = invalid then return startMs

    span = rangeEnd - rangeStart + 1
    if span <= 0 then return startMs

    offset = targetStart - rangeStart
    if offset <= 0 then return startMs

    return startMs + int((offset * durationMs) / span)
end function

sub sabr_storeSidxIndexUpdate(playbackContext as object, contentType as string, update as object)
    if not IsAssociativeArray(playbackContext) then return
    if not IsAssociativeArray(update) then return

    formatKey = `${update?.formatKey ?? ""}`
    if formatKey = "" and update.DoesExist("format_id")
        inferred = update.Lookup("format_id")
        if IsAssociativeArray(inferred)
            itagLabel = sabr_valueToLabel(inferred.Lookup("itag"))
            xtagLabel = sabr_valueToLabel(inferred.Lookup("xtags"))
            formatKey = `${itagLabel}:${xtagLabel}`
        end if
    end if
    if formatKey = "" then return

    typeLabel = `${update?.contentType ?? contentType ?? ""}`
    if typeLabel = "" then typeLabel = contentType
    indexKey = `${typeLabel ?? ""}`
    if indexKey = "" then indexKey = "UNKNOWN"
    indexKey = `${indexKey}|${formatKey}`

    sanitized = {
        "formatKey": formatKey
        "entries": []
        "timescale": sabr_toInt(update?.timescale)
        "earliestPresentationTime": update?.earliestPresentationTime
        "contentType": typeLabel
    }

    if update.DoesExist("unsupportedReason")
        sanitized["unsupportedReason"] = `${update.Lookup("unsupportedReason")}`
    end if

    entryList = update?.entries
    if IsArray(entryList)
        cleaned = []
        for each entry in entryList
            if not IsAssociativeArray(entry) then continue for
            startNumeric = sabr_toInt(entry?.rangeStart)
            if startNumeric = invalid and isValid(entry?.rangeStart)
                labelStart = `${entry.rangeStart}`
                if labelStart <> ""
                    startNumeric = Val(labelStart)
                end if
            end if
            endNumeric = sabr_toInt(entry?.rangeEnd)
            if endNumeric = invalid and isValid(entry?.rangeEnd)
                labelEndVal = `${entry.rangeEnd}`
                if labelEndVal <> ""
                    endNumeric = Val(labelEndVal)
                end if
            end if
            cleanedEntry = {
                "rangeStart": startNumeric
                "rangeEnd": endNumeric
                "startTimeMs": sabr_toInt(entry?.startTimeMs)
                "durationMs": sabr_toInt(entry?.durationMs)
                "referenceType": sabr_toInt(entry?.referenceType)
            }
            if isValid(entry?.rangeStart)
                cleanedEntry["rangeStartLabel"] = `${entry.rangeStart}`
            end if
            if isValid(entry?.rangeEnd)
                cleanedEntry["rangeEndLabel"] = `${entry.rangeEnd}`
            end if
            cleaned.push(cleanedEntry)
        end for
        sanitized["entries"] = cleaned
    end if

    map = playbackContext?.sidxIndexByFormat
    if not IsAssociativeArray(map)
        map = {}
    end if
    map[indexKey] = sanitized
    playbackContext["sidxIndexByFormat"] = map

    globalMap = sabr_globalSidxIndexMap()
    globalMap[indexKey] = sanitized
    m.sidxIndexCache = globalMap

    sabr_seedMetadataFromSidx(playbackContext, typeLabel, formatKey, sanitized)

    if isValid(m?.logs)
        entryCount = IsArray(sanitized.entries) ? sanitized.entries.count() : 0
        reason = sanitized?.unsupportedReason
        if isValid(reason) and reason <> ""
            m.logs.printl(log_level_Type.DEBUG, `[YTSABR-PlayerTime] Stored SIDX index for ${indexKey} entries=${entryCount} unsupported=${reason}`)
        else
            m.logs.printl(log_level_Type.DEBUG, `[YTSABR-PlayerTime] Stored SIDX index for ${indexKey} entries=${entryCount}`)
            if entryCount > 0
                preview = sanitized.entries[0]
                m.logs.printl(log_level_Type.DEBUG, `[YTSABR-PlayerTime] SIDX preview start=${preview?.rangeStart} duration=${preview?.durationMs} bytes=${preview?.rangeStart}-${preview?.rangeEnd}`)
            end if
        end if
    end if
end sub

function sabr_sortCacheEntriesBySegment(entries as object) as object
    if not IsArray(entries) then return entries
    sorted = []
    for each item in entries
        sorted.push(item)
    end for
    total = sorted.count()
    if total <= 1 then return sorted

    for i = 0 to total - 2
        for j = i + 1 to total - 1
            left = sorted[i]
            right = sorted[j]
            leftIndex = sabr_toInt(left?.startSegmentIndex)
            if leftIndex = invalid then leftIndex = sabr_toInt(left?.sequenceNumber)
            if leftIndex = invalid then leftIndex = sabr_toInt(left?.rangeStart)
            rightIndex = sabr_toInt(right?.startSegmentIndex)
            if rightIndex = invalid then rightIndex = sabr_toInt(right?.sequenceNumber)
            if rightIndex = invalid then rightIndex = sabr_toInt(right?.rangeStart)
            if leftIndex = invalid then leftIndex = 2147483647
            if rightIndex = invalid then rightIndex = 2147483647
            if rightIndex < leftIndex
                temp = sorted[i]
                sorted[i] = sorted[j]
                sorted[j] = temp
            end if
        end for
    end for
    return sorted
end function

function sabr_entryItagValue(entry as object) as dynamic
    if not IsAssociativeArray(entry) then return invalid
    raw = entry?.itag
    if not isValid(raw) then return invalid
    if IsInteger(raw) then return raw
    if IsFloat(raw) or IsDouble(raw) then return int(raw)
    if IsString(raw)
        trimmed = raw.trim()
        if trimmed = "" then return invalid
        parsed = sabr_toInt(trimmed)
        if parsed <> invalid then return parsed
        return trimmed
    end if
    return raw
end function

function sabr_copyFormatId(source as object) as object
    if not IsAssociativeArray(source) then return invalid
    copy = {}
    for each key in source
        copy[key] = source[key]
    end for
    return copy
end function

function sabr_resolveFormatIdForCacheEntry(entry as object, fallback as dynamic, activeFormat as object) as object
    formatId = invalid
    if IsAssociativeArray(fallback)
        fallbackId = fallback?.formatId
        if IsAssociativeArray(fallbackId)
            formatId = sabr_copyFormatId(fallbackId)
        end if
    end if

    entryItag = sabr_entryItagValue(entry)
    if entryItag <> invalid
        if not IsAssociativeArray(formatId)
            formatId = {}
        end if
        formatId["itag"] = entryItag
    end if

    if IsAssociativeArray(formatId)
        existingXtags = invalid
        if formatId.DoesExist("xtags")
            existingXtags = formatId.Lookup("xtags")
        end if
        xtagsMissing = true
        if isValid(existingXtags)
            xtagsMissing = sabr_valueToLabel(existingXtags) = ""
        end if
        if xtagsMissing
            candidate = invalid
            if IsAssociativeArray(fallback?.formatId) and fallback.formatId.DoesExist("xtags")
                candidate = fallback.formatId.Lookup("xtags")
            else if isValid(activeFormat?.xtags)
                candidate = activeFormat.xtags
            end if
            if isValid(candidate) then formatId["xtags"] = candidate
        end if
        existingLastModified = invalid
        if formatId.DoesExist("lastModified")
            existingLastModified = formatId.Lookup("lastModified")
        end if
        lastModifiedMissing = true
        if isValid(existingLastModified)
            lastModifiedMissing = sabr_valueToLabel(existingLastModified) = ""
        end if
        if lastModifiedMissing
            candidate = invalid
            if IsAssociativeArray(fallback?.formatId) and fallback.formatId.DoesExist("lastModified")
                candidate = fallback.formatId.Lookup("lastModified")
            else if isValid(activeFormat?.lastModified)
                candidate = activeFormat.lastModified
            end if
            if isValid(candidate) then formatId["lastModified"] = candidate
        end if
    else
        formatId = sabr_formatToFormatId(activeFormat)
    end if

    if not IsAssociativeArray(formatId)
        formatId = sabr_formatToFormatId(activeFormat)
    end if

    return formatId
end function

function sabr_buildMetadataFromCacheEntry(entry as object, activeFormat as object, formatType as string) as dynamic
    if not IsAssociativeArray(entry) then return invalid

    metadata = {}
    metadata["formatId"] = sabr_resolveFormatIdForCacheEntry(entry, entry, activeFormat)

    rangeStartVal = sabr_toInt(entry?.rangeStart)
    rangeEndVal = sabr_toInt(entry?.rangeEnd)

    startIndex = sabr_toInt(entry?.startSegmentIndex)
    if startIndex = invalid then startIndex = sabr_toInt(entry?.sequenceNumber)
    if startIndex = invalid and rangeStartVal <> invalid then startIndex = rangeStartVal
    if startIndex = invalid then return invalid

    endIndex = sabr_toInt(entry?.endSegmentIndex)
    if endIndex = invalid then endIndex = sabr_toInt(entry?.sequenceNumber)
    if endIndex = invalid then endIndex = startIndex

    startTimeVal = sabr_toInt(entry?.startTimeMs)
    if startTimeVal = invalid then startTimeVal = sabr_toInt(entry?.startMs)
    startTicksVal = sabr_toInt(entry?.startTicks)
    durationMsVal = sabr_toInt(entry?.durationMs)
    durationTicksVal = sabr_toInt(entry?.durationTicks)

    timescaleVal = sabr_toInt(entry?.timescale)
    if timescaleVal = invalid or timescaleVal <= 0
        timescaleVal = sabr_toInt(entry?.timeRange?.timescale)
    end if
    if timescaleVal = invalid or timescaleVal <= 0
        if formatType = "AUDIO"
            timescaleVal = 48000
        else
            timescaleVal = 1000
        end if
    end if

    if startTimeVal = invalid and startTicksVal <> invalid and timescaleVal > 0
        startTimeVal = int((startTicksVal * 1000) / timescaleVal)
    end if
    if startTicksVal = invalid and startTimeVal <> invalid and timescaleVal > 0
        startTicksVal = int((startTimeVal * timescaleVal) / 1000)
    end if

    if durationMsVal = invalid and durationTicksVal <> invalid and timescaleVal > 0
        durationMsVal = int((durationTicksVal * 1000) / timescaleVal)
    end if
    if durationTicksVal = invalid and durationMsVal <> invalid and timescaleVal > 0
        durationTicksVal = int((durationMsVal * timescaleVal) / 1000)
    end if

    if startTimeVal = invalid then startTimeVal = 0
    if startTimeVal < 0 then startTimeVal = 0
    if durationMsVal = invalid then durationMsVal = 0
    if durationMsVal < 0 then durationMsVal = 0
    if startTicksVal = invalid then startTicksVal = int((startTimeVal * timescaleVal) / 1000)
    if durationTicksVal = invalid then durationTicksVal = int((durationMsVal * timescaleVal) / 1000)
    if startTicksVal = invalid then startTicksVal = 0
    if startTicksVal < 0 then startTicksVal = 0
    if durationTicksVal = invalid then durationTicksVal = 0
    if durationTicksVal < 0 then durationTicksVal = 0

    metadata["startSequenceNumber"] = startIndex
    metadata["endSequenceNumber"] = endIndex
    metadata["sequenceNumber"] = sabr_toInt(entry?.sequenceNumber)
    if metadata["sequenceNumber"] = invalid then metadata["sequenceNumber"] = startIndex

    metadata["startTimeMs"] = startTimeVal.toStr()
    metadata["startMs"] = metadata["startTimeMs"]
    metadata["durationMs"] = durationMsVal.toStr()
    metadata["timescale"] = timescaleVal
    metadata["timeRange"] = {
        "timescale": timescaleVal
        "startTicks": startTicksVal
        "durationTicks": durationTicksVal
    }

    if rangeStartVal <> invalid then metadata["rangeStart"] = rangeStartVal
    if rangeEndVal <> invalid then metadata["rangeEnd"] = rangeEndVal

    return metadata
end function

function sabr_isInit(contentType as string, format as object, requestByteRange as object, requestRef = invalid as dynamic) as boolean
    logTag = sabr_utilLogTag(contentType, requestRef)
    if sabr_rangesMatch(format?.initRange, requestByteRange)
        m.logs.printl(log_level_Type.INFO, `${logTag} SABR format itag ${format.itag} init range requested: ${FormatJson(requestByteRange)}`)
        return true
    end if

    if sabr_rangesMatch(format?.indexRange, requestByteRange)
        m.logs.printl(log_level_Type.INFO, `${logTag} SABR format itag ${format.itag} index range requested: ${FormatJson(requestByteRange)}`)
        return true
    end if
    return false
end function

' Returns mediaIdHash (string) or invalid if not found
function sabr_extractMediaIdHash(url as string) as dynamic
    ' /sabr/<anything-not-a-slash>(optional slash)
    re = CreateObject("roRegex", "/sabr/([^/]+)/?", "i")
    m = re.Match(url)
    if m.Count() >= 2 then return m[1]
    return invalid
end function

function sabr_zeroPadDigits(value as integer, width as integer) as string
    if IsString(value)
        strValue = value
    else if IsInteger(value)
        strValue = value.toStr()
    else if IsNumber(value)
        strValue = Str(value).trim()
    else
        strValue = Str(value).trim()
    end if

    if width <= 0 then return strValue
    while Len(strValue) < width
        strValue = "0" + strValue
    end while
    return strValue
end function

sub sabr_ensureInfrastructure()
    sabr_cacheSetLogger(m.logs)
    sabr_cacheEnsureBasePath()
    sabr_cacheRunMaintenance("")
    if not isValid(m.sabrRequestMetadataManager)
        m.sabrRequestMetadataManager = sabr_createRequestMetadataManager()
    end if
end sub

function sabr_buildCacheKey(mediaIdHash as string, contentType as string, format as object, byteRange as object, isInitSegment as boolean) as string
    keyParts = []

    mediaIdLabel = sabr_valueToLabel(mediaIdHash)
    if mediaIdLabel <> "" then keyParts.push(mediaIdLabel)

    contentTypeLabel = sabr_valueToLabel(contentType)
    if contentTypeLabel <> "" then keyParts.push(contentTypeLabel)

    itagLabel = sabr_valueToLabel(format?.itag)
    if itagLabel = "" then itagLabel = sabr_valueToLabel(format?.formatId?.itag)
    if itagLabel <> "" then keyParts.push(itagLabel)

    xtagsLabel = sabr_valueToLabel(format?.xtags)
    if xtagsLabel = "" and isValid(format?.formatId)
        xtagsLabel = sabr_valueToLabel(format.formatId?.xtags)
    end if
    if xtagsLabel <> "" then keyParts.push(xtagsLabel)

    trackLabel = sabr_valueToLabel(format?.audioTrackId)
    if trackLabel <> "" then keyParts.push(trackLabel)

    if isInitSegment
        keyParts.push("init")
    else
        startRange = sabr_valueToLabel(byteRange?.startRange)
        if startRange = "" then startRange = sabr_valueToLabel(byteRange?.start)
        if startRange = "" then startRange = "0"
        endRange = sabr_valueToLabel(byteRange?.endRange)
        if endRange = "" then endRange = sabr_valueToLabel(byteRange?.end)
        if startRange <> "" and endRange <> ""
            keyParts.push(`${startRange}-${endRange}`)
        else if startRange <> ""
            keyParts.push(`${startRange}`)
        else
            keyParts.push("segment")
        end if
    end if

    return sabr_joinWithPipe(keyParts)
end function

function sabr_buildPrefetchInfo(streamInfo as object, currentFormat as object, requestMetadataEntry as object) as object
    if not isValid(streamInfo) then return invalid
    mediaHeader = streamInfo.mediaHeader
    if not isValid(mediaHeader) then return invalid

    startTimeMs = sabr_safeToInt(mediaHeader.startTimeMs)
    durationMs = sabr_safeToInt(mediaHeader.durationMs)
    endTimeMs = startTimeMs + durationMs

    return {
        "formatKey": sabr_formatToKey(currentFormat)
        "endTimeMs": endTimeMs
        "durationMs": durationMs
        "cacheKey": requestMetadataEntry?.cacheKey
        "byteRange": requestMetadataEntry?.byteRange
        "updatedAt": sabr_currentTimestampMs()
        "requestNumber": requestMetadataEntry?.requestNumber
    }
end function

sub sabr_maybeSchedulePrefetch(playbackContext as object, videoNode as object, prefetchInfo as object, contentType as string)
    if not isValid(playbackContext) then return
    if not isValid(prefetchInfo) then return
    if not isValid(videoNode) then return

    currentPositionMs = int((videoNode.position ?? 0) * 1000)
    remainingMs = prefetchInfo.endTimeMs - currentPositionMs

    playbackContext["prefetchState"] = prefetchInfo

    if remainingMs <= 5000 and remainingMs > -500
        if prefetchInfo.prefetchLogged <> true
            prefetchInfo.prefetchLogged = true
            prefetchInfo.loggedAt = sabr_currentTimestampMs()
            playbackContext["prefetchState"] = prefetchInfo
            logTag = sabr_utilLogTag(contentType, prefetchInfo?.requestNumber)
            m.logs.printl(log_level_Type.INFO, `${logTag} Prefetch window reached for cache key ${prefetchInfo.cacheKey}; remainingMs=${remainingMs}`)
        end if
    end if
end sub

function sabr_safeToInt(value as dynamic) as integer
    if not isValid(value) then return 0
    if IsInteger(value)
        return value
    else if IsFloat(value) or IsDouble(value)
        return int(value)
    else if IsString(value)
        return sabr_toInt(value)
    else
        return 0
    end if
end function

function sabr_joinWithPipe(parts as object) as string
    if not isValid(parts) then return ""
    total = parts.count()
    if total = 0 then return ""
    result = ""
    for i = 0 to total - 1
        piece = parts[i] ?? ""
        if result <> "" then result = `${result}|`
        result = `${result}${piece}`
    end for
    return result
end function

function sabr_currentTimestampMs() as integer
    dt = CreateObject("roDateTime")
    if not IsDateTime(dt) then return 0
    return (dt.AsSeconds() * 1000) + dt.GetMilliseconds()
end function

function sabr_valueToLabel(value as dynamic) as string
    if not isValid(value) then return ""
    if IsString(value)
        trimmed = value.trim()
        if trimmed = "" then return ""
        if Instr(1, trimmed, "e") > 0 or Instr(1, trimmed, "E") > 0
            numeric = trimmed.toFloat()
            if numeric <> invalid
                return sabr_valueToLabel(numeric)
            end if
        end if
        return trimmed
    end if
    if IsInteger(value)
        return value.toStr()
    end if
    if IsFloat(value) or IsDouble(value)
        precise = FormatJson(value)
        if precise <> "" and Instr(1, precise, "e") = 0 and Instr(1, precise, "E") = 0
            return precise
        end if
        intVal = int(value)
        if Abs(value - intVal) < 0.000001
            return intVal.toStr()
        end if
        strVal = Str(value).trim()
        if Instr(1, strVal, "e") > 0 or Instr(1, strVal, "E") > 0
            return FormatJson(int(value))
        end if
        return strVal
    end if
    return Str(value).trim()
end function

function sabr_formatRequestedRangeForPath(byteRange as object) as string
    if not isValid(byteRange) then return "none"
    startLabel = sabr_valueToLabel(byteRange?.startRange)
    if startLabel = "" then startLabel = sabr_valueToLabel(byteRange?.start)
    endLabel = sabr_valueToLabel(byteRange?.endRange)
    if endLabel = "" then endLabel = sabr_valueToLabel(byteRange?.end)
    if startLabel <> "" and endLabel <> ""
        return `${startLabel}-${endLabel}`
    else if startLabel <> ""
        return `${startLabel}-`
    else if endLabel <> ""
        return `-${endLabel}`
    end if
    return "none"
end function

function sabr_nextDumpSequence() as integer
    if not isValid(m.sabrDumpSequence)
        m.sabrDumpSequence = 0
    end if
    m.sabrDumpSequence = m.sabrDumpSequence + 1
    return m.sabrDumpSequence
end function

function sabr_buildSegmentCacheKeyForRange(format as object, byteRange as object) as string
    if not isValid(format) then return ""
    startLabel = sabr_valueToLabel(byteRange?.startRange)
    if startLabel = "" then startLabel = sabr_valueToLabel(byteRange?.start)
    if startLabel = "" then startLabel = "0"
    endLabel = sabr_valueToLabel(byteRange?.endRange)
    if endLabel = "" then endLabel = sabr_valueToLabel(byteRange?.end)
    if endLabel = "" then endLabel = "0"
    if startLabel = "" and endLabel = "" then return ""
    rangeLabel = startLabel
    if startLabel <> "" and endLabel <> ""
        rangeLabel = `${startLabel}-${endLabel}`
    end if

    itagPart = `${format?.itag ?? ""}`
    xtagsPart = `${format?.xtags ?? ""}`

    return `${rangeLabel}-${itagPart}-${xtagsPart}`
end function

sub sabr_logCoverageDiagnostics(info as object)
    if not isValid(info) then return
    logTag = info?.logTag ?? "[coverage]"
    cacheKey = info?.cacheKey ?? ""
    requested = info?.requested
    coverage = info?.coverage
    requestedLabel = sabr_formatRequestedRangeForPath(requested)
    coverageLabel = ""
    if isValid(coverage)
        coverageLabel = `${coverage?.rangeStart ?? "?"}-${coverage?.rangeEnd ?? "?"}`
    end if
    m.logs.printl(log_level_Type.DEBUG, `${logTag} Coverage diagnostics key=${cacheKey} requested=${requestedLabel} coverage=${coverageLabel} sequence=${coverage?.sequenceNumber ?? requested?.sequenceNumber ?? "?"}`)
end sub

function sabr_buildRepeatRequestKey(contentType as string, format as object, byteRange as object) as string
    if not isValid(byteRange) then return ""
    segmentKey = sabr_buildSegmentCacheKeyForRange(format, byteRange)
    if segmentKey = "" then return ""
    typeLabel = contentType ?? ""
    if typeLabel = "" then typeLabel = "UNKNOWN"
    return `${typeLabel}|${segmentKey}`
end function

sub sabr_debugLogRepeatState(contentType as string, requestNumber as dynamic, playbackContext as object, label as string, extra = invalid as dynamic)
    if not isValid(m?.logs) then return
    logTag = sabr_utilLogTag(contentType, `${requestNumber}`)
    state = playbackContext?.repeatRequestState

    extraParts = []
    if isValid(extra)
        if IsString(extra)
            extraParts.push(extra)
        else if IsAssociativeArray(extra)
            for each key in extra
                extraParts.push(`${key}=${extra[key]}`)
            end for
        end if
    end if

    if not IsAssociativeArray(state)
        message = `${logTag} RepeatState ${label}: none`
        if extraParts.count() > 0 then message = `${message} ${extraParts.Join(" ")}`
        m.logs.printl(log_level_Type.DEBUG, message)
        return
    end if

    pieces = [
        `key=${state?.lastKey ?? ""}`
        `count=${state?.count ?? ""}`
        `success=${state?.successStreak ?? ""}`
        `failure=${state?.failureStreak ?? ""}`
        `lastStatus=${state?.lastStatus ?? ""}`
        `lastResult=${state?.lastResult ?? ""}`
    ]
    if state?.updatedAt <> invalid
        pieces.push(`updatedAt=${state.updatedAt}`)
    end if
    if extraParts.count() > 0
        for each part in extraParts
            pieces.push(part)
        end for
    end if
    m.logs.printl(log_level_Type.DEBUG, `${logTag} RepeatState ${label}: ${pieces.Join(" ")}`)
end sub

function sabr_streamInfoKey(contentType as string, format as object) as string
    keyPart = sabr_formatToKey(format)
    if keyPart = ""
        keyPart = "unknown"
    end if
    typePart = contentType ?? ""
    if typePart = "" then typePart = "UNKNOWN"
    return `${typePart}|${keyPart}`
end function

sub sabr_logBufferedRanges(logTag as string, requestJson as object)
    if not isValid(m?.logs) then return
    if not IsAssociativeArray(requestJson) then return
    ranges = invalid
    if requestJson.DoesExist("clientAbrState") and IsAssociativeArray(requestJson.clientAbrState)
        ranges = requestJson.clientAbrState.Lookup("bufferedRanges")
    else if requestJson.DoesExist("bufferedRanges")
        ranges = requestJson.Lookup("bufferedRanges")
    end if

    summary = []
    if IsArray(ranges)
        for each entry in ranges
            if not IsAssociativeArray(entry) then continue for
            startLabel = sabr_valueToLabel(entry?.rangeStart)
            if startLabel = "" then startLabel = sabr_valueToLabel(entry?.startRange)
            endLabel = sabr_valueToLabel(entry?.rangeEnd)
            if endLabel = "" then endLabel = sabr_valueToLabel(entry?.endRange)
            entryType = sabr_valueToLabel(entry?.type)
            formatKey = sabr_valueToLabel(entry?.formatKey)
            summary.push(`${startLabel}-${endLabel}@${entryType}:${formatKey}`)
        end for
    end if

    selected = []
    selectedIds = requestJson?.selectedFormatIds
    if IsArray(selectedIds)
        for each id in selectedIds
            if IsAssociativeArray(id)
                itagLabel = sabr_valueToLabel(id?.itag)
                xtagLabel = sabr_valueToLabel(id?.xtags)
                selected.push(`${itagLabel}:${xtagLabel}`)
            else
                selected.push(`${id}`)
            end if
        end for
    end if

    if summary.count() = 0 and isValid(ranges)
        rawSummary = ""
        try
            rawSummary = FormatJson(ranges)
        catch e
            rawSummary = "<unserializable>"
        end try
        m.logs.printl(log_level_Type.DEBUG, `${logTag} bufferedRangesRaw=${rawSummary}`)
    end if

    m.logs.printl(log_level_Type.DEBUG, `${logTag} bufferedRanges=${summary.Join(" ")} selected=${selected.Join(",")}`)
end sub

function sabr_toInt(value as dynamic) as dynamic
    if not isValid(value) then return invalid
    if IsInteger(value) then return value
    if IsFloat(value) or IsDouble(value) then return int(value)
    if IsString(value)
        trimmed = value.trim()
        if trimmed = "" then return invalid
        return trimmed.toInt()
    end if
    return invalid
end function

function sabr_toSafeString(value as dynamic) as string
    if not isValid(value) then return ""
    if IsString(value) then return value.trim()
    if IsBoolean(value) then return value = true ? "true" : "false"
    return Str(value).trim()
end function

function sabr_storeStreamInfoForFormat(playbackContext as object, contentType as string, format as object, streamInfo as object) as void
    if not isValid(playbackContext) then return
    if not isValid(streamInfo) then return
    key = sabr_streamInfoKey(contentType, format)
    if key = "" then return

    map = playbackContext?.streamInfoByFormat
    if not IsAssociativeArray(map)
        map = createObject("roAssociativeArray")
    end if
    map[key] = streamInfo
    playbackContext["streamInfoByFormat"] = map
end function

function sabr_fetchStreamInfoForFormat(playbackContext as object, contentType as string, format as object) as dynamic
    if not isValid(playbackContext) then return invalid
    key = sabr_streamInfoKey(contentType, format)
    if key = "" then return invalid
    map = playbackContext?.streamInfoByFormat
    if not IsAssociativeArray(map) then return invalid
    info = map.Lookup(key)
    if isValid(info) then return info
    return invalid
end function

function sabr_guardRepeatedRequests(playbackContext as object, contentType as string, currentFormat as object, requestMetadataEntry as object, requestNumber as string, videoNode as object, mediaIdHash as string) as dynamic
    if not isValid(playbackContext) then return invalid
    if requestMetadataEntry?.isInit = true then return invalid

    repeatKey = sabr_buildRepeatRequestKey(contentType, currentFormat, requestMetadataEntry?.byteRange)
    if repeatKey = "" then return invalid
    requestMetadataEntry["repeatKey"] = repeatKey

    nowTs = sabr_currentTimestampMs()
    logTag = sabr_utilLogTag(contentType, requestNumber)
    repeatState = playbackContext?.repeatRequestState
    consecutiveCount = 1
    lastKey = ""
    lastCount = 0
    lastUpdated = invalid
    successStreak = 0
    failureStreak = 0

    if IsAssociativeArray(repeatState)
        lastKey = repeatState?.lastKey ?? ""
        lastCount = sabr_toInt(repeatState?.count)
        lastUpdated = sabr_toInt(repeatState?.updatedAt)
        successStreak = sabr_toInt(repeatState?.successStreak)
        failureStreak = sabr_toInt(repeatState?.failureStreak)
    end if

    if lastKey = repeatKey and lastCount <> invalid and lastCount > 0
        if lastUpdated = invalid or (nowTs - lastUpdated) <= SABR_REPEAT_SEGMENT_WINDOW_MS
            consecutiveCount = lastCount + 1
        end if
    else
        successStreak = 0
        failureStreak = 0
    end if

    rangeLabel = sabr_formatRequestedRangeForPath(requestMetadataEntry?.byteRange)
    newState = {
        "lastKey": repeatKey
        "count": consecutiveCount
        "updatedAt": nowTs
        "lastRequestNumber": requestNumber
        "range": rangeLabel
        "formatKey": sabr_formatToKey(currentFormat)
        "successStreak": successStreak
        "failureStreak": failureStreak
        "lastResult": repeatState?.lastResult ?? ""
        "lastStatus": repeatState?.lastStatus
    }
    playbackContext["repeatRequestState"] = newState

    deltaMs = -1
    if lastUpdated <> invalid then deltaMs = nowTs - lastUpdated
    extra = `key=${repeatKey} deltaMs=${deltaMs} range=${rangeLabel}`
    sabr_debugLogRepeatState(contentType, requestNumber, playbackContext, "before_guard", extra)

    if successStreak < SABR_REPEAT_SEGMENT_THRESHOLD then return invalid

    fatalMessage = `Repeated SABR requests detected for segment ${repeatKey} (range ${rangeLabel}); aborting playback`
    playbackContext["sabrFatalError"] = {
        "reason": fatalMessage
        "requestNumber": requestNumber
        "timestamp": nowTs
    }
    newState["aborted"] = true
    playbackContext["repeatRequestState"] = newState

    sabr_debugLogRepeatState(contentType, requestNumber, playbackContext, "guard_abort", extra)

    m.logs.printl(log_level_Type.WARN, `${logTag} ${fatalMessage}`)

    if isValid(videoNode)
        try
            videoNode.control = "stop"
        catch e
            m.logs.printl(log_level_Type.DEBUG, `${logTag} Failed to stop video node after repeat guard: ${e?.message}`)
        end try
    end if

    serialized = FormatJson(playbackContext)
    if isValid(serialized) and serialized <> ""
        writeFile(`tmp:/${mediaIdHash}/playbackContext.json`, serialized)
    end if

    return sabr_buildErrorResponseForPlayer(502, fatalMessage)
end function

sub sabr_recordRepeatResult(playbackContext as object, requestMetadataEntry as object, response as object, contentType = "" as string, requestNumber = invalid as dynamic)
    if not isValid(playbackContext) then return
    repeatKey = `${requestMetadataEntry?.repeatKey ?? ""}`
    if repeatKey = "" then return

    repeatState = playbackContext?.repeatRequestState
    if not IsAssociativeArray(repeatState) then return
    if `${repeatState?.lastKey ?? ""}` <> repeatKey then return

    statusVal = sabr_toInt(response?.status)
    success = false
    if statusVal <> invalid
        if statusVal = 206 or ((statusVal >= 200 and statusVal < 300) and statusVal <> 204)
            success = true
        end if
    end if

    if success
        body = response?.body
        bodyPath = sabr_toSafeString(response?.bodyPath)
        if GetInterface(body, "ifByteArray") <> invalid and body.count() = 0 and bodyPath = ""
            success = false
        end if
    end if

    successCount = sabr_toInt(repeatState?.successStreak)
    if successCount = invalid then successCount = 0
    failureCount = sabr_toInt(repeatState?.failureStreak)
    if failureCount = invalid then failureCount = 0

    if success
        repeatState["successStreak"] = successCount + 1
        repeatState["failureStreak"] = 0
    else
        repeatState["failureStreak"] = failureCount + 1
        repeatState["successStreak"] = 0
    end if

    repeatState["lastResult"] = success ? "success" : "failure"
    repeatState["lastStatus"] = statusVal
    repeatState["updatedAt"] = sabr_currentTimestampMs()

    playbackContext["repeatRequestState"] = repeatState

    if contentType <> ""
        if requestNumber = invalid then requestNumber = requestMetadataEntry?.requestNumber
        extra = `key=${repeatKey} status=${statusVal} success=${success}`
        sabr_debugLogRepeatState(contentType, requestNumber, playbackContext, "after_result", extra)
    end if
end sub

function sabr_formatTypeFromFormat(format as dynamic) as string
    mimeType = format?.mimeType ?? ""
    if mimeType.inStr("audio") > -1 then return "AUDIO"
    if mimeType.inStr("video") > -1 then return "VIDEO"
    if isValid(format?.width) then return "VIDEO"
    return "AUDIO"
end function

function sabr_mediaHeaderToSegmentMetadata(mediaHeader as dynamic, coverage = invalid as dynamic) as dynamic
    if not isValid(mediaHeader) then return invalid
    formatId = mediaHeader?.formatId
    if not isValid(formatId) then return invalid

    startSequenceNumber = sabr_toInt(mediaHeader?.sequenceNumber)
    endSequenceNumber = startSequenceNumber
    sequenceNumber = startSequenceNumber
    if sequenceNumber = invalid then sequenceNumber = sabr_toInt(coverage?.sequenceNumber)
    if sequenceNumber = invalid or sequenceNumber <= 0 then sequenceNumber = 1
    if startSequenceNumber = invalid or startSequenceNumber <= 0 then startSequenceNumber = sequenceNumber
    if endSequenceNumber = invalid or endSequenceNumber <= 0 then endSequenceNumber = sequenceNumber

    durationMs = mediaHeader?.durationMs ?? ""
    if durationMs = "" then durationMs = mediaHeader?.timeRange?.durationTicks ?? ""
    timescale = sabr_toInt(mediaHeader?.timeRange?.timescale)
    if timescale = invalid then timescale = 1000

    metadata = {
        "formatId": mediaHeader.formatId
        "startSequenceNumber": startSequenceNumber
        "endSequenceNumber": endSequenceNumber
        "sequenceNumber": sequenceNumber
        "startTimeMs": mediaHeader.startMs ?? "0"
        "durationMs": durationMs ?? "0"
        "timescale": timescale
        "timeRange": mediaHeader.timeRange
    }
    defaultStartRange = mediaHeader.startRange ?? mediaHeader.start ?? ""

    if isValid(coverage)
        if isValid(coverage?.rangeStart)
            metadata["rangeStart"] = coverage.rangeStart
        else if defaultStartRange <> ""
            metadata["rangeStart"] = defaultStartRange
        end if
        if isValid(coverage?.rangeEnd)
            metadata["rangeEnd"] = coverage.rangeEnd
        end if
        covSeq = sabr_toInt(coverage?.sequenceNumber)
        if covSeq <> invalid and covSeq > 0
            metadata["sequenceNumber"] = covSeq
            metadata["startSequenceNumber"] = covSeq
            metadata["endSequenceNumber"] = covSeq
        end if
        if isValid(coverage?.headerId)
            metadata["headerId"] = coverage.headerId
        end if
        if isValid(coverage?.cacheKey)
            metadata["cacheKey"] = coverage.cacheKey
        end if
    end if

    startRangeVal = sabr_toInt(metadata?.rangeStart)
    if startRangeVal = invalid
        if defaultStartRange <> ""
            metadata["rangeStart"] = defaultStartRange
            startRangeVal = sabr_toInt(defaultStartRange)
        end if
    end if
    if startRangeVal = invalid then startRangeVal = 0

    if not metadata.DoesExist("rangeEnd")
        contentLength = sabr_toInt(mediaHeader?.contentLength)
        if contentLength <> invalid and contentLength > 0
            metadata["rangeEnd"] = startRangeVal + contentLength - 1
        end if
    end if

    if not metadata.DoesExist("rangeStart")
        metadata["rangeStart"] = defaultStartRange
    end if
    if not metadata.DoesExist("rangeEnd")
        metadata["rangeEnd"] = startRangeVal
    end if

    startIdxVal = sabr_toInt(metadata?.startSequenceNumber)
    endIdxVal = sabr_toInt(metadata?.endSequenceNumber)
    startSeqProblem = startIdxVal = invalid or startIdxVal <= 0
    endSeqProblem = endIdxVal = invalid or endIdxVal <= 0
    if not endSeqProblem and startIdxVal <> invalid
        if endIdxVal < startIdxVal
            endSeqProblem = true
        end if
    end if
    if startSeqProblem or endSeqProblem
        headerLabel = mediaHeader?.headerId ?? ""
        m.logs.printl(log_level_Type.DEBUG, `[YTSABR-Meta] Missing segment sequence metadata; headerId=${headerLabel} headerSeq=${mediaHeader?.sequenceNumber} coverageSeq=${coverage?.sequenceNumber} startSeq=${metadata?.startSequenceNumber} endSeq=${metadata?.endSequenceNumber} startType=${Type(metadata?.startSequenceNumber)} endType=${Type(metadata?.endSequenceNumber)} computedStart=${startIdxVal} computedEnd=${endIdxVal} range=${metadata?.rangeStart}-${metadata?.rangeEnd}`)
    end if

    return metadata
end function

function sabr_segmentStartMs(metadata as dynamic) as dynamic
    if not isValid(metadata) then return invalid
    startMs = sabr_toInt(metadata?.startTimeMs)
    if startMs = invalid then startMs = sabr_toInt(metadata?.startMs)
    if startMs = invalid
        startTicks = sabr_toInt(metadata?.timeRange?.startTicks)
        timescale = sabr_toInt(metadata?.timeRange?.timescale)
        if startTicks <> invalid and timescale <> invalid and timescale <> 0
            startMs = int((startTicks * 1000) / timescale)
        end if
    end if
    return startMs
end function

function sabr_segmentDurationMs(metadata as dynamic) as dynamic
    if not isValid(metadata) then return invalid
    durationMs = sabr_toInt(metadata?.durationMs)
    if durationMs = invalid or durationMs <= 0
        durationTicks = sabr_toInt(metadata?.timeRange?.durationTicks)
        timescale = sabr_toInt(metadata?.timeRange?.timescale)
        if durationTicks <> invalid and timescale <> invalid and timescale <> 0
            durationMs = int((durationTicks * 1000) / timescale)
        end if
    end if
    return durationMs
end function

function sabr_lookupRecentMetadataBySequence(playbackContext as object, format as object, sequenceNumber as dynamic, contentType = "" as string) as dynamic
    seqVal = sabr_toInt(sequenceNumber)
    if seqVal = invalid then return invalid

    formatKey = sabr_formatToKey(format)
    initializedFormats = playbackContext?.initializedFormats
    if formatKey <> "" and IsAssociativeArray(initializedFormats) and initializedFormats.DoesExist(formatKey)
        formatState = initializedFormats.Lookup(formatKey)
        candidate = formatState?.lastSegmentMetadata
        if isValid(candidate) and sabr_toInt(candidate?.sequenceNumber) = seqVal
            return candidate
        end if
        recent = formatState?.recentSegmentMetadata
        if IsArray(recent)
            for i = recent.count() - 1 to 0
                meta = recent[i]
                if isValid(meta) and sabr_toInt(meta?.sequenceNumber) = seqVal
                    return meta
                end if
            end for
        end if
    end if

    if isValid(contentType)
        if contentType = "VIDEO"
            fallback = playbackContext?.lastVideoSegmentMetadata
        else if contentType = "AUDIO"
            fallback = playbackContext?.lastAudioSegmentMetadata
        else
            fallback = invalid
        end if
        if isValid(fallback) and sabr_toInt(fallback?.sequenceNumber) = seqVal
            return fallback
        end if
    end if

    return invalid
end function

function sabr_normalizeByteRange(rawRange as object, context = invalid as dynamic) as object
    normalized = {
        "startRange": ""
        "endRange": ""
    }

    if isValid(rawRange)
        startLabel = `${rawRange?.startRange ?? ""}`
        if startLabel = "" then startLabel = `${rawRange?.start ?? ""}`
        endLabel = `${rawRange?.endRange ?? ""}`
        if endLabel = "" then endLabel = `${rawRange?.end ?? ""}`
        if startLabel <> "" then normalized["startRange"] = startLabel
        if endLabel <> "" then normalized["endRange"] = endLabel
    end if

    if isValid(context?.segmentIndexInfo)
        normalized["segmentIndexInfo"] = context.segmentIndexInfo
    end if
    if isValid(context?.sequenceNumber)
        normalized["sequenceNumber"] = `${context.sequenceNumber}`
    end if

    return normalized
end function

function sabr_hasCompleteByteRange(byteRange as object) as boolean
    if not isValid(byteRange) then return false
    startLabel = `${byteRange?.startRange ?? ""}`
    if startLabel = "" then startLabel = `${byteRange?.start ?? ""}`
    endLabel = `${byteRange?.endRange ?? ""}`
    if endLabel = "" then endLabel = `${byteRange?.end ?? ""}`
    return startLabel <> "" and endLabel <> ""
end function

function sabr_byteRangeToCoverage(byteRange as object) as dynamic
    startVal = invalid
    endVal = invalid

    startLabel = `${byteRange?.startRange ?? ""}`
    if startLabel = "" then startLabel = `${byteRange?.start ?? ""}`
    if startLabel <> ""
        startVal = sabr_toInt(startLabel)
    end if

    endLabel = `${byteRange?.endRange ?? ""}`
    if endLabel = "" then endLabel = `${byteRange?.end ?? ""}`
    if endLabel <> ""
        endVal = sabr_toInt(endLabel)
    end if

    if not isValid(startVal) then return invalid
    if not isValid(endVal) then return invalid
    if endVal < startVal then return invalid

    return {
        "rangeStart": startVal
        "rangeEnd": endVal
    }
end function

function sabr_rangesMatch(rangeObj as dynamic, requestRange as object) as boolean
    if not isValid(rangeObj) then return false

    expectedStart = `${rangeObj?.start ?? "0"}`
    if expectedStart = "" then expectedStart = `${rangeObj?.startRange ?? "0"}`
    expectedEnd = `${rangeObj?.end ?? "0"}`
    if expectedEnd = "" then expectedEnd = `${rangeObj?.endRange ?? "0"}`

    requestStart = `${requestRange?.startRange ?? "0"}`
    if requestStart = "" then requestStart = `${requestRange?.start ?? "0"}`
    requestEnd = `${requestRange?.endRange ?? "0"}`
    if requestEnd = "" then requestEnd = `${requestRange?.end ?? "0"}`

    if expectedStart = "" or expectedEnd = "" then return false
    if requestStart = "" or requestEnd = "" then return false
    return (expectedStart = requestStart) and (expectedEnd = requestEnd)
end function


function sabr_getDumpLabel(playbackContext as object, prefix as string, requestNumber as string, byteRange as object, contentType = "" as string, format = invalid as dynamic) as string
    if not isValid(prefix) then prefix = "dump"
    rn = requestNumber
    if rn = ""
        rn = "unknown"
    end if
    rangePart = sabr_formatRequestedRangeForPath(byteRange)
    if rangePart = "" then rangePart = "none"

    contentLabel = contentType ?? ""
    if contentLabel = "" then contentLabel = playbackContext?.lastContentType ?? ""
    if contentLabel = ""
        contentLabel = "unknown"
    end if

    playbackContext["lastContentType"] = contentLabel

    itagLabel = ""
    if isValid(format)
        itagLabel = isValid(format?.itag) ? `${format.itag}` : ""
    end if
    if itagLabel = "" and isValid(playbackContext?.lastFormat)
        itagLabel = playbackContext.lastFormat?.itag ?? ""
    end if
    if itagLabel = "" then itagLabel = "noitag"

    if isValid(format)
        playbackContext["lastFormat"] = format
    end if

    batchIndex = isValid(playbackContext?.lastDumpIndex) ? `${playbackContext.lastDumpIndex}` : ""
    if batchIndex = "" then batchIndex = isValid(playbackContext?.requestSequence) ? `${playbackContext.requestSequence}` : ""
    if batchIndex = "" then batchIndex = rn

    counter =  m.top.utilsTask.callFunc("getNextId", "sabrDumpCounterBatch")

    seqLabel = sabr_nextDumpSequence()

    return `roku-player/${sabr_zeroPadDigits(seqLabel, 6)}-${prefix}-${contentLabel}-itag${itagLabel}-${batchIndex}-${counter}-${rn}-${rangePart}`
end function

sub roku_debugUploadText(debugUploadUrl as string, relativePath as string, text as string, logs = invalid as dynamic)
    if not isValid(text) then return
    payload = text
    if not IsString(payload)
        payload = `${payload} ?? ""`
    end if
    if payload = "" then return
    roku_debugUploadContent(debugUploadUrl, relativePath, payload, true, logs)
end sub

sub roku_debugUploadBytes(debugUploadUrl as string, relativePath as string, bytes as object, logs = invalid as dynamic)
    if not isValid(bytes) then return
    if GetInterface(bytes, "ifByteArray") = invalid then return
    roku_debugUploadContent(debugUploadUrl, relativePath, bytes, false, logs)
end sub

sub roku_debugUploadContent(debugUploadUrl as string, relativePath as string, content as dynamic, isText as boolean, logs = invalid as dynamic)
    baseUrl = `${debugUploadUrl ?? ""}`
    if baseUrl = "" then return

    originalPath = `${relativePath ?? ""}`
    if originalPath = ""
        originalPath = isText ? "roku-debug-request.json" : "roku-debug-bytes.bin"
    end if

    encodedPath = roku_urlEncode(originalPath)
    if encodedPath = "" then encodedPath = originalPath

    separator = "?"
    if Instr(baseUrl, "?") > 0
        separator = "&"
    end if
    url = `${baseUrl}${separator}path=${encodedPath}`

    transfer = CreateObject("roUrlTransfer")
    if LCase(Left(url, 5)) = "https"
        transfer.SetCertificatesFile("common:/certs/ca-bundle.crt")
        transfer.InitClientCertificates()
    end if
    transfer.SetRequest("POST")
    transfer.SetUrl(url)

    success = false

    if isText
        stringPayload = content
        if not IsString(stringPayload)
            stringPayload = `${stringPayload} ?? ""`
        end if
        if isValid(stringPayload) and stringPayload <> ""
            transfer.AddHeader("Content-Type", "application/json")
            success = transfer.PostFromString(stringPayload)
        end if
    else
        transfer.AddHeader("Content-Type", "application/octet-stream")
        tempDir = "tmp:/roku-debug"
        fs = CreateObject("roFileSystem")
        fs.CreateDirectory(tempDir)
        fileName = roku_sanitizeForFilename(originalPath)
        if fileName = "" then fileName = "roku-debug-bytes.bin"
        tmpFilePath = `${tempDir}/${fileName}`

        bytesRef = content
        wrote = false
        if GetInterface(bytesRef, "ifByteArray") <> invalid
            wrote = bytesRef.WriteFile(tmpFilePath)
        else
            byteCopy = CreateObject("roByteArray")
            if IsString(bytesRef)
                byteCopy.FromAsciiString(bytesRef)
            end if
            wrote = byteCopy.WriteFile(tmpFilePath)
        end if

        if wrote
            success = transfer.PostFromFile(tmpFilePath)
            fs.Delete(tmpFilePath)
        end if
    end if

    if success = true
        if isValid(logs)
            logs.printl(log_level_Type.DEBUG, `[YTSABR-Debug] Uploaded debug payload to ${url}`)
        end if
    else
        if isValid(logs)
            logs.printl(log_level_Type.WARN, `[YTSABR-Debug] Failed to upload debug payload to ${url}`)
        end if
    end if
end sub

function roku_sanitizeForFilename(value as string) as string
    if not isValid(value) then return ""
    sanitized = ""
    for i = 1 to Len(value)
        ch = Mid(value, i, 1)
        ascii = Asc(ch)
        if ch = "." or ch = "-" or ch = "_" or ch = " "
            sanitized = sanitized + ch
        else if ascii >= 48 and ascii <= 57
            sanitized = sanitized + ch
        else if ascii >= 65 and ascii <= 90
            sanitized = sanitized + ch
        else if ascii >= 97 and ascii <= 122
            sanitized = sanitized + ch
        else
            sanitized = sanitized + "_"
        end if
    end for
    return sanitized
end function

function roku_urlEncode(value as string) as string
    if not isValid(value) then return ""
    encoder = CreateObject("roUrlTransfer")
    return encoder.Escape(value)
end function

sub sabr_deleteFileIfExists(path as dynamic)
    if not isValid(path) then return
    if not IsString(path) then return
    if path = "" then return

    fs = CreateObject("roFileSystem")
    if fs.Exists(path)
        fs.Delete(path)
    end if
end sub

function sabr_extractRequestNumber(value as dynamic) as string
    if not isValid(value) then return ""

    if IsAssociativeArray(value)
        if value.DoesExist("requestNumber")
            return sabr_extractRequestNumber(value.requestNumber)
        end if
        return ""
    end if

    return sabr_valueToLabel(value)
end function

function sabr_utilLogTag(contentType as string, requestRef = invalid as dynamic) as string
    rn = sabr_extractRequestNumber(requestRef)
    if rn = ""
        return `[YTSABR-Util-${contentType}]`
    end if
    return `[YTSABR-Util-${contentType}-${rn}]`
end function

function sabr_handleRequest(request as object, contentType as string, mediaIdHash as string, sabr as object, videoNode as object, redirectDepth = 0 as integer) as object
    ok = true

    sabrAbrUrl = ""
    playbackContext = invalid
    response = invalid
    requestTimer = invalid
    requestLogTag = `[YTSABR-${contentType}]`
    if isValid(m?.logs)
        requestTimer = m.logs.mark()
    end if

    ' load the playbackContext.json file from tmp:/${mediaIdHash}/playbackContext.json
    fileContent = getFile(`tmp:/${mediaIdHash}/playbackContext.json`)
    if fileContent = "" then
        ok = false
        m.logs.printl(log_level_Type.WARN, `[YTSABR-Util-${contentType}] No SABR playbackContext file found for mediaIdHash: ${mediaIdHash}`)
    else
        playbackContext = ParseJson(fileContent)
        if not isValid(playbackContext)
            ok = false
            m.logs.printl(log_level_Type.WARN, `[YTSABR-Util-${contentType}] Invalid SABR playbackContext file for mediaIdHash: ${mediaIdHash}`)
        else
            m.logs.printl(log_level_Type.INFO, `[YTSABR-Util-${contentType}] Loaded SABR playbackContext from file for mediaIdHash: ${mediaIdHash}`)
        end if
    end if

    if not isValid(playbackContext)
        ok = false
        m.logs.printl(log_level_Type.WARN, `[YTSABR-Util-${contentType}] No SABR playback context available`)
    ' else
        ' m.logs.printl(log_level_Type.INFO, `SABR playback mediaId: ${FormatJson(playbackContext.sabrPayload)}`)
    end if

    fatalInfo = playbackContext?.sabrFatalError
    if isValid(fatalInfo)
        fatalReason = fatalInfo?.reason ?? "SABR fatal error"
        m.logs.printl(log_level_Type.WARN, `[YTSABR-Util-${contentType}] Blocking SABR request due to fatal error: ${fatalReason}`)
        return sabr_buildErrorResponseForPlayer(502, fatalReason)
    end if

    sabr_ensureInfrastructure()
    metadataManager = m.sabrRequestMetadataManager
    debugUploadUrl = m.top.debugUploadUrl ?? ""

    formats = sabr?.adaptiveFormats
    if not isValid(formats) or formats.count() = 0
        formats = sabr?.hlsFormats
        if not isValid(formats) or formats.count() = 0
            ok = false
            m.logs.printl(log_level_Type.WARN, `[YTSABR-Util-${contentType}] No SABR formats available`)
        end if
    end if
    
    sabrAbrUrl = sabr?.serverAbrStreamingUrl
    if not isValid(sabrAbrUrl) or sabrAbrUrl = ""
        ok = false
        m.logs.printl(log_level_Type.WARN, `[YTSABR-Util-${contentType}] No SABR URL provided`)
    end if

    ' increment the request number
    ' nextRequestId = generateSabrRequestNumber(playbackContext, contentType)
    nextRequestId = m.top.utilsTask.callFunc("getNextId", "sabrRequestNumber")
    playbackContext["requestNumber"] = nextRequestId
    requestLogTag = sabr_utilLogTag(contentType, nextRequestId)
    m.logs.printl(log_level_Type.INFO, `${requestLogTag} SABR playback request number: ${nextRequestId}`)

    ' update the URL's rn param (or create it) to be the request number
    regexRn = CreateObject("roRegex", "([&?])rn=[^&]*", "i")
    if regexRn.match(sabrAbrUrl).count() > 0
        sabrAbrUrl = regexRn.replaceAll(sabrAbrUrl, `\1rn=${nextRequestId}`)
    else
        sep = sabrAbrUrl.inStr("?") > -1 ? "&" : "?"
        sabrAbrUrl = `${sabrAbrUrl}${sep}rn=${nextRequestId}`
    end if
    m.logs.printl(log_level_Type.INFO, `${requestLogTag} URL: ${sabrAbrUrl}`)

    ' originalUrl = request.path
    try
        if not isValid(request.search.key) or request.search.key = ""
            ok = false
            m.logs.printl(log_level_Type.WARN, `${requestLogTag} No SABR itag key provided`)
        else
            currentKey = sabr_toInt(request.search.key)
            currentFormat = invalid
            for each format in formats
                if format.itag = currentKey
                    currentFormat = format
                    exit for
                end if
            end for
        end if
    catch e
        ok = false
        m.logs.printl(log_level_Type.WARN, `${requestLogTag} Error finding format for itag: ${request.search.key} - ${e.message}`)
    end try

    if not isValid(currentFormat)
        ok = false
        m.logs.printl(log_level_Type.WARN, `${requestLogTag} No matching format for itag: ${request.search.key}`)
    end if

    activeFormats = sabr_getActiveFormats(currentFormat, sabr, playbackContext)

    requestByteRange = sabr_getHeaderByteRange(request)
    requestByteRange = sabr_normalizeByteRange(requestByteRange, {
        "mediaIdHash": mediaIdHash
        "contentType": contentType
        "format": currentFormat
    })
    m.logs.printl(log_level_Type.DEBUG, `${requestLogTag} Normalized byteRange start=${requestByteRange?.startRange ?? ""} end=${requestByteRange?.endRange ?? ""} seq=${requestByteRange?.sequenceNumber ?? ""}`)
    streamInfoForFormat = sabr_fetchStreamInfoForFormat(playbackContext, contentType, currentFormat)
    isInitSegmentRequest = sabr_isInit(contentType, currentFormat, requestByteRange, nextRequestId)

    formatKeyForLog = sabr_formatToKey(currentFormat)
    totalsForLog = playbackContext?.deliveredDurationTotals
    totalLogValue = invalid
    if IsAssociativeArray(totalsForLog) and formatKeyForLog <> "" and totalsForLog.DoesExist(formatKeyForLog)
        totalLogValue = totalsForLog.Lookup(formatKeyForLog)
    end if
    m.logs.printl(log_level_Type.DEBUG, `${requestLogTag} Resolving segment start; init=${isInitSegmentRequest} formatKey=${formatKeyForLog} totals=${totalLogValue}`)

    bufferState = sabr_buildBufferedState(mediaIdHash, currentFormat, activeFormats, playbackContext, contentType)

    playerTimeInfo = sabr_resolvePlayerTimeMsForRequest(playbackContext, contentType, currentFormat, requestByteRange, videoNode)
    playerTimeOverride = sabr_toInt(playerTimeInfo?.value)
    if playerTimeOverride = invalid or playerTimeOverride < 0
        playerTimeOverride = 0
    end if
    playerTimeSourceLabel = `${playerTimeInfo?.source ?? "unknown"}`
    playbackContext["lastResolvedPlayerTimeMs"] = playerTimeOverride
    playbackContext["lastResolvedPlayerTimeSource"] = playerTimeSourceLabel

    m.logs.printl(log_level_Type.DEBUG, `${requestLogTag} Resolved playerTimeMs=${playerTimeOverride} source=${playerTimeSourceLabel}`)
    rangeLabelForLog = sabr_formatRequestedRangeForPath(requestByteRange)
    m.logs.printl(log_level_Type.DEBUG, `${requestLogTag} Using playerTimeMs=${playerTimeOverride} for range ${rangeLabelForLog}`)

    sabrRequestJson = sabr_createVideoPlaybackAbrRequest(request, contentType, sabr, currentFormat, activeFormats, playbackContext, playerTimeOverride, videoNode, nextRequestId)

     if isValid(currentFormat.height) 
        sabrRequestJson.clientAbrState["stickyResolution"] = currentFormat.height
        sabrRequestJson.clientAbrState["lastManualSelectedResolution"] = currentFormat.height
     end if

    formatToDiscard = sabr_applyBufferedStateToRequest(sabrRequestJson, bufferState)

    if isValid(formatToDiscard)
        ' the formatToDiscard is the one that we are faking out the youtube server to "not" send us any data.
        ' in this way, if this is a video request, we can get the video segment data but not the audio and vice versa
        ' Sabr wants to send us both audio and video segments in the same response, but we only want one or the other
        sabrRequestJson.selectedFormatIds.push(formatToDiscard)
    end if

    sabr_logBufferedRanges(requestLogTag, sabrRequestJson)

    cacheKey = sabr_buildCacheKey(mediaIdHash, contentType, currentFormat, requestByteRange, isInitSegmentRequest)

    keyParam = request.search.key
    if keyParam = "" and isValid(request.search?.itag)
        keyParam = request.search.itag
    end if

    requestMetadataEntry = {
        "requestNumber": nextRequestId
        "isInit": isInitSegmentRequest
        "byteRange": {
            "start": requestByteRange.startRange
            "end": requestByteRange.endRange
            "startRange": requestByteRange.startRange
            "endRange": requestByteRange.endRange
            "sequenceNumber": requestByteRange.DoesExist("sequenceNumber") ? requestByteRange.sequenceNumber : invalid
            "segmentIndexInfo": requestByteRange.DoesExist("segmentIndexInfo") ? requestByteRange.segmentIndexInfo : invalid
        }
        "format": currentFormat
        "contentType": contentType
        "mediaIdHash": mediaIdHash
        "cacheKey": cacheKey
        "streamInfo": streamInfoForFormat
        "timestamp": sabr_currentTimestampMs()
        "debugUploadUrl": debugUploadUrl
        "sabrKey": keyParam
        "requestPath": request.path
    }
    if requestByteRange.DoesExist("segmentIndexInfo")
        requestMetadataEntry["segmentIndexInfo"] = requestByteRange.segmentIndexInfo
    end if
    if requestByteRange.DoesExist("sequenceNumber")
        requestMetadataEntry["sequenceNumber"] = sabr_toInt(requestByteRange.sequenceNumber)
    end if
    if isValid(metadataManager)
        metadataManager.store(metadataManager, `${nextRequestId}`, requestMetadataEntry)
    end if

    sabr_debugLogRepeatState(contentType, nextRequestId, playbackContext, "pre_guard", `range=${rangeLabelForLog}`)

    repeatGuardResponse = sabr_guardRepeatedRequests(playbackContext, contentType, currentFormat, requestMetadataEntry, `${nextRequestId}`, videoNode, mediaIdHash)
    if isValid(repeatGuardResponse)
        return repeatGuardResponse
    end if

    cacheHit = false
    cacheLookupRange = sabr_formatRequestedRangeForPath(requestMetadataEntry.byteRange)
    cacheLookupLabel = `${cacheKey ?? ""}`
    if cacheLookupLabel = "" then cacheLookupLabel = "none"
    m.logs.printl(log_level_Type.DEBUG, `${requestLogTag} Cache lookup start sabr_isInit=${isInitSegmentRequest} key=${cacheLookupLabel} range=${cacheLookupRange}`)

    cacheEntry = sabr_cacheLoadSegment({
        "mediaIdHash": mediaIdHash
        "contentType": contentType
        "itag": currentFormat?.itag
        "trackId": currentFormat?.audioTrackId
        "requestedStart": requestMetadataEntry.byteRange?.startRange
        "requestedEnd": requestMetadataEntry.byteRange?.endRange
        "isInit": isInitSegmentRequest
    })

    if IsAssociativeArray(cacheEntry) and GetInterface(cacheEntry?.data, "ifByteArray") <> invalid and cacheEntry.data.count() > 0
        if not isValid(requestMetadataEntry.streamInfo)
            storedInfo = sabr_fetchStreamInfoForFormat(playbackContext, contentType, currentFormat)
            if isValid(storedInfo)
                requestMetadataEntry["streamInfo"] = storedInfo
            else if isValid(playbackContext.lastSabrStreamInfo)
                requestMetadataEntry["streamInfo"] = playbackContext.lastSabrStreamInfo
            end if
        end if

        cachedResult = {
            "data": cacheEntry.data
            "done": true
            "coverage": {
                "rangeStart": cacheEntry.rangeStart
                "rangeEnd": cacheEntry.rangeEnd
            }
        }

        if cacheEntry?.path <> ""
            playerTimeForDelivery = sabr_toInt(requestMetadataEntry?.playerTimeMs)
            if playerTimeForDelivery = invalid or playerTimeForDelivery < 0
                playerTimeForDelivery = sabr_toInt(playbackContext?.lastResolvedPlayerTimeMs)
            end if
            if playerTimeForDelivery = invalid or playerTimeForDelivery < 0
                playerTimeForDelivery = sabr_toInt(playbackContext?.lastRequestedPlayerTimeMs)
            end if
            sabr_cacheMarkDeliveredByPath(cacheEntry.path, "cache-hit-response", {
                "contentType": contentType,
                "itag": currentFormat?.itag,
                "trackId": currentFormat?.audioTrackId,
                "mediaIdHash": mediaIdHash,
                "playerTimeMs": playerTimeForDelivery
            })
        end if

        response = sabr_buildResponseForPlayer(requestMetadataEntry, cachedResult, currentFormat, requestByteRange, contentType)
        prefetchInfo = sabr_buildPrefetchInfo(requestMetadataEntry.streamInfo, currentFormat, requestMetadataEntry)
        sabr_maybeSchedulePrefetch(playbackContext, videoNode, prefetchInfo, contentType)
        cacheHit = true
        pathLabel = cacheEntry?.path ?? ""
        if pathLabel <> "" and pathLabel.InStr("/") >= 0
            parts = pathLabel.Split("/")
            pathLabel = parts[parts.count() - 1]
        end if
        m.logs.printl(log_level_Type.INFO, `${requestLogTag} Cache hit path=${pathLabel} range=${cacheLookupRange} bytes=${cacheEntry.data.count()}`)
    end if

    if cacheHit = false
        m.logs.printl(log_level_Type.DEBUG, `${requestLogTag} Cache miss key=${cacheLookupLabel} range=${cacheLookupRange}`)
    end if
    batchCounter =  m.top.utilsTask.callFunc("getNextId", "sabrBatchCounter")
    playbackContext["lastDumpIndex"] = batchCounter
    requestMetadataEntry["batchIndex"] = batchCounter

    if ok and not cacheHit
        if not isInitSegmentRequest and isValid(currentFormat)
            sabrRequestJson.selectedFormatIds.push(currentFormat)
        end if

        if isValid(m?.logs)
            selectedSummary = ""
            if IsArray(sabrRequestJson?.selectedFormatIds) and sabrRequestJson.selectedFormatIds.count() > 0
                try
                    selectedSummary = FormatJson(sabrRequestJson.selectedFormatIds)
                catch e
                    selectedSummary = "<FormatJson error>"
                end try
            end if
            if selectedSummary <> ""
                m.logs.printl(log_level_Type.DEBUG, `${requestLogTag} selectedFormatIdsJson=${selectedSummary}`)
            end if
        end if

        ' clone the object as the encode will add snake case object keys alongside camel case ones
        playbackContext["lastSabrRequest"] = sabrRequestJson
        if debugUploadUrl <> ""
            requestPayloadJson = FormatJson(sabrRequestJson)
            if isValid(requestPayloadJson) and requestPayloadJson <> ""
                dumpLabel = sabr_getDumpLabel(playbackContext, "sabr-request", `${nextRequestId}`, requestMetadataEntry.byteRange, contentType, currentFormat)
                roku_debugUploadText(debugUploadUrl, `${dumpLabel}.json`, requestPayloadJson, m.logs)
            end if
        end if
        encodedProto = ""
        protoBytes = invalid
        protoFilePath = ""
        responseFilePath = ""
        encodeTimer = invalid
        if isValid(m?.logs)
            encodeTimer = m.logs.mark()
        end if
        try
            m.logs.printl(log_level_Type.INFO, `${requestLogTag} Encoding SABR proto for itag: ${currentFormat.itag}`)
            ' m.logs.printl(log_level_Type.VERBOSE, FormatJson(sabrRequestJson))
            encodedProto = VideoPlaybackAbrRequestEncode(sabrRequestJson)
            if IsString(encodedProto) and encodedProto <> ""
                protoBytes = CreateObject("roByteArray")
                protoBytes.FromBase64String(encodedProto)
                ' sanity check on the decode
                decodedProto = VideoPlaybackAbrRequestDecode(encodedProto)
                if not isValid(decodedProto)
                    ok = false
                    m.logs.printl(log_level_Type.WARN, `${requestLogTag} Error decoding SABR proto after encode`)
                else
                    ' m.logs.printl(log_level_Type.VERBOSE, `${requestLogTag} Decoded SABR proto: ${FormatJson(decodedProto)}`)
                    if debugUploadUrl <> ""
                        requestPayloadJson = FormatJson(decodedProto)
                        if isValid(requestPayloadJson) and requestPayloadJson <> ""
                            dumpLabel = sabr_getDumpLabel(playbackContext, "sabr-request-decode", `${nextRequestId}`, requestMetadataEntry.byteRange, contentType, currentFormat)
                            roku_debugUploadText(debugUploadUrl, `${dumpLabel}.json`, requestPayloadJson, m.logs)
                        end if
                    end if
                end if
            end if
        catch e
            ok = false
            m.logs.printl(log_level_Type.WARN, `${requestLogTag} Error encoding SABR proto: ${e.message}`)
        end try
        if encodeTimer <> invalid
            m.logs.printTime(log_level_Type.INFO, `${requestLogTag} Proto encode duration`, encodeTimer, -1)
        end if

        ' prepare the SABR request now
        if ok and IsValid(protoBytes)
            m.logs.printl(log_level_Type.INFO, `${requestLogTag} proto payload`)
            if playbackContext.hasVideoParts = true
                m.logs.printl(log_level_Type.INFO, `${requestLogTag} Sending SABR video request to URL: ${sabrAbrUrl}`)
                ' write the protoBytes to a file and send that file to the SABR URL
                protoFilePath = `tmp:/${mediaIdHash}/sabrRequest-${contentType}-${nextRequestId}.bin`
                protoBytes.writeFile(protoFilePath)
                sabrRequest = {
                    "url": sabrAbrUrl, ' "http://192.168.119.94:8000/sabr"
                    "requestType": "proxy",
                    "timeout": 10000,
                    "options": {
                        "method": "POST_FILE_TO_FILE_WITH_DECODINGS",
                        "body": protoFilePath
                    }
                }

                m.logs.printl(log_level_Type.INFO, `[RELAY] Performing proxied request to: ${FormatJson(sabrAbrUrl)}`)
                requestSpan = invalid
                if isValid(m?.logs)
                    requestSpan = m.logs.mark()
                end if
                res = makeRequest(sabrRequest)
                if requestSpan <> invalid
                    m.logs.printTime(log_level_Type.INFO, `${requestLogTag} SABR proxy round-trip`, requestSpan, -1)
                end if
                if not isValid(res?.status) 
                    ok = false
                    m.logs.printl(log_level_Type.WARN, `${requestLogTag} No response status from SABR UMP request`)
                    response = sabr_buildErrorResponseForPlayer(500, "SABR request failed")
                else if res.status >= 200 and res?.status <= 206
                    responseFilePath = res.body
                    fatalReason = ""
                    segmentInfo = invalid
                    umpResult = invalid
                    segmentScanSummary = invalid
                    totalBytesRead = 0
                    chunkIndex = 0
                    processTimer = invalid
                    requestMetadata = invalid

                    if isValid(responseFilePath) and responseFilePath <> ""
                        requestMetadata = {
                            "isUMP": true
                            "isSABR": true
                            "isInit": isInitSegmentRequest
                            "requestNumber": nextRequestId
                            "format": currentFormat
                            "streamInfo": {}
                            "cacheKey": cacheKey
                            "debugUploadUrl": debugUploadUrl
                            "mediaIdHash": mediaIdHash
                            "contentType": contentType
                        }
                        requestMetadata["chunkBufferPool"] = sabr_chunkBufferPool()
                        requestMetadata["chunkBufferPoolLimit"] = SABR_CHUNK_BUFFER_POOL_LIMIT

                        if isValid(requestMetadataEntry.byteRange.start) and requestMetadataEntry.byteRange.start <> "" and isValid(requestMetadataEntry.byteRange.end) and requestMetadataEntry.byteRange.end <> ""
                            requestMetadata["byteRange"] = requestMetadataEntry.byteRange
                        end if

                        if isValid(m?.logs)
                            processTimer = m.logs.mark()
                        end if
                        chunkSize = SABR_UMP_STREAM_CHUNK_SIZE
                        if chunkSize <= 0 then chunkSize = 131072

                        try
                            sabrUmpProcessor = sabr_ump_createProcessor(requestMetadata, m.logs)
                            fileOffset = 0
                            while true
                                chunkBytes = sabr_acquireChunkBuffer()
                                readOk = chunkBytes.ReadFile(responseFilePath, fileOffset, chunkSize)
                                if readOk <> true
                                    sabr_releaseChunkBuffer(chunkBytes)
                                    exit while
                                end if
                                chunkLength = chunkBytes.Count()
                                if chunkLength <= 0
                                    sabr_releaseChunkBuffer(chunkBytes)
                                    exit while
                                end if

                                totalBytesRead = totalBytesRead + chunkLength
                                chunkIndex = chunkIndex + 1
                                chunkResult = sabrUmpProcessor.processChunk(chunkBytes)
                                if isValid(chunkResult) and chunkResult.done = true
                                    if chunkResult?.error <> invalid and chunkResult.error <> ""
                                        fatalReason = `SABR processing error: ${chunkResult.error}`
                                        if not isValid(umpResult) then umpResult = chunkResult
                                        exit while
                                    else if not isValid(umpResult)
                                        umpResult = chunkResult
                                    end if
                                end if

                                fileOffset = fileOffset + chunkLength
                                if chunkLength < chunkSize or fatalReason <> "" then exit while
                            end while

                            if fatalReason = ""
                                segmentInfo = sabrUmpProcessor.getSegmentInfo()
                            end if
                            if sabrUmpProcessor.DoesExist("getSegmentScanSummary")
                                segmentScanSummary = sabrUmpProcessor.getSegmentScanSummary()
                            end if
                        catch e
                            fatalReason = e?.message ?? ""
                            if fatalReason = "" then fatalReason = `${e}`
                            if fatalReason = "" then fatalReason = "SABR init processing failed"
                        end try

                        if processTimer <> invalid
                            m.logs.printTime(log_level_Type.INFO, `${requestLogTag} UMP processing duration`, processTimer, -1)
                        end if
                        if totalBytesRead > 0
                            m.logs.printl(log_level_Type.INFO, `${requestLogTag} SABR UMP streamed response bytes=${totalBytesRead} chunks=${chunkIndex}`)
                        else
                            m.logs.printl(log_level_Type.WARN, `${requestLogTag} SABR UMP response file empty or unreadable: ${responseFilePath}`)
                        end if
                    else
                        fatalReason = "SABR UMP response path missing"
                        m.logs.printl(log_level_Type.WARN, `${requestLogTag} ${fatalReason}`)
                    end if

                    if fatalReason <> ""
                        playbackContext["sabrFatalError"] = {
                            "reason": fatalReason
                            "requestNumber": nextRequestId
                            "timestamp": sabr_currentTimestampMs()
                        }
                        m.logs.printl(log_level_Type.WARN, `${requestLogTag} Fatal SABR error: ${fatalReason}`)
                        if response = invalid
                            response = sabr_buildErrorResponseForPlayer(502, fatalReason)
                        end if
                    else
                        if isValid(segmentInfo)
                            m.logs.printl(log_level_Type.INFO, `${requestLogTag} Segment info available after processing: ${FormatJson(segmentInfo)}`)
                        end if

                        if IsArray(segmentScanSummary?.segments)
                            segmentCount = segmentScanSummary.segments.count()
                            matchedFlag = segmentScanSummary?.matched
                            if matchedFlag = invalid then matchedFlag = false
                            m.logs.printl(log_level_Type.INFO, `${requestLogTag} SABR scan summary segments=${segmentCount} matched=${matchedFlag}`)
                            for each scanEntry in segmentScanSummary.segments
                                headerLabel = sabr_valueToLabel(scanEntry?.headerId)
                                seqLabel = sabr_valueToLabel(scanEntry?.sequenceNumber)
                                startLabel = sabr_valueToLabel(scanEntry?.start)
                                matchedLabel = scanEntry?.matched
                                if matchedLabel = invalid then matchedLabel = false
                                m.logs.printl(log_level_Type.DEBUG, `${requestLogTag} SABR scan header=${headerLabel} seq=${seqLabel} start=${startLabel} matched=${matchedLabel}`)
                            end for
                        end if

                        playbackContext["lastSabrStreamInfo"] = requestMetadata.streamInfo
                        playbackCookieValue = requestMetadata.playbackCookie
                        if isValid(playbackCookieValue) and playbackCookieValue <> ""
                            playbackContext["lastPlaybackCookie"] = playbackCookieValue
                            if isValid(sabr)
                                sabr.playbackCookie = playbackCookieValue
                            end if
                        end if
                        redirectUrl = requestMetadata.streamInfo?.redirect?.url ?? ""
                        redirectTriggered = false
                        if redirectUrl <> ""
                            if isValid(sabr)
                                sabr.serverAbrStreamingUrl = redirectUrl
                            end if
                            playbackContext["serverAbrStreamingUrl"] = redirectUrl
                            m.logs.printl(log_level_Type.INFO, `${requestLogTag} Updated SABR server URL via redirect: ${redirectUrl}`)
                            if not isValid(umpResult?.data) or umpResult.data.count() = 0
                                redirectTriggered = true
                            end if
                        end if
                        requestMetadataEntry["streamInfo"] = requestMetadata.streamInfo

                        if redirectTriggered
                            if redirectDepth >= 3
                                fatalReason = "SABR redirect limit reached"
                                m.logs.printl(log_level_Type.WARN, `${requestLogTag} ${fatalReason}`)
                            else
                                m.logs.printl(log_level_Type.INFO, `${requestLogTag} Following SABR redirect to ${redirectUrl}`)
                                sabr_deleteFileIfExists(responseFilePath)
                                sabr_deleteFileIfExists(protoFilePath)
                                writeFile(`tmp:/${mediaIdHash}/playbackContext.json`, FormatJson(playbackContext))
                                return sabr_handleRequest(request, contentType, mediaIdHash, sabr, videoNode, redirectDepth + 1)
                            end if
                        end if

                        if not isValid(umpResult)
                            pendingSummary = []
                            processedParts = []
                            if IsAssociativeArray(sabrUmpProcessor)
                                if sabrUmpProcessor.DoesExist("getPendingSegmentsSummary")
                                    pendingSummary = sabrUmpProcessor.getPendingSegmentsSummary()
                                end if
                                if sabrUmpProcessor.DoesExist("getProcessedPartTypes")
                                    processedParts = sabrUmpProcessor.getProcessedPartTypes()
                                end if
                            end if

                            streamInfoKeys = []
                            if IsAssociativeArray(requestMetadata?.streamInfo)
                                for each infoKey in requestMetadata.streamInfo
                                    streamInfoKeys.push(infoKey)
                                end for
                            end if

                            logDetails = {
                                "requestNumber": nextRequestId
                                "requestedRange": sabr_formatRequestedRangeForPath(requestMetadataEntry?.byteRange)
                                "pendingSegments": pendingSummary
                                "processedParts": processedParts
                                "streamInfoKeys": streamInfoKeys
                            }
                            if not isValid(umpResult)
                                logDetails["result"] = "missing"
                            end if
                            m.logs.printl(log_level_Type.WARN, `${requestLogTag} No segment data returned from UMP response: ${FormatJson(logDetails)}`)
                        else
                            requestMetadataEntry["streamInfo"] = requestMetadata.streamInfo

                            coverageInfo = umpResult?.coverage
                            deliveredSegment = false
                            if isValid(umpResult?.data) and GetInterface(umpResult.data, "ifByteArray") <> invalid
                                segmentBytes = umpResult.data
                                deliveredSegment = segmentBytes.count() > 0
                                if deliveredSegment
                                    coverageRange = sabr_byteRangeToCoverage(requestMetadataEntry.byteRange)
                                    if not isValid(coverageRange) and isValid(coverageInfo)
                                        coverageRange = coverageInfo
                                    end if
                                    rangeLabel = sabr_formatRequestedRangeForPath(requestMetadataEntry.byteRange)
                                    deliveredLabel = coverageRange
                                    if not isValid(deliveredLabel) and isValid(coverageInfo)
                                        deliveredLabel = coverageInfo
                                    end if
                                    if IsAssociativeArray(deliveredLabel)
                                        deliveredLabel = `${deliveredLabel?.rangeStart ?? ""}-${deliveredLabel?.rangeEnd ?? ""}`
                                    end if
                                    deliveredInfo = {
                                        "coverageLabel": deliveredLabel
                                        "rangeLabel": rangeLabel
                                        "bytes": segmentBytes.count()
                                    }
                                    m.logs.printl(log_level_Type.INFO, `${requestLogTag} SABR delivered segment ${FormatJson(deliveredInfo)}`)
                                    requestMetadataEntry["coverage"] = coverageRange
                                    requestMetadataEntry["segmentIndexKey"] = sabr_formatToKey(currentFormat)
                                    playerTimeForStore = sabr_toInt(playerTimeOverride)
                                    coverageForStore = coverageRange
                                    if not isValid(coverageForStore) and isValid(coverageInfo)
                                        coverageForStore = coverageInfo
                                    end if
                                    storageInfo = sabr_cacheStoreSegment({
                                        "mediaIdHash": mediaIdHash
                                        "contentType": contentType
                                        "itag": currentFormat?.itag
                                        "bytes": segmentBytes
                                        "coverage": coverageForStore
                                        "playerTimeMs": playerTimeForStore
                                        "streamInfo": requestMetadata.streamInfo
                                        "cacheKey": cacheKey
                                        "formatKey": sabr_formatToKey(currentFormat)
                                    })
                                    storagePath = storageInfo?.path ?? ""
                                    if deliveredSegment = true and storagePath <> ""
                                        sabr_cacheMarkDeliveredByPath(storagePath, "direct-response", {
                                            "contentType": contentType,
                                            "itag": currentFormat?.itag,
                                            "trackId": currentFormat?.audioTrackId,
                                            "mediaIdHash": mediaIdHash,
                                            "playerTimeMs": playerTimeForStore
                                        })
                                    end if
                                end if
                            end if

                            if isValid(metadataManager)
                                metadataManager.store(metadataManager, `${nextRequestId}`, requestMetadataEntry)
                            end if

                            prefetchInfo = sabr_buildPrefetchInfo(requestMetadataEntry.streamInfo, currentFormat, requestMetadataEntry)
                            sabr_maybeSchedulePrefetch(playbackContext, videoNode, prefetchInfo, contentType)

                            sabr_applyStreamInfoUpdates(playbackContext, requestMetadata.streamInfo, contentType, deliveredSegment, requestMetadataEntry)
                            if deliveredSegment = true
                                sabr_storeStreamInfoForFormat(playbackContext, contentType, currentFormat, requestMetadata.streamInfo)
                            end if
                            if isValid(requestMetadata.streamInfo) and IsAssociativeArray(requestMetadata.streamInfo)
                                if requestMetadata.streamInfo.DoesExist("deliveredCoverage")
                                    requestMetadata.streamInfo.Delete("deliveredCoverage")
                                end if
                            end if

                            if response = invalid and isValid(umpResult)
                                response = sabr_buildResponseForPlayer(requestMetadataEntry, umpResult, currentFormat, requestByteRange, contentType)
                            end if
                        end if
                    end if
                else
                    m.logs.printl(log_level_Type.WARN, `${requestLogTag} SABR UMP request failed with status: ${res?.status}`)
                    response = sabr_buildErrorResponseForPlayer(sabr_toInt(`${res?.status ?? 0}`), `SABR request failed`)
                end if
            else
                m.logs.printl(log_level_Type.INFO, `${requestLogTag} ignoring audio SABR request for now`)
            end if
        else
            m.logs.printl(log_level_Type.WARN, `${requestLogTag} No valid SABR proto bytes to send`)
        end if

        sabr_deleteFileIfExists(responseFilePath)
        sabr_deleteFileIfExists(protoFilePath)

    end if

    if debugUploadUrl <> "" and isValid(response)
        bytesCount = 0
        if GetInterface(response.body, "ifByteArray") <> invalid
            bytesCount = response.body.count()
        else if isValid(response?.bodyLength)
            bytesCount = sabr_toInt(response.bodyLength)
        end if
        if GetInterface(response.body, "ifByteArray") <> invalid
            m.logs.printl(log_level_Type.INFO, `${requestLogTag} Response body size=${bytesCount} bytes for request ${nextRequestId}`)
            dumpBase = sabr_getDumpLabel(playbackContext, "response", `${nextRequestId}`, requestByteRange, contentType, currentFormat)
            roku_debugUploadBytes(debugUploadUrl, dumpBase + "-bytes", response.body, m.logs)
        else
            m.logs.printl(log_level_Type.INFO, `${requestLogTag} Response body size=${bytesCount} bytes for request ${nextRequestId} (streaming)`)
        end if

        responseInfo = {
            "status": response.status
            "headers": response.headers
            "cacheKey": cacheKey
            "isInit": isInitSegmentRequest
            "requestNumber": nextRequestId
            "contentType": contentType
        }
        roku_debugUploadText(debugUploadUrl, dumpBase + "-meta.json", FormatJson(responseInfo), m.logs)
    end if

    sabr_recordRepeatResult(playbackContext, requestMetadataEntry, response, contentType, `${nextRequestId}`)

    if not IsAssociativeArray(response)
        response = sabr_buildEmptyResponseForPlayer(contentType, currentFormat)
    end if

    if IsAssociativeArray(response.headers) and not response.headers.DoesExist("Content-Range")
        response.headers["X-Cache-Range"] = sabr_formatRequestedRangeForPath(requestByteRange)
    end if

    ' write the playbackContext to the playbackContext.json file to preserve state
    m.logs.printl(log_level_Type.INFO, `${requestLogTag} Storing SABR playbackContext to file for mediaIdHash: ${mediaIdHash}`)
    if isValid(playbackContext?.sidxIndexByFormat)
        m.logs.printl(log_level_Type.DEBUG, `${requestLogTag} SIDX map snapshot ${FormatJson(playbackContext.sidxIndexByFormat)}`)
    end if
    ' m.logs.printl(log_level_Type.VERBOSE, FormatJson(playbackContext))
    contextStoreTimer = invalid
    if isValid(m?.logs)
        contextStoreTimer = m.logs.mark()
    end if
    writeFile(`tmp:/${mediaIdHash}/playbackContext.json`, FormatJson(playbackContext))
    if contextStoreTimer <> invalid
        m.logs.printTime(log_level_Type.INFO, `${requestLogTag} Playback context persisted`, contextStoreTimer, -1)
    end if

    if requestTimer <> invalid
        m.logs.printTime(log_level_Type.INFO, `${requestLogTag} Total request duration`, requestTimer, -1)
    end if

    return response

end function

function sabr_getActiveFormats(currentFormat as object, sabr as object, playbackContext as object) as object
    formats = sabr.adaptiveFormats
    videoFormat = invalid
    audioFormat = invalid

    mimeType = currentFormat?.mimeType ?? ""
    if mimeType.inStr("video") > -1 or isValid(currentFormat?.width)
        videoFormat = currentFormat
    else if mimeType.inStr("audio") > -1 or not isValid(currentFormat?.width)
        audioFormat = currentFormat
    end if

    if not isValid(videoFormat)
        videoFormat = playbackContext?.lastVideoFormat
    end if
    if not isValid(audioFormat)
        audioFormat = playbackContext?.lastAudioFormat
    end if

    if not isValid(videoFormat)
        videoFormat = sabr_pickBestFormat(formats, "video")
    end if
    if not isValid(audioFormat)
        audioFormat = sabr_pickBestFormat(formats, "audio")
    end if

    if isValid(videoFormat)
        playbackContext["lastVideoFormat"] = videoFormat
    end if
    if isValid(audioFormat)
        playbackContext["lastAudioFormat"] = audioFormat
    end if

    return {
        "videoFormat": videoFormat,
        "audioFormat": audioFormat
    }
end function

function sabr_pickBestFormat(formats as dynamic, mediaType as string) as dynamic
    if not isValid(formats) then return invalid
    bestFormat = invalid
    bestBitrate = 0
    targetKeyword = mediaType = "audio" ? "audio" : "video"

    for each format in formats
        mimeType = format?.mimeType ?? ""
        if mimeType.inStr(targetKeyword) > -1
            bitrate = sabr_toInt(format?.bitrate)
            if bitrate = invalid then bitrate = sabr_toInt(format?.averageBitrate)
            if bitrate <> invalid and bitrate > bestBitrate
                bestBitrate = bitrate
                bestFormat = format
            end if
        end if
    end for

    return bestFormat
end function

function sabr_pickMeasuredBitrate(info as dynamic) as dynamic
    if not isValid(info) then return invalid
    if isValid(info.measuredBitrate) and info.measuredBitrate > 0 then return info.measuredBitrate
    if isValid(info.streamBitrate) and info.streamBitrate > 0 then return info.streamBitrate
    return invalid
end function

function sabr_createVideoPlaybackAbrRequest(request as object, contentType as string, sabr as object, currentFormat as object, activeFormats as object, playbackContext as object, playerTimeOverride as dynamic, videoNode as object, requestRef = invalid as dynamic) as object
    ' Create the ABR request object
    logTag = sabr_utilLogTag(contentType, requestRef)
    if not isValid(sabr.ustreamerConfig)
        m.logs.printl(log_level_Type.WARN, `${logTag} No SABR ustreamerConfig available`)
        return {}
    end if

    streamerContext = {
        "poToken": sabr.poToken,
        "playbackCookie": invalid, ' the playbackContext.lastPlaybackCookie will be set on handling the response nextRequestPolicy.playbackCookie
        "clientInfo": sabr.clientInfo,
        "sabrContexts": [],
        "unsentSabrContexts": [],
    }

    if isValid(playbackContext.lastPlaybackCookie)
        streamerContext["playbackCookie"] = playbackContext.lastPlaybackCookie
    end if

    if isValid(playbackContext.sabrContexts)
        streamerContext["sabrContexts"] = []
        for each key in playbackContext.sabrContexts
            streamerContext.sabrContexts.push(playbackContext.sabrContexts[key])
        end for
    end if

    playbackContext["lastPlayerTimeSecs"] = videoNode.position

    m.logs.printl(log_level_Type.INFO, `${logTag} streamingSegment : ${FormatJson(videoNode.streamingSegment)}`)

    bandwidthEstimate = sabr_pickMeasuredBitrate(videoNode.completedStreamInfo)
    if not isValid(bandwidthEstimate)
        bandwidthEstimate = sabr_pickMeasuredBitrate(videoNode.streamInfo)
    end if
    if not isValid(bandwidthEstimate) and isValid(videoNode.streamingSegment) and isValid(videoNode.streamingSegment.segBitrateBps)
        bandwidthEstimate = videoNode.streamingSegment.segBitrateBps
    end if
    ' if not isValid(bandwidthEstimate) and isValid(videoNode.segment) and isValid(videoNode.segment.bandwidth)
    '     bandwidthEstimate = videoNode.segment.bandwidth
    ' end if
    if not isValid(bandwidthEstimate) or bandwidthEstimate <= 0
        bandwidthEstimate = currentFormat?.bitrate ?? 0
    end if

    AUDIO_ONLY = 1
    VIDEO_ONLY = 2

    overrideMs = sabr_toInt(playerTimeOverride)
    overrideUsed = overrideMs <> invalid
    desiredPlayerTimeMs = overrideMs
    if desiredPlayerTimeMs = invalid or desiredPlayerTimeMs < 0
        desiredPlayerTimeMs = sabr_resolveFallbackPlayerTimeMs(playbackContext, currentFormat)
        overrideUsed = false
    end if
    if desiredPlayerTimeMs = invalid or desiredPlayerTimeMs < 0 then desiredPlayerTimeMs = 0

    playbackContext["lastRequestedPlayerTimeMs"] = desiredPlayerTimeMs
    playbackContext["lastPlayerTimeSecs"] = videoNode.position

    ' include the request byte range in the log
    overrideNote = overrideUsed ? " (derived from byte range)" : " (fallback)"
    m.logs.printl(log_level_Type.INFO, `${logTag} Creating SABR ABR request with playerTimeMs=${desiredPlayerTimeMs}, byteRange=${FormatJson(request.search)}, bandwidthEstimate=${bandwidthEstimate}${overrideNote}`)

    req = {
        "clientAbrState": {
            "playbackRate": videoNode.playbackSpeed ?? 1.0,
            "playerTimeMs": desiredPlayerTimeMs.toStr(),
            "clientViewportIsFlexible": false,
            "bandwidthEstimate": bandwidthEstimate.toStr(),
            "drcEnabled": currentFormat.isDrc ?? false,
            "enabledTrackTypesBitfield": isValid(currentFormat.width) ? VIDEO_ONLY : AUDIO_ONLY,
            "audioTrackId": currentFormat.audioTrackId
        },
        "bufferedRanges": [],
        "selectedFormatIds": [],
        "preferredAudioFormatIds": [ activeFormats.audioFormat ?? {} ],
        "preferredVideoFormatIds": [ activeFormats.videoFormat ?? {} ],
        "preferredSubtitleFormatIds": [],
        "videoPlaybackUstreamerConfig": sabr.ustreamerConfig,
        "streamerContext": streamerContext,
        "field1000": []
    }

    return req

end function

function sabr_resolveFallbackPlayerTimeMsInfo(playbackContext as object, format as object) as object
    info = {
        "value": 0
        "source": "default:0"
    }

    if not isValid(playbackContext) then return info

    formatKey = sabr_formatToKey(format)
    totals = playbackContext?.deliveredDurationTotals
    if IsAssociativeArray(totals) and formatKey <> "" and totals.DoesExist(formatKey)
        candidate = sabr_toInt(totals.Lookup(formatKey))
        if candidate <> invalid and candidate >= 0
            info["value"] = candidate
            info["source"] = "deliveredDurationTotals"
            return info
        end if
    end if

    previous = sabr_toInt(playbackContext?.lastRequestedPlayerTimeMs)
    if previous <> invalid and previous >= 0
        info["value"] = previous
        info["source"] = "lastRequestedPlayerTimeMs"
        return info
    end if

    estimate = sabr_toInt(playbackContext?.estimatedPlayerTimeMs)
    if estimate <> invalid and estimate >= 0
        info["value"] = estimate
        info["source"] = "estimatedPlayerTimeMs"
        return info
    end if

    lastPositionSeconds = playbackContext?.lastPlayerTimeSecs
    if isValid(lastPositionSeconds)
        positionMs = int((lastPositionSeconds ?? 0) * 1000)
        if positionMs >= 0
            info["value"] = positionMs
            info["source"] = "lastPlayerTimeSecs"
            return info
        end if
    end if

    return info
end function

function sabr_resolveFallbackPlayerTimeMs(playbackContext as object, format as object) as dynamic
    info = sabr_resolveFallbackPlayerTimeMsInfo(playbackContext, format)
    return info["value"]
end function


'     playbackContext["initializedFormats"] = initializedFormats
'     return initializedFormats
' end function

function sabr_formatToKey(format as dynamic) as string
    if not isValid(format) then return ""

    itagPart = ""
    if isValid(format.itag)
        itagPart = `${format.itag}`
    end if

    xtagsPart = ""
    if isValid(format.xtags)
        xtagsPart = `${format.xtags}`
    end if

    return `${itagPart}:${xtagsPart}`
end function

function sabr_cloneObject(value as dynamic) as dynamic
    if not isValid(value) then return invalid
    json = ""
    clone = invalid
    try
        json = FormatJson(value)
        if isValid(json) and json <> ""
            clone = ParseJson(json)
        end if
    catch e
        clone = invalid
    end try
    if not isValid(clone) then clone = value
    return clone
end function

function sabr_formatToFormatId(format as object) as object
    if not isValid(format) then return {}

    return {
        "itag": format.itag,
        "xtags": format.xtags,
        "lastModified": format.lastModified
    }
end function

' create a bogus full buffer range with max int32 values so we fake out the youtube server to think we already have all this data in the buffer
' as we don't want it (this is how we can still get either "just" video or "just" audio segments based on the player's dash requests)
function sabr_createFullBufferRange(format as object) as object
    MAX_INT32_VALUE = 2147483647
    return {
        "formatId": sabr_formatToFormatId(format),
        "durationMs": MAX_INT32_VALUE,
        "startTimeMs": "0",
        "startSegmentIndex": MAX_INT32_VALUE,
        "endSegmentIndex": MAX_INT32_VALUE,
        "timeRange": {
            "durationTicks": MAX_INT32_VALUE,
            "startTicks": "0",
            "timescale": 1000
        }
    }
end function

function sabr_buildBufferedRangeFromMetadata(originalMetadata as dynamic) as dynamic
    if not isValid(originalMetadata) then return invalid
    metadata = sabr_cloneObject(originalMetadata)
    if not isValid(metadata) then metadata = originalMetadata
    if not IsAssociativeArray(metadata) then return invalid

    sabr_normalizeSegmentTiming(metadata)

    durationMsStr = `${metadata?.durationMs ?? 0}`
    if durationMsStr = "" then durationMsStr = "0"

    startSequenceNumber = sabr_toInt(metadata?.startSequenceNumber)
    if startSequenceNumber = invalid or startSequenceNumber < 0
        startSequenceNumber = sabr_toInt(metadata?.sequenceNumber)
    end if
    if startSequenceNumber = invalid or startSequenceNumber < 0 then startSequenceNumber = 0

    endSequenceNumber = sabr_toInt(metadata?.endSequenceNumber)
    if endSequenceNumber = invalid or endSequenceNumber < startSequenceNumber
        endSequenceNumber = startSequenceNumber
    end if

    startTimeMsStr = `${metadata?.startTimeMs ?? 0}`
    if startTimeMsStr = "" then startTimeMsStr = `${metadata?.startMs ?? 0}`
    if startTimeMsStr = "" then startTimeMsStr = "0"

    timeRangeInfo = metadata?.timeRange
    timeRangeScale = sabr_toInt(timeRangeInfo?.timescale)
    if timeRangeScale = invalid or timeRangeScale <= 0 then timeRangeScale = metadata?.timescale ?? 1000
    if timeRangeScale = invalid or timeRangeScale <= 0 then timeRangeScale = 1000

    durationTicksVal = sabr_toInt(timeRangeInfo?.durationTicks)
    if durationTicksVal = invalid
        durationTicksVal = sabr_toInt(durationMsStr)
        if durationTicksVal <> invalid and timeRangeScale <> 1000
            durationTicksVal = int(durationTicksVal * timeRangeScale / 1000)
        end if
    end if
    durationTicksStr = `${durationTicksVal ?? 0}`
    if durationTicksStr = "" then durationTicksStr = durationMsStr

    startTicksVal = sabr_toInt(timeRangeInfo?.startTicks)
    if startTicksVal = invalid
        startTimeVal = sabr_toInt(startTimeMsStr)
        if startTimeVal <> invalid and timeRangeScale <> 1000
            startTicksVal = int(startTimeVal * timeRangeScale / 1000)
        else
            startTicksVal = startTimeVal
        end if
    end if
    startTicksStr = `${startTicksVal ?? 0}`
    if startTicksStr = "" then startTicksStr = startTimeMsStr

    formatted = {
        "formatId": metadata.formatId,
        "startSegmentIndex": startSequenceNumber,
        "durationMs": durationMsStr,
        "startTimeMs": startTimeMsStr,
        "endSegmentIndex": endSequenceNumber,
        "timeRange": {
            "timescale": timeRangeScale,
            "startTicks": startTicksStr,
            "durationTicks": durationTicksStr
        }
    }

    rangeStartVal = sabr_toInt(metadata?.rangeStart)
    if rangeStartVal = invalid
        rangeStartVal = sabr_toInt(metadata?.startRange)
    end if
    if rangeStartVal <> invalid then formatted["rangeStart"] = `${rangeStartVal ?? ""}`
    rangeEndVal = sabr_toInt(metadata?.rangeEnd)
    if rangeEndVal = invalid
        rangeEndVal = sabr_toInt(metadata?.endRange)
    end if
    if rangeEndVal <> invalid then formatted["rangeEnd"] = `${rangeEndVal ?? ""}`

    return formatted
end function

sub sabr_normalizeSegmentTiming(metadata as object)
    if not IsAssociativeArray(metadata) then return

    timeRange = metadata?.timeRange
    if not IsAssociativeArray(timeRange)
        timeRange = {}
    end if

    timescale = sabr_toInt(timeRange?.timescale)
    if timescale = invalid or timescale <= 0
        timescale = sabr_toInt(metadata?.timescale)
    end if
    if timescale = invalid or timescale <= 0 then timescale = 1000

    startMsVal = sabr_toInt(metadata?.startTimeMs)
    if startMsVal = invalid then startMsVal = sabr_toInt(metadata?.startMs)
    if startMsVal = invalid
        startTicks = sabr_toInt(timeRange?.startTicks)
        if startTicks <> invalid
            startMsVal = int((startTicks * 1000) / timescale)
        end if
    end if
    if startMsVal <> invalid
        metadata["startTimeMs"] = startMsVal.toStr()
        metadata["startMs"] = startMsVal.toStr()
        timeRange["startTicks"] = int((startMsVal * timescale) / 1000)
    end if

    durationMsVal = sabr_toInt(metadata?.durationMs)
    if durationMsVal = invalid or durationMsVal <= 0
        durationTicks = sabr_toInt(timeRange?.durationTicks)
        if durationTicks <> invalid and durationTicks > 0
            durationMsVal = int((durationTicks * 1000) / timescale)
        end if
    end if
    if durationMsVal = invalid or durationMsVal <= 0
        durationMsVal = sabr_segmentDurationMs(metadata)
    end if
    if durationMsVal <> invalid and durationMsVal >= 0
        metadata["durationMs"] = durationMsVal.toStr()
        timeRange["durationTicks"] = int((durationMsVal * timescale) / 1000)
    end if

    metadata["timeRange"] = timeRange
end sub

function sabr_buildResponseForPlayer(requestMetadata as object, umpResult as dynamic, currentFormat as object, requestByteRange as object, contentType as string) as object
    headers = CreateObject("roAssociativeArray")
    itagLabelForHeader = sabr_valueToLabel(currentFormat?.itag)
    if itagLabelForHeader = "" then itagLabelForHeader = `${requestMetadata?.format?.itag ?? ""}`
    if itagLabelForHeader <> ""
        headers["X-Cache-Itag"] = itagLabelForHeader
    end if

    responseBody = CreateObject("roByteArray")
    responsePath = ""
    responseOffset = 0
    responseLength = invalid
    fullBody = invalid
    fullPayloadLength = 0
    status = 204

    if isValid(umpResult)
        potentialPath = sabr_toSafeString(umpResult?.path)
        if potentialPath <> ""
            sizeVal = sabr_fsGetFileSize(potentialPath)
            if sizeVal <> invalid and sizeVal > 0
                responsePath = potentialPath
                fullPayloadLength = sizeVal
            end if
        end if

        if fullPayloadLength = 0 and isValid(umpResult.data)
            fullBody = umpResult.data
            if GetInterface(fullBody, "ifByteArray") <> invalid
                responseBody = fullBody
                fullPayloadLength = fullBody.count()
            end if
        end if

        if fullPayloadLength > 0
            mimeType = currentFormat?.mimeType
            if not isValid(mimeType) or mimeType = ""
                mimeType = contentType = "VIDEO" ? "video/mp4" : "audio/mp4"
            end if
            headers["Content-Type"] = mimeType
            headers["Accept-Ranges"] = "bytes"
            status = 200

            requestCoverage = sabr_byteRangeToCoverage(requestByteRange)
            requestedStart = requestCoverage?.rangeStart
            requestedEnd = requestCoverage?.rangeEnd

            if not isValid(requestedStart)
                startLabel = `${requestByteRange?.startRange ?? 0}`
                if startLabel = "" then startLabel = `${requestByteRange?.start ?? "0"}`
                if startLabel <> "" then requestedStart = sabr_toInt(startLabel)
            end if

            if not isValid(requestedEnd)
                endLabel = `${requestByteRange?.endRange ?? ""}`
                if endLabel = "" then endLabel = `${requestByteRange?.end ?? ""}`
                if endLabel <> "" then requestedEnd = sabr_toInt(endLabel)
            end if

            coverageStart = invalid
            coverageEnd = invalid

            if requestMetadata?.isInit = true
                coverageStart = 0
                coverageEnd = fullPayloadLength > 0 ? fullPayloadLength - 1 : -1
            end if

            resultCoverage = invalid
            if IsAssociativeArray(umpResult)
                resultCoverage = umpResult.Lookup("coverage")
                if not isValid(resultCoverage)
                    covStart = umpResult.Lookup("coverageStart")
                    covEnd = umpResult.Lookup("coverageEnd")
                    if isValid(covStart) and isValid(covEnd)
                        resultCoverage = {
                            "rangeStart": covStart
                            "rangeEnd": covEnd
                        }
                    end if
                end if
            end if
            if isValid(resultCoverage) and IsAssociativeArray(resultCoverage)
                covStartVal = resultCoverage.Lookup("rangeStart")
                if not isValid(covStartVal) then covStartVal = resultCoverage.Lookup("start")
                covEndVal = resultCoverage.Lookup("rangeEnd")
                if not isValid(covEndVal) then covEndVal = resultCoverage.Lookup("end")

                if IsString(covStartVal) then covStartVal = sabr_toInt(covStartVal)
                if IsString(covEndVal) then covEndVal = sabr_toInt(covEndVal)

                if isValid(covStartVal) then coverageStart = covStartVal
                if isValid(covEndVal) then coverageEnd = covEndVal
            end if

            metadataCoverage = sabr_byteRangeToCoverage(requestMetadata?.byteRange)
            if not isValid(coverageStart) and isValid(metadataCoverage)
                coverageStart = metadataCoverage.rangeStart
            end if
            if not isValid(coverageEnd) and isValid(metadataCoverage)
                coverageEnd = metadataCoverage.rangeEnd
            end if

            if not isValid(coverageStart) and isValid(requestedStart)
                coverageStart = requestedStart
            end if
            if isValid(coverageStart) and not isValid(coverageEnd) and fullPayloadLength > 0
                coverageEnd = coverageStart + fullPayloadLength - 1
            end if
            if isValid(coverageStart) and isValid(coverageEnd) and coverageEnd < coverageStart
                coverageEnd = invalid
            end if

            if fullPayloadLength > 0 and isValid(requestedStart)
                if not isValid(coverageStart)
                    coverageStart = requestedStart
                    if not isValid(coverageEnd)
                        coverageEnd = coverageStart + fullPayloadLength - 1
                    end if
                end if

                sliceOffset = requestedStart - coverageStart
                if sliceOffset < 0 then sliceOffset = 0

                maxIndex = fullPayloadLength - 1
                if sliceOffset <= maxIndex
                    desiredLength = invalid
                    if isValid(requestedEnd)
                        sliceEndIndex = requestedEnd - coverageStart
                        if isValid(coverageEnd)
                            maxCoverageIndex = coverageEnd - coverageStart
                            if sliceEndIndex > maxCoverageIndex
                                sliceEndIndex = maxCoverageIndex
                            end if
                        end if
                        if sliceEndIndex > maxIndex then sliceEndIndex = maxIndex
                        if sliceEndIndex < sliceOffset
                            desiredLength = 0
                        else
                            desiredLength = sliceEndIndex - sliceOffset + 1
                        end if
                    else
                        desiredLength = fullPayloadLength - sliceOffset
                    end if

                    if desiredLength = invalid then desiredLength = fullPayloadLength - sliceOffset
                    if desiredLength < 0 then desiredLength = 0
                    maxAvailable = fullPayloadLength - sliceOffset
                    if desiredLength > maxAvailable then desiredLength = maxAvailable

                    if responsePath <> ""
                        responseOffset = sliceOffset
                        responseLength = desiredLength
                    else
                        if sliceOffset <> 0 or desiredLength <> fullPayloadLength
                            sliced = CreateObject("roByteArray")
                            if desiredLength > 0
                                sliced[desiredLength - 1] = 0
                                destIndex = 0
                                limitIndex = sliceOffset + desiredLength - 1
                                for i = sliceOffset to limitIndex
                                    sliced[destIndex] = fullBody[i]
                                    destIndex = destIndex + 1
                                end for
                            end if
                            responseBody = sliced
                        end if
                    end if
                else
                    responseBody = CreateObject("roByteArray")
                    responseLength = 0
                end if
            end if

            rangeStartForHeaders = requestedStart
            if not isValid(rangeStartForHeaders)
                if isValid(coverageStart)
                    rangeStartForHeaders = coverageStart
                else
                    rangeStartForHeaders = 0
                end if
            end if

            if responsePath <> ""
                finalLength = responseLength
                if finalLength = invalid then finalLength = fullPayloadLength - responseOffset
                actualEnd = rangeStartForHeaders + finalLength - 1
            else
                finalLength = responseBody.count()
                actualEnd = rangeStartForHeaders + finalLength - 1
            end if

            if isValid(requestedEnd) and actualEnd > requestedEnd
                actualEnd = requestedEnd
            end if

            totalLengthVal = sabr_toInt(currentFormat?.contentLength)
            if not isValid(totalLengthVal)
                totalLengthVal = sabr_toInt(requestMetadata?.format?.contentLength)
            end if
            if not isValid(totalLengthVal)
                mediaHeader = requestMetadata?.streamInfo?.mediaHeader
                startRangeVal = sabr_toInt(mediaHeader?.startRange)
                if startRangeVal = invalid then startRangeVal = sabr_toInt(mediaHeader?.start)
                contentLengthVal = sabr_toInt(mediaHeader?.contentLength)
                if isValid(startRangeVal) and isValid(contentLengthVal)
                    totalLengthVal = startRangeVal + contentLengthVal
                end if
            end if
            if not isValid(totalLengthVal) and isValid(coverageEnd)
                totalLengthVal = coverageEnd + 1
            end if
            if not isValid(totalLengthVal)
                if finalLength > 0
                    totalLengthVal = actualEnd + 1
                else
                    totalLengthVal = fullPayloadLength
                end if
            end if
            if isValid(totalLengthVal) and isValid(actualEnd) and totalLengthVal <= actualEnd
                totalLengthVal = actualEnd + 1
            end if
            totalLengthStr = ""
            if isValid(totalLengthVal) then totalLengthStr = totalLengthVal.toStr()
            if totalLengthStr = "" then totalLengthStr = "*"

            if isValid(requestedStart)
                status = 206
                headers["Content-Range"] = `bytes ${rangeStartForHeaders}-${actualEnd}/${totalLengthStr}`
            end if

            headers["Content-Length"] = `${finalLength}`

            result = {
                "status": status
                "headers": headers
                "body": responseBody
            }
            if responsePath <> ""
                result["bodyPath"] = responsePath
                result["bodyOffset"] = responseOffset
                result["bodyLength"] = finalLength
            end if
            result["fullBody"] = fullBody
            return result
        end if
    end if

    if isValid(requestMetadata?.error)
        status = 500
        headers["Content-Type"] = "text/plain"
        headers["Content-Length"] = "0"
    else if isValid(requestMetadata?.streamInfo?.redirect?.url)
        status = 302
        headers["Location"] = requestMetadata.streamInfo.redirect.url
        headers["Content-Type"] = "text/plain"
        headers["Content-Length"] = "0"
    else
        headers["Content-Type"] = "text/plain"
        headers["Content-Length"] = "0"
    end if

    if headers.DoesExist("Connection") = false
        headers["Connection"] = "close"
    end if

    return {
        "status": status
        "headers": headers
        "body": responseBody
    }
end function

function sabr_buildEmptyResponseForPlayer(contentType as string, currentFormat as object) as object
    body = CreateObject("roByteArray")

    mimeType = currentFormat?.mimeType ?? ""
    if mimeType = ""
        if contentType = "VIDEO"
            mimeType = "video/mp4"
        else if contentType = "AUDIO"
            mimeType = "audio/mp4"
        else
            mimeType = "application/octet-stream"
        end if
    end if

    headers = {
        "Content-Length": "0"
        "Accept-Ranges": "bytes"
        "Cache-Control": "no-store"
        "Content-Type": mimeType
    }

    return {
        "status": 204
        "headers": headers
        "body": body
    }
end function

function sabr_fsGetFileSize(path as string) as dynamic
    if not IsString(path) or path = "" then return invalid
    fs = CreateObject("roFileSystem")
    stat = invalid
    try
        stat = fs.Stat(path)
    catch e
        stat = invalid
    end try
    if IsAssociativeArray(stat)
        sizeVal = stat.Lookup("size")
        if sizeVal = invalid then sizeVal = stat.Lookup("length")
        return sizeVal
    end if
    return invalid
end function

function sabr_buildErrorResponseForPlayer(status as integer, message as string) as object
    body = CreateObject("roByteArray")
    if isValid(message) and message <> ""
        body.FromAsciiString(message)
    end if

    headers = {
        "Content-Type": "text/plain"
        "Content-Length": body.count().toStr()
        "Connection": "close"
    }

    return {
        "status": status
        "headers": headers
        "body": body
    }
end function

sub sabr_applyStreamInfoUpdates(playbackContext as object, streamInfo as object, contentType as string, deliveredSegment = true as boolean, requestMetadataEntry = invalid as dynamic)
    if not isValid(streamInfo) then return

    sidxUpdates = streamInfo?.sidxIndexUpdates
    if IsArray(sidxUpdates)
        for each sidxUpdate in sidxUpdates
            sabr_storeSidxIndexUpdate(playbackContext, contentType, sidxUpdate)
        end for
    else if IsAssociativeArray(streamInfo?.sidxIndexUpdate)
        sabr_storeSidxIndexUpdate(playbackContext, contentType, streamInfo.sidxIndexUpdate)
    end if

    if isValid(streamInfo.nextRequestPolicy)
        playbackContext["nextRequestPolicy"] = streamInfo.nextRequestPolicy
        if isValid(streamInfo.nextRequestPolicy.playbackCookie)
            playbackContext["lastPlaybackCookie"] = PlaybackCookieEncode(streamInfo.nextRequestPolicy.playbackCookie)
        end if
        playbackContext["backoffTimeMs"] = streamInfo.nextRequestPolicy.backoffTimeMs
    end if

    if isValid(streamInfo.sabrContextSendingPolicy)
        playbackContext["sabrContextSendingPolicy"] = streamInfo.sabrContextSendingPolicy
    end if

    if isValid(streamInfo.sabrContextUpdate)
        contexts = playbackContext["sabrContexts"]
        if not isValid(contexts)
            contexts = CreateObject("roAssociativeArray")
        end if
        contextType = streamInfo.sabrContextUpdate.type
        if isValid(contextType)
            contexts.AddReplace(contextType.toStr(), streamInfo.sabrContextUpdate)
        end if
        playbackContext["sabrContexts"] = contexts
    end if

    if isValid(streamInfo.mediaHeader)
        initializedFormats = playbackContext.initializedFormats
        formatId = streamInfo.mediaHeader.formatId
        formatKey = sabr_formatToKey({ "itag": formatId?.itag, "xtags": formatId?.xtags })
        initializedFormat = {}
        if initializedFormats.DoesExist(formatKey)
            initializedFormat = initializedFormats.Lookup(formatKey)
        end if

        coverageData = streamInfo?.deliveredCoverage
        if isValid(coverageData)
            streamInfo["segmentCoverage"] = coverageData
        end if
        metadataFromHeader = sabr_mediaHeaderToSegmentMetadata(streamInfo.mediaHeader, coverageData)
        if isValid(metadataFromHeader)
            if deliveredSegment = true
                initializedFormat["lastSegmentMetadata"] = metadataFromHeader
                recentSegments = initializedFormat?.recentSegmentMetadata
                if not IsArray(recentSegments)
                    recentSegments = []
                end if
                recentSegments.push(metadataFromHeader)
                if recentSegments.count() > 6
                    trimmed = []
                    total = recentSegments.count()
                    startIndex = total - 6
                    for idx = startIndex to total - 1
                        trimmed.push(recentSegments[idx])
                    end for
                    recentSegments = trimmed
                end if
                initializedFormat["recentSegmentMetadata"] = recentSegments
                initializedFormats.AddReplace(formatKey, initializedFormat)
                playbackContext["initializedFormats"] = initializedFormats

                if streamInfo.mediaHeader.isInitSeg <> true
                    if contentType = "VIDEO"
                        playbackContext["lastVideoSegmentMetadata"] = metadataFromHeader
                    else if contentType = "AUDIO"
                        playbackContext["lastAudioSegmentMetadata"] = metadataFromHeader
                    end if
                end if

                if isValid(requestMetadataEntry?.format)
                    sabr_updateDeliveredDurationTotals(playbackContext, contentType, requestMetadataEntry.format, metadataFromHeader)
                end if
            end if
            sabr_recordSegmentMetadata(playbackContext, contentType, formatKey, metadataFromHeader)
        end if
    end if

    if isValid(streamInfo.formatInitMetadata)
        playbackContext["formatInitializationMetadata"] = streamInfo.formatInitMetadata
    end if

    if isValid(streamInfo.streamProtectionStatus)
        playbackContext["streamProtectionStatus"] = streamInfo.streamProtectionStatus
    end if

    if IsAssociativeArray(streamInfo) and streamInfo.DoesExist("deliveredCoverage")
        streamInfo.Delete("deliveredCoverage")
    end if
end sub

function sabr_getSegmentMetadataByRange(playbackContext as object, contentType as string, format as object, createIfMissing = false as boolean) as dynamic
    formatKey = sabr_formatToKey(format)
    return sabr_getSegmentMetadataByRangeKey(playbackContext, contentType, formatKey, createIfMissing)
end function

function sabr_getSegmentMetadataByRangeKey(playbackContext as object, contentType as string, formatKey as string, createIfMissing = false as boolean) as dynamic
    if not isValid(playbackContext) then return invalid
    if formatKey = "" then return invalid

    catalog = playbackContext?.segmentMetadataByRange
    if not IsAssociativeArray(catalog)
        if not createIfMissing then return invalid
        catalog = {}
    end if

    typeKey = contentType ?? ""
    if typeKey = "" then typeKey = "UNKNOWN"
    if not catalog.DoesExist(typeKey)
        if not createIfMissing then return invalid
        catalog[typeKey] = {}
    end if

    byFormat = catalog[typeKey]
    if not IsAssociativeArray(byFormat)
        if not createIfMissing then return invalid
        byFormat = {}
        catalog[typeKey] = byFormat
    end if

    if not byFormat.DoesExist(formatKey)
        if not createIfMissing then return invalid
        byFormat[formatKey] = {}
    end if

    playbackContext["segmentMetadataByRange"] = catalog
    return byFormat[formatKey]
end function

sub sabr_recordSegmentMetadata(playbackContext as object, contentType as string, formatKey as string, metadata as dynamic)
    if not isValid(metadata) then return
    startRangeVal = sabr_toInt(metadata?.startRange)
    if startRangeVal = invalid then return

    byRange = sabr_getSegmentMetadataByRangeKey(playbackContext, contentType, formatKey, true)
    if not IsAssociativeArray(byRange) then return

    byRange[startRangeVal.toStr()] = metadata
end sub

sub sabr_updateDeliveredDurationTotals(playbackContext as object, contentType as string, format as object, metadata as dynamic)
    if not isValid(playbackContext) then return
    if not isValid(format) then return
    if not isValid(metadata) then return
    if metadata?.isInitSeg = true then return

    formatKey = sabr_formatToKey(format)
    if formatKey = "" then return

    durationVal = sabr_segmentDurationMs(metadata)
    if durationVal = invalid or durationVal <= 0 then return

    tracker = playbackContext?.deliveredSegmentTracking
    if not IsAssociativeArray(tracker)
        tracker = {}
    end if

    formatTracker = tracker.Lookup(formatKey)
    if not IsAssociativeArray(formatTracker)
        formatTracker = {}
    end if

    segmentId = ""
    seqVal = sabr_toInt(metadata?.sequenceNumber)
    if seqVal <> invalid and seqVal >= 0
        segmentId = `seq:${seqVal}`
    else
        rangeLabel = sabr_valueToLabel(metadata?.rangeStart)
        if rangeLabel <> "" then segmentId = `range:${rangeLabel}`
    end if
    if segmentId = "" then segmentId = `ts:${sabr_valueToLabel(metadata?.startTimeMs)}`
    if segmentId = "" then segmentId = `id:${durationVal.toStr()}`

    if formatTracker.DoesExist(segmentId) then return

    formatTracker[segmentId] = durationVal
    tracker[formatKey] = formatTracker
    playbackContext["deliveredSegmentTracking"] = tracker

    totals = playbackContext?.deliveredDurationTotals
    if not IsAssociativeArray(totals)
        totals = {}
    end if

    currentTotal = sabr_toInt(totals.Lookup(formatKey))
    if currentTotal = invalid then currentTotal = 0
    totals[formatKey] = currentTotal + durationVal
    playbackContext["deliveredDurationTotals"] = totals

    logTag = sabr_utilLogTag(contentType, playbackContext?.requestNumber)
    m.logs.printl(log_level_Type.DEBUG, `${logTag} Recorded segment duration ${durationVal}ms for ${formatKey}; cumulative=${totals[formatKey]}`)
end sub

'         baseStart = sabr_segmentStartMs(nearestMetadata)
'         duration = sabr_segmentDurationMs(nearestMetadata)
'         if baseStart <> invalid and duration <> invalid
'             prediction = baseStart + duration
'             if prediction >= 0 then return prediction
'         end if
'     end if

'     return invalid
' end function
function sabr_chunkBufferPool() as object
    pool = m?.sabrChunkBufferPool
    if not IsArray(pool)
        pool = []
        m.sabrChunkBufferPool = pool
    end if
    return pool
end function

function sabr_acquireChunkBuffer() as object
    pool = sabr_chunkBufferPool()
    if pool.count() > 0
        buffer = pool[pool.count() - 1]
        pool.Delete(pool.count() - 1)
        return buffer
    end if
    return CreateObject("roByteArray")
end function

sub sabr_releaseChunkBuffer(buffer as dynamic)
    if GetInterface(buffer, "ifByteArray") = invalid then return
    pool = sabr_chunkBufferPool()
    limit = SABR_CHUNK_BUFFER_POOL_LIMIT
    if limit <= 0 then limit = 8
    if pool.count() >= limit then return
    pool.push(buffer)
end sub
