import "pkg:/source/ytproto/generated/runtime.brs"
import "pkg:/source/ytproto/generated/messages/VideoPlaybackAbrRequest.brs"
import "pkg:/source/ytproto/generated/messages/ClientAbrState.brs"
import "pkg:/source/ytproto/generated/messages/FormatId.brs"
import "pkg:/source/ytproto/generated/messages/StreamerContext.brs"
import "pkg:/source/ytproto/generated/messages/ClientInfo.brs"
import "pkg:/source/ytproto/generated/messages/TimeRange.brs"
import "pkg:/source/ytproto/generated/messages/BufferedRange.brs"
import "pkg:/source/ytproto/generated/messages/StreamerContext.brs"
import "pkg:/source/ytproto/generated/messages/SabrContext.brs"
import "pkg:/source/ytproto/generated/messages/GLDeviceInfo.brs"
import "pkg:/source/ytproto/generated/messages/MediaCapabilities.brs"
import "pkg:/source/ytproto/generated/messages/VideoFormatCapability.brs"
import "pkg:/source/ytproto/generated/messages/AudioFormatCapability.brs"
import "pkg:/source/ytproto/generated/messages/PlaybackAuthorization.brs"
import "pkg:/source/ytproto/generated/messages/AuthorizedFormat.brs"
import "pkg:/source/ytproto/generated/messages/Range.brs"
import "pkg:/source/ytproto/generated/messages/PlaybackCookie.brs"
import "pkg:/source/ytproto/generated/messages/UnknownInnerMessage.brs"
import "pkg:/source/ytproto/generated/messages/UnknownInnerMessage1.brs"
import "pkg:/source/ytproto/generated/messages/UnknownMessage3.brs"
import "pkg:/source/ytproto/generated/messages/VideoStreamingBufferedRangeUnknownMessage1.brs"
import "pkg:/source/ytproto/generated/messages/VideoStreamingBufferedRangeUnknownMessage2.brs"
import "pkg:/source/ytproto/generated/messages/VideoStreamingStreamerContextUnknownMessage1.brs"
import "pkg:/source/ytproto/generated/messages/VideoStreamingUnknownMessage1.brs"
import "pkg:/source/ytproto/generated/messages/VideoStreamingUnknownMessage2.brs"
import "pkg:/source/SabrUmpProcessor.bs"
import "pkg:/source/SabrRequestMetadataManager.bs"
import "pkg:/source/isItem.bs"
import "pkg:/source/httpRequest.bs"
import "pkg:/source/SabrDebug.bs"
import "pkg:/source/SabrUtils.bs"
import "pkg:/source/taskUtils.bs"

' Time window (ms) for repeat guard to track duplicate requests.
const SABR_REPEAT_SEGMENT_WINDOW_MS = 5000

' Fixed bandwidth (bps) to report to SABR when non-zero; otherwise we rely on measurements.
const SABR_BANDWIDTH_OVERRIDE_BPS = 0

' Scale measured bandwidth by this factor when no override is provided.
const SABR_BANDWIDTH_MULTIPLIER = 1.0 ' i.e. 1.5

' Default fallback amount (ms) to bump playerTimeMs beyond the segment start to avoid repeat coverage.
const SABR_PLAYER_TIME_DEFAULT_BUMP_MS = 2000

'------------------------------------------------------------------------------
' Function : sabr_handleRequest
' Purpose  : Coordinates lookup, SABR request generation, UMP decoding, and
'            response assembly for a player segment request, including repeat
'            detection, buffered-state updates, and spool streaming.
'------------------------------------------------------------------------------
function sabr_handleRequest(request as object, contentType as string, mediaIdHash as string, sabr as object, videoNode as object, queuedAtMs = invalid as dynamic, redirectDepth = 0 as integer) as object
    ok = true

    sabrAbrUrl = ""
    playbackContext = invalid
    response = invalid
    requestTimer = invalid
    requestLogTag = `[YTSABR-${contentType}]`
    if isValid(m?.logs)
        requestTimer = m.logs.mark()
    end if
    requestStartMs = sabr_currentTimestampMs()
    timingInfo = CreateObject("roAssociativeArray")
    timingInfo["requestStartMs"] = requestStartMs
    queuedAtValue = sabr_toInt(queuedAtMs)
    if queuedAtValue <> invalid
        timingInfo["queuedAtMs"] = queuedAtValue
    end if

    ' Load playback context for media and validate cached metadata from tmp:/${mediaIdHash}/playbackContext.json
    playbackContextPath = `tmp:/${mediaIdHash}/playbackContext.json`
    fileContent = getFile(playbackContextPath)
    if fileContent = invalid or fileContent = ""
        sabr_log(m.logs, log_level_Type.WARN, `[YTSABR-Util-${contentType}] No SABR playbackContext file found for mediaIdHash: ${mediaIdHash}`, false)
    else
        parsedOk = true
        try
            playbackContext = ParseJson(fileContent)
        catch e
            parsedOk = false
            detail = sabr_formatExceptionDetail(e)
            snippet = fileContent.left(256)
            sabr_log(m.logs, log_level_Type.WARN, `[YTSABR-Util-${contentType}] Failed to parse playbackContext (${playbackContextPath}): ${detail}`, false)
            sabr_log(m.logs, log_level_Type.DEBUG, `[YTSABR-Util-${contentType}] playbackContext snippet: ${snippet}`, true)
        end try
        if parsedOk = false or not IsAssociativeArray(playbackContext)
            playbackContext = invalid
            sabr_log(m.logs, log_level_Type.WARN, `[YTSABR-Util-${contentType}] Invalid SABR playbackContext file for mediaIdHash: ${mediaIdHash}; rebuilding`, false)
        else
            sabr_log(m.logs, log_level_Type.INFO, `[YTSABR-Util-${contentType}] Loaded SABR playbackContext from file for mediaIdHash: ${mediaIdHash}`)
        end if
    end if

    if not IsAssociativeArray(playbackContext)
        playbackContext = CreateObject("roAssociativeArray")
        playbackContext["mediaIdHash"] = mediaIdHash
        sabr_log(m.logs, log_level_Type.WARN, `[YTSABR-Util-${contentType}] No valid SABR playback context available; initialized empty context`, false)
    else if not playbackContext.DoesExist("mediaIdHash")
        playbackContext["mediaIdHash"] = mediaIdHash
    end if

    fatalInfo = playbackContext?.sabrFatalError
    if isValid(fatalInfo)
        fatalReason = fatalInfo?.reason ?? "SABR fatal error"
        sabr_log(m.logs, log_level_Type.WARN, `[YTSABR-Util-${contentType}] Blocking SABR request due to fatal error: ${fatalReason}`, false)
        return sabr_buildErrorResponseForPlayer(502, fatalReason)
    end if

    ' Ensure cache/task infrastructure exists before handling segments
    sabr_ensureInfrastructure()
    metadataManager = m.sabrRequestMetadataManager
    debugUploadUrl = m.top.debugUploadUrl ?? ""

    formats = sabr?.adaptiveFormats
    if not isValid(formats) or formats.count() = 0
        formats = sabr?.hlsFormats
        if not isValid(formats) or formats.count() = 0
            ok = false
            sabr_log(m.logs, log_level_Type.WARN, `[YTSABR-Util-${contentType}] No SABR formats available`, false)
        end if
    end if

    sabrAbrUrl = sabr?.serverAbrStreamingUrl
    if not isValid(sabrAbrUrl) or sabrAbrUrl = ""
        ok = false
        sabr_log(m.logs, log_level_Type.WARN, `[YTSABR-Util-${contentType}] No SABR URL provided`, false)
    end if

    ' Assign a unique request number and patch SABR URL
    ' nextRequestId = generateSabrRequestNumber(playbackContext, contentType)
    nextRequestId = m.top.utilsTask.callFunc("getNextId", "sabrRequestNumber")
    playbackContext["requestNumber"] = nextRequestId
    requestLogTag = sabr_utilLogTag(contentType, nextRequestId)
    sabr_log(m.logs, log_level_Type.INFO, `${requestLogTag} SABR playback request number: ${nextRequestId}`)

    ' Update SABR URL with request number token param (or create it) to be the request number
    regexRn = CreateObject("roRegex", "([&?])rn=[^&]*", "i")
    if regexRn.match(sabrAbrUrl).count() > 0
        sabrAbrUrl = regexRn.replaceAll(sabrAbrUrl, `\1rn=${nextRequestId}`)
    else
        sep = sabrAbrUrl.inStr("?") > -1 ? "&" : "?"
        sabrAbrUrl = `${sabrAbrUrl}${sep}rn=${nextRequestId}`
    end if
    sabr_log(m.logs, log_level_Type.INFO, `${requestLogTag} URL: ${sabrAbrUrl}`)

    ' Resolve requested format from query params

    keyParam = request.search.key
    try
        if not isValid(keyParam) or keyParam = ""
            ok = false
            sabr_log(m.logs, log_level_Type.WARN, `${requestLogTag} No SABR itag key provided`, false)
        else
            keyParts = keyParam.split(":")
            currentKeyItag = sabr_toInt(keyParts[0])
            currentKeyXTag = keyParts.count() > 1 ? keyParts[1] : ""
            currentFormat = invalid
            for each format in formats
                if format.itag = currentKeyItag and (format?.xTag ?? "") = currentKeyXTag
                    currentFormat = format
                    exit for
                end if
            end for
        end if
    catch e
        ok = false
        sabr_log(m.logs, log_level_Type.WARN, `${requestLogTag} Error finding format for itag: ${keyParam} - ${e.message}`, false)
    end try

    if not isValid(currentFormat)
        ok = false
        sabr_log(m.logs, log_level_Type.WARN, `${requestLogTag} No matching format for itag: ${keyParam}`, false)
    end if

    activeFormats = sabr_getActiveFormats(currentFormat, sabr, playbackContext)

    ' Normalize requested byte range for downstream lookups
    requestByteRange = sabr_getHeaderByteRange(request)
    requestByteRange = sabr_normalizeByteRange(requestByteRange, {
        "mediaIdHash": mediaIdHash
        "contentType": contentType
        "format": currentFormat
    })
    ' Log normalized range for diagnostics
    sabr_log(m.logs, log_level_Type.DEBUG, `${requestLogTag} Normalized byteRange start=${requestByteRange?.startRange ?? ""} end=${requestByteRange?.endRange ?? ""} seq=${requestByteRange?.sequenceNumber ?? ""}`)
    isInitSegmentRequest = sabr_isInit(contentType, currentFormat, requestByteRange, nextRequestId)

    formatKeyForLog = sabr_formatToKey(currentFormat)
    sabr_log(m.logs, log_level_Type.DEBUG, `${requestLogTag} Resolving segment start; init=${isInitSegmentRequest} formatKey=${formatKeyForLog}`)

    cachedSpoolSegment = invalid
    ' spoolKey = `${requestByteRange?.startRange}:${keyParam}`
    cachedSegment = sabr_findSpoolSegmentInCache(playbackContext, requestByteRange, keyParam)
    if IsAssociativeArray(cachedSegment)
        spooledSegment = cachedSegment.spooledSegment
        spoolKey = cachedSegment.spoolKey
        coverageStartVal = sabr_toInt(spooledSegment?.startRange)
        coverageEndVal = sabr_toInt(spooledSegment?.endRange)
        sabr_log(m.logs, log_level_Type.DEBUG, `${requestLogTag} Spool map hit key=${spoolKey} isInitSeg=${spooledSegment.isInitSeg} requestRange=${requestByteRange?.startRange}-${requestByteRange?.endRange} coverage=${coverageStartVal}-${coverageEndVal}`)
        if coverageEndVal <> sabr_toInt(requestByteRange?.endRange) and not spooledSegment.isInitSeg
            sabr_log(m.logs, log_level_Type.WARN, `${requestLogTag} Spool map miss key=${spoolKey} requestRange=${requestByteRange?.startRange}-${requestByteRange?.endRange}`)
        else
            ' immediately stream this identified spooled segment to the player through the socket
            chunks = spooledSegment?.chunks
            totalBytes = sabr_toInt(spooledSegment?.totalBytes)
            if totalBytes = invalid
                totalBytes = 0
                if IsArray(chunks)
                    for each chunk in chunks
                        chunkLen = sabr_toInt(chunk?.length)
                        if chunkLen <> invalid then totalBytes = totalBytes + chunkLen
                    end for
                end if
            end if
            if spooledSegment?.isInitSeg = true
                trimmed = sabr_trimSegmentChunksForRange(chunks, spooledSegment?.startRange, requestByteRange)
                if IsAssociativeArray(trimmed)
                    trimmedChunks = trimmed?.chunks
                    trimmedBytes = sabr_toInt(trimmed?.totalBytes)
                    if IsArray(trimmedChunks) and trimmedChunks.count() > 0 and trimmedBytes <> invalid and trimmedBytes > 0
                        chunks = trimmedChunks
                        totalBytes = trimmedBytes
                    end if
                end if
            end if
            coverageInfo = CreateObject("roAssociativeArray")
            if coverageStartVal <> invalid then coverageInfo["rangeStart"] = coverageStartVal
            if coverageEndVal <> invalid then coverageInfo["rangeEnd"] = coverageEndVal

            spoolResponse = {
                "path": spooledSegment.path
                "chunks": chunks
                "totalBytes": totalBytes
            }
            if spooledSegment?.isInitSeg = true
                spoolResponse["isInitSeg"] = true
            end if
            if coverageInfo.Count() > 0
                spoolResponse["coverage"] = coverageInfo
            end if

            cacheRequestMetadata = {
                "format": currentFormat
                "byteRange": requestByteRange
            }
            responseForPlayer = sabr_buildResponseForPlayer(cacheRequestMetadata, spoolResponse, currentFormat, requestByteRange, contentType)
            sabr_log(m.logs, log_level_Type.INFO, `${requestLogTag} Serving spooled segment to player key=${spoolKey} requestByteRange=${formatJson(requestByteRange)} isInitSeg=${spooledSegment.isInitSeg}`)
            sabr_log(m.logs, log_level_Type.INFO, `${requestLogTag} Serving spooled segment to player key=${spoolKey} chunkCount=${IsArray(chunks) ? chunks.count() : 0} totalBytes=${totalBytes}`)
            return responseForPlayer
        end if
    else
        sabr_log(m.logs, log_level_Type.DEBUG, `${requestLogTag} No cached spool map for lookup keys key=${sabr_valueToLabel(keyParam)} requestRange=${requestByteRange?.startRange}-${requestByteRange?.endRange}`)
    end if

    bufferState = sabr_buildBufferedState(mediaIdHash, currentFormat, activeFormats, playbackContext, contentType, requestByteRange)

    playerTimeInfo = sabr_resolvePlayerTimeMsForRequest(playbackContext, contentType, currentFormat, requestByteRange, videoNode)
    previousResolvedPlayerTime = sabr_toInt(playbackContext?.lastResolvedPlayerTimeMs)
    previousRequestedPlayerTime = sabr_toInt(playbackContext?.lastRequestedPlayerTimeMs)
    previousMaxResolvedPlayerTime = sabr_toInt(playbackContext?.maxResolvedPlayerTimeMs)
    storedPruneThresholdMs = sabr_toInt(playbackContext?.bufferPruneThresholdMs)
    toleranceMs = 1000

    ' Resolve player-time prediction and update context
    playerTimeOverride = sabr_toInt(playerTimeInfo?.value)
    if playerTimeOverride = invalid or playerTimeOverride < 0
        playerTimeOverride = 0
    end if
    playerTimeSourceLabel = `${playerTimeInfo?.source ?? "unknown"}`
    segmentStartMs = sabr_toInt(playerTimeInfo?.segmentStartMs)
    segmentDurationMs = sabr_toInt(playerTimeInfo?.segmentDurationMs)
    if segmentStartMs <> invalid
        if playerTimeOverride < segmentStartMs
            playerTimeOverride = segmentStartMs
        end if
        fudgeMs = 1
        if segmentDurationMs <> invalid and segmentDurationMs > 0
            fudgeMs = Int(segmentDurationMs / 100)
            if fudgeMs < 1 then fudgeMs = 1
            if fudgeMs > 50 then fudgeMs = 50
        end if
        candidateOverride = playerTimeOverride
        if candidateOverride <= segmentStartMs
            candidateOverride = segmentStartMs + fudgeMs
            if segmentDurationMs <> invalid and segmentDurationMs > 0
                maxAllowed = segmentStartMs + segmentDurationMs
                if candidateOverride > maxAllowed then candidateOverride = maxAllowed
            end if
        end if
        if candidateOverride > playerTimeOverride
            sabr_log(m.logs, log_level_Type.DEBUG, `${requestLogTag} PlayerTime cheat bump start=${segmentStartMs} duration=${segmentDurationMs} bump=${candidateOverride - playerTimeOverride}`)
            playerTimeOverride = candidateOverride
        end if
    end if
    defaultBumpMs = SABR_PLAYER_TIME_DEFAULT_BUMP_MS
    if segmentDurationMs <> invalid and segmentDurationMs > 0
        computedBump = Int(segmentDurationMs / 2)
        if computedBump <= 0 then computedBump = SABR_PLAYER_TIME_DEFAULT_BUMP_MS
        defaultBumpMs = computedBump
    end if
    if defaultBumpMs > 0
        targetOverride = playerTimeOverride + defaultBumpMs
        if segmentStartMs <> invalid and segmentDurationMs <> invalid and segmentDurationMs > 0
            maxAllowedOverride = segmentStartMs + segmentDurationMs
            if targetOverride > maxAllowedOverride then targetOverride = maxAllowedOverride
        end if
        if targetOverride > playerTimeOverride
            sabr_log(m.logs, log_level_Type.DEBUG, `${requestLogTag} PlayerTime default bump applied value=${playerTimeOverride} -> ${targetOverride}`)
            playerTimeOverride = targetOverride
        end if
    end if
    playbackContext["lastResolvedPlayerTimeMs"] = playerTimeOverride
    playbackContext["lastResolvedPlayerTimeSource"] = playerTimeSourceLabel

    sabr_log(m.logs, log_level_Type.DEBUG, `${requestLogTag} Resolved playerTimeMs=${playerTimeOverride} source=${playerTimeSourceLabel}`)
    rangeLabelForLog = sabr_formatRequestedRangeForPath(requestByteRange)
    sabr_log(m.logs, log_level_Type.DEBUG, `${requestLogTag} Using playerTimeMs=${playerTimeOverride} for range ${rangeLabelForLog}`)

    seekBackDetected = false
    if playerTimeOverride <> invalid
        if previousResolvedPlayerTime <> invalid and playerTimeOverride + toleranceMs < previousResolvedPlayerTime
            seekBackDetected = true
        else if previousRequestedPlayerTime <> invalid and playerTimeOverride + toleranceMs < previousRequestedPlayerTime
            seekBackDetected = true
        else if previousMaxResolvedPlayerTime <> invalid and playerTimeOverride + toleranceMs < previousMaxResolvedPlayerTime
            seekBackDetected = true
        end if
    end if

    newMaxResolvedPlayerTime = previousMaxResolvedPlayerTime
    if playerTimeOverride <> invalid
        if newMaxResolvedPlayerTime = invalid or playerTimeOverride > newMaxResolvedPlayerTime or seekBackDetected
            newMaxResolvedPlayerTime = playerTimeOverride
        end if
        playbackContext["maxResolvedPlayerTimeMs"] = newMaxResolvedPlayerTime
    end if

    ' Work out requested segment indices/timing for logging
    targetSegmentIndex = invalid
    segmentIndexInfo = requestByteRange?.segmentIndexInfo
    if IsAssociativeArray(segmentIndexInfo)
        targetSegmentIndex = sabr_toInt(segmentIndexInfo?.segmentIndex)
        if targetSegmentIndex = invalid
            targetSegmentIndex = sabr_toInt(segmentIndexInfo?.sequenceNumber)
        end if
        if targetSegmentIndex = invalid
            targetSegmentIndex = sabr_toInt(segmentIndexInfo?.startSegmentIndex)
        end if
    end if
    if targetSegmentIndex = invalid
        targetSegmentIndex = sabr_toInt(requestByteRange?.sequenceNumber)
    end if

    ' Track buffer prune thresholds to help repeat guard
    pruneCutoffMs = storedPruneThresholdMs
    if playerTimeOverride <> invalid
        if pruneCutoffMs = invalid or playerTimeOverride < pruneCutoffMs
            pruneCutoffMs = playerTimeOverride
        end if
    end if

    if seekBackDetected and playerTimeOverride <> invalid
        pruneCutoffMs = playerTimeOverride
        playbackContext["bufferPruneThresholdMs"] = playerTimeOverride
    else if storedPruneThresholdMs <> invalid and playerTimeOverride <> invalid and playerTimeOverride > storedPruneThresholdMs + toleranceMs
        playbackContext.Delete("bufferPruneThresholdMs")
        pruneCutoffMs = playerTimeOverride
    end if

    pruneRangeStart = sabr_toInt(requestByteRange?.startRange)
    if pruneRangeStart = invalid then pruneRangeStart = sabr_toInt(requestByteRange?.start)

    if pruneCutoffMs <> invalid or targetSegmentIndex <> invalid
        sabr_pruneBufferedRangesForSeekBack(bufferState, contentType, targetSegmentIndex, pruneCutoffMs, requestLogTag)
    else if seekBackDetected and isValid(m?.logs)
        sabr_log(m.logs, log_level_Type.DEBUG, `${requestLogTag} Seek-back detected but no pruning constraints available`)
    end if

    sabrRequestJson = sabr_createVideoPlaybackAbrRequest(request, contentType, sabr, currentFormat, activeFormats, playbackContext, playerTimeOverride, videoNode, nextRequestId)

    if isValid(currentFormat.height)
        sabrRequestJson.clientAbrState["stickyResolution"] = currentFormat.height
        sabrRequestJson.clientAbrState["lastManualSelectedResolution"] = currentFormat.height
    end if

    formatToDiscard = sabr_applyBufferedStateToRequest(sabrRequestJson, bufferState)

    if isValid(formatToDiscard)
        ' the formatToDiscard is the one that we are faking out the youtube server to "not" send us any data.
        ' in this way, if this is a video request, we can get the video segment data but not the audio and vice versa
        ' Sabr wants to send us both audio and video segments in the same response, but we only want one or the other
        sabrRequestJson.selectedFormatIds.push(formatToDiscard)
    end if

    sabr_logBufferedRanges(requestLogTag, sabrRequestJson)

    requestMetadataEntry = {
        "requestNumber": nextRequestId
        "isInit": isInitSegmentRequest
        "byteRange": {
            "start": requestByteRange.startRange
            "end": requestByteRange.endRange
            "startRange": requestByteRange.startRange
            "endRange": requestByteRange.endRange
            "sequenceNumber": requestByteRange.DoesExist("sequenceNumber") ? requestByteRange.sequenceNumber : invalid
            "segmentIndexInfo": requestByteRange.DoesExist("segmentIndexInfo") ? requestByteRange.segmentIndexInfo : invalid
        }
        "format": currentFormat
        "contentType": contentType
        "mediaIdHash": mediaIdHash
        "streamInfo": {}
        "timestamp": sabr_currentTimestampMs()
        "debugUploadUrl": debugUploadUrl
        "sabrKey": keyParam
        "requestPath": request.path
    }
    if queuedAtValue <> invalid
        requestMetadataEntry["queuedAtMs"] = queuedAtValue
    end if
    requestMetadataEntry["requestStartMs"] = requestStartMs
    if requestByteRange.DoesExist("segmentIndexInfo")
        requestMetadataEntry["segmentIndexInfo"] = requestByteRange.segmentIndexInfo
    end if
    if requestByteRange.DoesExist("sequenceNumber")
        requestMetadataEntry["sequenceNumber"] = sabr_toInt(requestByteRange.sequenceNumber)
    end if
    if isValid(metadataManager)
        metadataManager.store(metadataManager, `${nextRequestId}`, requestMetadataEntry)
    end if

    sabr_debugLogRepeatState(contentType, nextRequestId, playbackContext, "pre_guard", `range=${rangeLabelForLog}`)

    repeatGuardResponse = sabr_guardRepeatedRequests(playbackContext, contentType, currentFormat, requestMetadataEntry, `${nextRequestId}`, videoNode, mediaIdHash)
    if isValid(repeatGuardResponse)
        return repeatGuardResponse
    end if

    batchCounter = m.top.utilsTask.callFunc("getNextId", "sabrBatchCounter")
    playbackContext["lastDumpIndex"] = batchCounter
    requestMetadataEntry["batchIndex"] = batchCounter

    ' Build and send SABR request when cache misses
    if ok
        if not isInitSegmentRequest and isValid(currentFormat)
            sabrRequestJson.selectedFormatIds.push(currentFormat)
        end if

        if isValid(m?.logs)
            selectedSummary = ""
            if IsArray(sabrRequestJson?.selectedFormatIds) and sabrRequestJson.selectedFormatIds.count() > 0
                try
                    selectedSummary = FormatJson(sabrRequestJson.selectedFormatIds)
                catch e
                    selectedSummary = "<FormatJson error>"
                end try
            end if
            if selectedSummary <> ""
                sabr_log(m.logs, log_level_Type.DEBUG, `${requestLogTag} selectedFormatIdsJson=${selectedSummary}`)
            end if
        end if

        playbackContext["lastSabrRequest"] = sabrRequestJson
        ' Optionally upload debug artifacts for the response
        if debugUploadUrl <> ""
            requestPayloadJson = FormatJson(sabrRequestJson)
            if isValid(requestPayloadJson) and requestPayloadJson <> ""
                rangeLabel = sabr_formatRequestedRangeForPath(requestMetadataEntry.byteRange)
                dumpCounter = invalid
                if isValid(m.top?.utilsTask)
                    dumpCounter = m.top.utilsTask.callFunc("getNextId", "sabrDumpCounterBatch")
                end if
                dumpLabel = sabr_debugBuildDumpLabel(playbackContext, "sabr-request", `${nextRequestId}`, rangeLabel, contentType, currentFormat, dumpCounter)
                debugFolder = LCase(contentType) = "audio" ? "audio" : "video"
                spoolMaps = playbackContext?.umpSpoolMaps
                if IsAssociativeArray(spoolMaps) and spoolMaps.Count() > 0
                    spoolJson = ""
                    try
                        spoolJson = FormatJson(spoolMaps)
                    catch err
                        spoolJson = "<FormatJson error>"
                    end try
                    if spoolJson <> ""
                        sabr_debugUploadText(debugUploadUrl, `${debugFolder}/${dumpLabel}-spool.json`, spoolJson, m.logs)
                    end if
                end if
                sabr_debugUploadText(debugUploadUrl, `${debugFolder}/${dumpLabel}.json`, requestPayloadJson, m.logs)
            end if
        end if
        encodedProto = ""
        protoBytes = invalid
        protoFilePath = ""
        responseFilePath = ""
        encodeTimer = invalid
        if isValid(m?.logs)
            encodeTimer = m.logs.mark()
        end if
        try
            sabr_log(m.logs, log_level_Type.INFO, `${requestLogTag} Encoding SABR proto for itag: ${currentFormat.itag}`)
            encodedProto = VideoPlaybackAbrRequestEncode(sabrRequestJson)
            if IsString(encodedProto) and encodedProto <> ""
                protoBytes = CreateObject("roByteArray")
                protoBytes.FromBase64String(encodedProto)
                if debugUploadUrl <> ""
                    ' sanity check on the decode
                    decodedProto = VideoPlaybackAbrRequestDecode(encodedProto)
                    if not isValid(decodedProto)
                        ok = false
                        sabr_log(m.logs, log_level_Type.WARN, `${requestLogTag} Error decoding SABR proto after encode`, false)
                    else
                        requestPayloadJson = FormatJson(decodedProto)
                        if isValid(requestPayloadJson) and requestPayloadJson <> ""
                            rangeLabelDecode = sabr_formatRequestedRangeForPath(requestMetadataEntry.byteRange)
                            dumpCounterDecode = invalid
                            if isValid(m.top?.utilsTask)
                                dumpCounterDecode = m.top.utilsTask.callFunc("getNextId", "sabrDumpCounterBatch")
                            end if
                            dumpLabel = sabr_debugBuildDumpLabel(playbackContext, "sabr-request-decode", `${nextRequestId}`, rangeLabelDecode, contentType, currentFormat, dumpCounterDecode)
                            debugFolder = LCase(contentType) = "audio" ? "audio" : "video"
                            sabr_debugUploadText(debugUploadUrl, `${debugFolder}/${dumpLabel}.json`, requestPayloadJson, m.logs)
                        end if
                    end if
                end if
            end if
        catch e
            ok = false
            sabr_log(m.logs, log_level_Type.WARN, `${requestLogTag} Error encoding SABR proto: ${e.message}`, false)
        end try
        if encodeTimer <> invalid
            m.logs.printTime(log_level_Type.INFO, `${requestLogTag} Proto encode duration`, encodeTimer, -1)
        end if

        ' prepare the SABR request now
        if ok and IsValid(protoBytes)
            sabr_log(m.logs, log_level_Type.INFO, `${requestLogTag} proto payload`)

            shouldSendSabr = false
            if contentType = "VIDEO"
                shouldSendSabr = true
            else if playbackContext.hasVideoParts = true
                shouldSendSabr = true
            end if

            hasVideoPartsFlag = false
            if playbackContext?.hasVideoParts = true then hasVideoPartsFlag = true
            sabr_log(m.logs, log_level_Type.DEBUG, `${requestLogTag} SABR send decision contentType=${contentType} type=${Type(contentType)} hasVideoParts=${hasVideoPartsFlag} shouldSend=${shouldSendSabr}`)

            if shouldSendSabr
                sabr_log(m.logs, log_level_Type.INFO, `${requestLogTag} Sending SABR request to URL: ${sabrAbrUrl}`)
                ' write the protoBytes to a file and send that file to the SABR URL
                keyLabelForDump = sabr_sanitizeForFilename(sabr_toSafeString(keyParam))
                if keyLabelForDump = "" then keyLabelForDump = "nokey"
                protoFilePath = `tmp:/${mediaIdHash}/sabrRequest-${contentType}-${keyLabelForDump}-${nextRequestId}.bin`
                protoBytes.writeFile(protoFilePath)
                sabrRequest = {
                    "url": sabrAbrUrl,
                    "requestType": "proxy",
                    "timeout": 10000,
                    "options": {
                        "method": "POST_FILE_TO_FILE_WITH_DECODINGS",
                        "body": protoFilePath
                    }
                }

                sabr_log(m.logs, log_level_Type.INFO, `[RELAY] Performing proxied request to: ${FormatJson(sabrAbrUrl)}`)
                requestSpan = invalid
                if isValid(m?.logs)
                    requestSpan = m.logs.mark()
                end if
                res = makeRequest(sabrRequest)
                if requestSpan <> invalid
                    m.logs.printTime(log_level_Type.INFO, `${requestLogTag} SABR proxy round-trip`, requestSpan, -1)
                end if
                if not isValid(res?.status)
                    ok = false
                    sabr_log(m.logs, log_level_Type.WARN, `${requestLogTag} No response status from SABR UMP request`, false)
                    response = sabr_buildErrorResponseForPlayer(500, "SABR request failed")
                else if res.status >= 200 and res?.status <= 206
                    responseFilePath = res.body
                    fatalReason = ""
                    segmentInfo = invalid
                    umpResult = invalid
                    segmentScanSummary = invalid
                    spoolResultForResponse = invalid
                    requestMetadata = {
                        "isUMP": true
                        "isSABR": true
                        "isInit": isInitSegmentRequest
                        "requestNumber": nextRequestId
                        "format": currentFormat
                        "streamInfo": {}
                        "debugUploadUrl": debugUploadUrl
                        "mediaIdHash": mediaIdHash
                        "contentType": contentType
                        "umpMode": "target"
                    }
                    if IsAssociativeArray(requestMetadataEntry.byteRange)
                        requestMetadata["byteRange"] = requestMetadataEntry.byteRange
                    end if

                    if isValid(responseFilePath) and responseFilePath <> ""
                        spoolMap = sabr_ump_buildSpoolPartMap(responseFilePath, 16, keyParam)
                        sabr_logSpoolSummary(m.logs, requestLogTag, spoolMap)
                        if IsAssociativeArray(spoolMap) and (spoolMap?.error ?? "") = ""
                            if not IsAssociativeArray(playbackContext["umpSpoolMaps"]) then playbackContext["umpSpoolMaps"] = {}
                            segmentIndex = spoolMap?.segmentIndex
                            if IsAssociativeArray(segmentIndex)
                                for each segmentKey in segmentIndex.Keys()
                                    entry = segmentIndex.Lookup(segmentKey)
                                    playbackContext["umpSpoolMaps"][segmentKey] = entry
                                    sidxUpdate = entry?.sidxIndex
                                    if IsAssociativeArray(sidxUpdate)
                                        sabr_storeSidxIndexUpdate(playbackContext, contentType, sidxUpdate)
                                    end if
                                end for
                            end if

                            if IsAssociativeArray(segmentIndex)
                                cacheKeyBase = `${contentType}|${sabr_toSafeString(keyParam)}`
                                if not IsAssociativeArray(playbackContext?.initSegments)
                                    playbackContext["initSegments"] = {}
                                end if
                                initCache = playbackContext.initSegments
                                for each segKey in segmentIndex.Keys()
                                    segEntry = segmentIndex.Lookup(segKey)
                                    if IsAssociativeArray(segEntry) and segEntry?.isInitSeg = true
                                        initPath = sabr_ump_materializeInitSegment(segEntry, responseFilePath, mediaIdHash, contentType, keyParam)
                                        if IsString(initPath) and initPath <> ""
                                            initCache[cacheKeyBase] = initPath
                                        end if
                                    end if
                                end for
                                playbackContext.initSegments = initCache
                            end if
                        end if

                        spoolFetch = sabr_findSpoolSegmentInCache(playbackContext, requestByteRange, keyParam)
                        if IsAssociativeArray(spoolFetch)
                            initPath = sabr_toSafeString(spoolFetch?.initPath)
                            spoolSegment = spoolFetch.spooledSegment
                            spoolChunks = spoolSegment?.chunks
                            if initPath <> ""
                                totalBytesForResponse = http_getFileSize(initPath)
                                if totalBytesForResponse = invalid then totalBytesForResponse = 0
                                coverageInfo = sabr_byteRangeToCoverage(requestByteRange)
                                spoolResultForResponse = {
                                    "path": initPath
                                    "chunks": []
                                    "totalBytes": totalBytesForResponse
                                    "coverage": coverageInfo
                                    "isInitSeg": true
                                }
                            else if IsArray(spoolChunks) and spoolChunks.count() > 0
                                totalBytesForResponse = sabr_toInt(spoolSegment?.totalBytes)
                                if spoolSegment?.isInitSeg = true
                                    trimmed = sabr_trimSegmentChunksForRange(spoolChunks, spoolSegment?.startRange, requestByteRange)
                                    if IsAssociativeArray(trimmed)
                                        trimmedChunks = trimmed?.chunks
                                        trimmedBytes = sabr_toInt(trimmed?.totalBytes)
                                        if IsArray(trimmedChunks) and trimmedChunks.count() > 0
                                            spoolChunks = trimmedChunks
                                            if trimmedBytes <> invalid then totalBytesForResponse = trimmedBytes
                                        end if
                                    end if
                                end if
                                if totalBytesForResponse = invalid or totalBytesForResponse <= 0
                                    totalBytesForResponse = 0
                                    for each chunkEntry in spoolChunks
                                        lenVal = sabr_toInt(chunkEntry?.length)
                                        if lenVal <> invalid then totalBytesForResponse = totalBytesForResponse + lenVal
                                    end for
                                end if
                                coverageStartVal = sabr_toInt(spoolSegment?.startRange)
                                coverageEndVal = sabr_toInt(spoolSegment?.endRange)
                                if spoolSegment?.isInitSeg = true
                                    trimmedCoverage = sabr_byteRangeToCoverage(requestByteRange)
                                    if IsAssociativeArray(trimmedCoverage)
                                        covStartTrim = sabr_toInt(trimmedCoverage?.rangeStart)
                                        covEndTrim = sabr_toInt(trimmedCoverage?.rangeEnd)
                                        if covStartTrim <> invalid then coverageStartVal = covStartTrim
                                        if covEndTrim <> invalid then coverageEndVal = covEndTrim
                                    end if
                                end if
                                if totalBytesForResponse > 0 and sabr_toSafeString(spoolSegment?.path) <> ""
                                    spoolResultForResponse = {
                                        "path": spoolSegment.path
                                        "chunks": spoolChunks
                                        "totalBytes": totalBytesForResponse
                                        "coverage": {
                                            "rangeStart": coverageStartVal
                                            "rangeEnd": coverageEndVal
                                        }
                                    }
                                    if spoolSegment?.isInitSeg = true
                                        spoolResultForResponse["isInitSeg"] = true
                                    end if
                                end if
                            end if
                        end if

                        controlEffects = sabr_ump_extractControlParts(spoolMap, responseFilePath)
                        streamInfoSeed = {}
                        if IsAssociativeArray(controlEffects)
                            if isValid(controlEffects.nextRequestPolicy)
                                streamInfoSeed["nextRequestPolicy"] = controlEffects.nextRequestPolicy
                                cookieProto = controlEffects.nextRequestPolicy?.playbackCookie
                                if isValid(cookieProto)
                                    requestMetadata["playbackCookie"] = PlaybackCookieEncode(cookieProto)
                                end if
                            end if
                            if isValid(controlEffects.sabrContextUpdate)
                                streamInfoSeed["sabrContextUpdate"] = controlEffects.sabrContextUpdate
                            end if
                            if isValid(controlEffects.sabrContextSendingPolicy)
                                streamInfoSeed["sabrContextSendingPolicy"] = controlEffects.sabrContextSendingPolicy
                            end if
                            if isValid(controlEffects.redirect)
                                streamInfoSeed["redirect"] = controlEffects.redirect
                            end if
                            if isValid(controlEffects.reloadPlaybackContext)
                                streamInfoSeed["reloadPlaybackContext"] = controlEffects.reloadPlaybackContext
                            end if
                            if isValid(controlEffects.sabrError)
                                requestMetadata["error"] = { "sabrError": controlEffects.sabrError }
                                fatalReason = "SABR error received"
                                sabr_log(m.logs, log_level_Type.WARN, `${requestLogTag} SABR error received: ${FormatJson(controlEffects.sabrError)}`, false)
                            end if
                        end if
                        requestMetadata["streamInfo"] = streamInfoSeed
                    else
                        fatalReason = "SABR UMP response path missing"
                        sabr_log(m.logs, log_level_Type.WARN, `${requestLogTag} ${fatalReason}`, false)
                    end if

                    if not isValid(umpResult) and IsAssociativeArray(spoolResultForResponse)
                        umpResult = spoolResultForResponse
                    end if

                    if fatalReason <> ""
                        playbackContext["sabrFatalError"] = {
                            "reason": fatalReason
                            "requestNumber": nextRequestId
                            "timestamp": sabr_currentTimestampMs()
                        }
                        sabr_log(m.logs, log_level_Type.WARN, `${requestLogTag} Fatal SABR error: ${fatalReason}`, false)
                        if response = invalid
                            response = sabr_buildErrorResponseForPlayer(502, fatalReason)
                        end if
                    else
                        if isValid(segmentInfo)
                            sabr_log(m.logs, log_level_Type.INFO, `${requestLogTag} Segment info available after processing: ${FormatJson(segmentInfo)}`)
                        end if

                        if IsArray(segmentScanSummary?.segments)
                            segmentCount = segmentScanSummary.segments.count()
                            matchedFlag = segmentScanSummary?.matched
                            if matchedFlag = invalid then matchedFlag = false
                            sabr_log(m.logs, log_level_Type.INFO, `${requestLogTag} SABR scan summary segments=${segmentCount} matched=${matchedFlag}`)
                            for each scanEntry in segmentScanSummary.segments
                                headerLabel = sabr_valueToLabel(scanEntry?.headerId)
                                seqLabel = sabr_valueToLabel(scanEntry?.sequenceNumber)
                                startLabel = sabr_valueToLabel(scanEntry?.start)
                                matchedLabel = scanEntry?.matched
                                if matchedLabel = invalid then matchedLabel = false
                                sabr_log(m.logs, log_level_Type.DEBUG, `${requestLogTag} SABR scan header=${headerLabel} seq=${seqLabel} start=${startLabel} matched=${matchedLabel}`)
                            end for
                        end if

                        playbackCookieValue = requestMetadata.playbackCookie
                        if isValid(playbackCookieValue) and playbackCookieValue <> ""
                            playbackContext["lastPlaybackCookie"] = playbackCookieValue
                            if isValid(sabr)
                                sabr.playbackCookie = playbackCookieValue
                            end if
                        end if
                        redirectUrl = requestMetadata.streamInfo?.redirect?.url ?? ""
                        redirectTriggered = false
                        if redirectUrl <> ""
                            if isValid(sabr)
                                sabr.serverAbrStreamingUrl = redirectUrl
                            end if
                            playbackContext["serverAbrStreamingUrl"] = redirectUrl
                            sabr_log(m.logs, log_level_Type.INFO, `${requestLogTag} Updated SABR server URL via redirect: ${redirectUrl}`)
                            if not isValid(umpResult?.data) or umpResult.data.count() = 0
                                redirectTriggered = true
                            end if
                        end if
                        requestMetadataEntry["streamInfo"] = requestMetadata.streamInfo

                        if redirectTriggered
                            if redirectDepth >= 3
                                fatalReason = "SABR redirect limit reached"
                                sabr_log(m.logs, log_level_Type.WARN, `${requestLogTag} ${fatalReason}`, false)
                            else
                                sabr_log(m.logs, log_level_Type.INFO, `${requestLogTag} Following SABR redirect to ${redirectUrl}`)
                                ' Cleanup temp files for proto/response
                                ' sabr_deleteFileIfExists(responseFilePath)
                                sabr_deleteFileIfExists(protoFilePath)
                                writeFile(`tmp:/${mediaIdHash}/playbackContext.json`, FormatJson(playbackContext))
                                return sabr_handleRequest(request, contentType, mediaIdHash, sabr, videoNode, queuedAtValue, redirectDepth + 1)
                            end if
                        end if

                        if not isValid(umpResult)
                            pendingSummary = []
                            processedParts = []
                            streamInfoKeys = []
                            if IsAssociativeArray(requestMetadata?.streamInfo)
                                for each infoKey in requestMetadata.streamInfo
                                    streamInfoKeys.push(infoKey)
                                end for
                            end if

                            logDetails = {
                                "requestNumber": nextRequestId
                                "requestedRange": sabr_formatRequestedRangeForPath(requestMetadataEntry?.byteRange)
                                "pendingSegments": pendingSummary
                                "processedParts": processedParts
                                "streamInfoKeys": streamInfoKeys
                            }
                            if not isValid(umpResult)
                                logDetails["result"] = "missing"
                            end if
                            sabr_log(m.logs, log_level_Type.WARN, `${requestLogTag} No segment data returned from UMP response: ${FormatJson(logDetails)}`, false)
                        else
                            requestMetadataEntry["streamInfo"] = requestMetadata.streamInfo

                            coverageInfo = umpResult?.coverage
                            deliveredSegment = false
                            if isValid(umpResult?.data) and GetInterface(umpResult.data, "ifByteArray") <> invalid
                                segmentBytes = umpResult.data
                                deliveredSegment = segmentBytes.count() > 0
                                if deliveredSegment
                                    coverageRange = sabr_byteRangeToCoverage(requestMetadataEntry.byteRange)
                                    if not isValid(coverageRange) and isValid(coverageInfo)
                                        coverageRange = coverageInfo
                                    end if
                                    rangeLabel = sabr_formatRequestedRangeForPath(requestMetadataEntry.byteRange)
                                    deliveredLabel = coverageRange
                                    if not isValid(deliveredLabel) and isValid(coverageInfo)
                                        deliveredLabel = coverageInfo
                                    end if
                                    if IsAssociativeArray(deliveredLabel)
                                        deliveredLabel = `${deliveredLabel?.rangeStart ?? ""}-${deliveredLabel?.rangeEnd ?? ""}`
                                    end if
                                    deliveredInfo = {
                                        "coverageLabel": deliveredLabel
                                        "rangeLabel": rangeLabel
                                        "bytes": segmentBytes.count()
                                    }
                                    sabr_log(m.logs, log_level_Type.INFO, `${requestLogTag} SABR delivered segment ${FormatJson(deliveredInfo)}`)
                                    requestMetadataEntry["coverage"] = coverageRange
                                    requestMetadataEntry["segmentIndexKey"] = sabr_formatToKey(currentFormat)
                                    if IsAssociativeArray(requestMetadata?.streamInfo) and isValid(coverageRange)
                                        requestMetadata.streamInfo["deliveredCoverage"] = coverageRange
                                    end if
                                    playerTimeForStore = sabr_toInt(playerTimeOverride)
                                    if playerTimeForStore <> invalid and playerTimeForStore >= 0
                                        requestMetadataEntry["playerTimeMs"] = playerTimeForStore
                                    end if
                                end if
                            else if IsArray(umpResult?.chunks)
                                chunkList = umpResult.chunks
                                chunkTotalBytes = sabr_toInt(umpResult?.totalBytes)
                                if chunkTotalBytes = invalid or chunkTotalBytes <= 0
                                    chunkTotalBytes = 0
                                    for each chunkEntry in chunkList
                                        chunkLenVal = sabr_toInt(chunkEntry?.length)
                                        if chunkLenVal <> invalid then chunkTotalBytes = chunkTotalBytes + chunkLenVal
                                    end for
                                end if
                                if chunkTotalBytes > 0
                                    deliveredSegment = true
                                    coverageRange = sabr_byteRangeToCoverage(requestMetadataEntry.byteRange)
                                    if not isValid(coverageRange) and isValid(coverageInfo)
                                        coverageRange = coverageInfo
                                    end if
                                    rangeLabel = sabr_formatRequestedRangeForPath(requestMetadataEntry.byteRange)
                                    deliveredLabel = coverageRange
                                    if not isValid(deliveredLabel) and isValid(coverageInfo)
                                        deliveredLabel = coverageInfo
                                    end if
                                    if IsAssociativeArray(deliveredLabel)
                                        deliveredLabel = `${deliveredLabel?.rangeStart ?? ""}-${deliveredLabel?.rangeEnd ?? ""}`
                                    end if
                                    deliveredInfo = {
                                        "coverageLabel": deliveredLabel
                                        "rangeLabel": rangeLabel
                                        "bytes": chunkTotalBytes
                                        "chunks": chunkList.count()
                                    }
                                    sabr_log(m.logs, log_level_Type.INFO, `${requestLogTag} SABR delivered segment (chunks) ${FormatJson(deliveredInfo)}`)
                                    requestMetadataEntry["coverage"] = coverageRange
                                    requestMetadataEntry["segmentIndexKey"] = sabr_formatToKey(currentFormat)
                                    if IsAssociativeArray(requestMetadata?.streamInfo) and isValid(coverageRange)
                                        requestMetadata.streamInfo["deliveredCoverage"] = coverageRange
                                    end if
                                    playerTimeForStore = sabr_toInt(requestMetadataEntry?.playerTimeMs)
                                    if playerTimeForStore = invalid or playerTimeForStore < 0
                                        playerTimeForStore = sabr_toInt(playbackContext?.lastResolvedPlayerTimeMs)
                                    end if
                                    if playerTimeForStore = invalid or playerTimeForStore < 0
                                        playerTimeForStore = sabr_toInt(playbackContext?.lastRequestedPlayerTimeMs)
                                    end if
                                    if playerTimeForStore <> invalid and playerTimeForStore >= 0
                                        requestMetadataEntry["playerTimeMs"] = playerTimeForStore
                                    end if
                                end if
                            end if

                            if isValid(metadataManager)
                                metadataManager.store(metadataManager, `${nextRequestId}`, requestMetadataEntry)
                            end if

                            
                            sabr_applyStreamInfoUpdates(playbackContext, requestMetadata.streamInfo, contentType, deliveredSegment, requestMetadataEntry)
                            if isValid(requestMetadata.streamInfo) and IsAssociativeArray(requestMetadata.streamInfo)
                                if requestMetadata.streamInfo.DoesExist("deliveredCoverage")
                                    requestMetadata.streamInfo.Delete("deliveredCoverage")
                                end if
                            end if

                            if response = invalid and isValid(umpResult)
                                response = sabr_buildResponseForPlayer(requestMetadataEntry, umpResult, currentFormat, requestByteRange, contentType)
                            end if
                        end if
                    end if
                else
                    sabr_log(m.logs, log_level_Type.WARN, `${requestLogTag} SABR UMP request failed with status: ${res?.status}`, false)
                    response = sabr_buildErrorResponseForPlayer(sabr_toInt(`${res?.status ?? 0}`), `SABR request failed`)
                end if
            else
                sabr_log(m.logs, log_level_Type.INFO, `${requestLogTag} ignoring audio SABR request for now`)
            end if
        else
            sabr_log(m.logs, log_level_Type.WARN, `${requestLogTag} No valid SABR proto bytes to send`, false)
        end if

    end if

    if IsAssociativeArray(timingInfo)
        timingInfo["responseBuildMs"] = sabr_currentTimestampMs()
    end if

    if IsAssociativeArray(response) and IsAssociativeArray(timingInfo)
        response["timing"] = timingInfo
    end if

    if debugUploadUrl <> "" and isValid(response)
        bodyByteArray = invalid
        bodyPathForDump = sabr_toSafeString(response?.bodyPath)
        bytesCount = 0

        if GetInterface(response.body, "ifByteArray") <> invalid and response.body.count() > 0
            bodyByteArray = response.body
            bytesCount = response.body.count()
        else if bodyPathForDump <> ""
            fs = CreateObject("roFileSystem")
            if fs.Exists(bodyPathForDump)
                fileStats = fs.Stat(bodyPathForDump)
                if isValid(fileStats) and fileStats.DoesExist("size")
                    bytesCount = sabr_toInt(fileStats.size)
                end if
            end if
        else if isValid(response?.bodyLength)
            bytesCount = sabr_toInt(response.bodyLength)
        end if

        rangeLabelResponse = sabr_formatRequestedRangeForPath(requestByteRange)
        dumpCounterResponse = invalid
        if isValid(m.top?.utilsTask)
            dumpCounterResponse = m.top.utilsTask.callFunc("getNextId", "sabrDumpCounterBatch")
        end if
        dumpBase = sabr_debugBuildDumpLabel(playbackContext, "response", `${nextRequestId}`, rangeLabelResponse, contentType, currentFormat, dumpCounterResponse)
        debugFolder = LCase(contentType) = "audio" ? "audio" : "video"
        if isValid(bodyByteArray)
            sabr_log(m.logs, log_level_Type.INFO, `${requestLogTag} Response body size=${bytesCount} bytes for request ${nextRequestId}`)
            sabr_debugUploadBytes(debugUploadUrl, `${debugFolder}/${dumpBase}-bytes`, bodyByteArray, m.logs)
        else if bodyPathForDump <> ""
            sabr_log(m.logs, log_level_Type.INFO, `${requestLogTag} Response body size=${bytesCount} bytes for request ${nextRequestId} (streaming)`)
            sabr_debugUploadBytes(debugUploadUrl, `${debugFolder}/${dumpBase}-bytes`, bodyPathForDump, m.logs)
        else
            sabr_log(m.logs, log_level_Type.INFO, `${requestLogTag} Response body size=${bytesCount} bytes for request ${nextRequestId} (no body data)`)
        end if

        responseInfo = {
            "status": response.status
            "headers": response.headers
            "isInit": isInitSegmentRequest
            "requestNumber": nextRequestId
            "contentType": contentType
        }
        sabr_debugUploadText(debugUploadUrl, `${debugFolder}/${dumpBase}-meta.json`, FormatJson(responseInfo), m.logs)
    end if

    ' Cleanup temp files for proto/response
    ' sabr_deleteFileIfExists(responseFilePath)
    sabr_deleteFileIfExists(protoFilePath)

    sabr_recordRepeatResult(playbackContext, requestMetadataEntry, response, contentType, `${nextRequestId}`)

    if not IsAssociativeArray(response)
        response = sabr_buildEmptyResponseForPlayer(contentType, currentFormat)
        if IsAssociativeArray(response) and IsAssociativeArray(timingInfo)
            response["timing"] = timingInfo
        end if
    end if

    if IsAssociativeArray(response.headers) and not response.headers.DoesExist("Content-Range")
        response.headers["X-Cache-Range"] = sabr_formatRequestedRangeForPath(requestByteRange)
    end if

    ' Persist playback context to tmp so next request sees fresh state to preserve state
    sabr_log(m.logs, log_level_Type.INFO, `${requestLogTag} Storing SABR playbackContext to file for mediaIdHash: ${mediaIdHash}`)
    if isValid(playbackContext?.sidxIndexByFormat)
        sabr_log(m.logs, log_level_Type.DEBUG, `${requestLogTag} SIDX map snapshot ${FormatJson(playbackContext.sidxIndexByFormat)}`)
    end if
    ' sabr_log(m.logs, log_level_Type.VERBOSE, FormatJson(playbackContext))
    contextStoreTimer = invalid
    if isValid(m?.logs)
        contextStoreTimer = m.logs.mark()
    end if
    writeFile(`tmp:/${mediaIdHash}/playbackContext.json`, FormatJson(playbackContext))
    if contextStoreTimer <> invalid
        m.logs.printTime(log_level_Type.INFO, `${requestLogTag} Playback context persisted`, contextStoreTimer, -1)
    end if

    if requestTimer <> invalid
        m.logs.printTime(log_level_Type.INFO, `${requestLogTag} Total request duration`, requestTimer, -1)
    end if

    return response

end function

'------------------------------------------------------------------------------
' Function : sabr_getHeaderByteRange
' Purpose  : Parses the HTTP Range header (case insensitive) into a simple
'            associative array describing the requested byte start/end values.
'------------------------------------------------------------------------------
function sabr_getHeaderByteRange(request as object) as object
    range = "bytes=0-"
    if isValid(request.headers.Range)
        range = request.headers.Range
    else if isValid(request.headers.range)
        range = request.headers.range
    end if
    ' split the range into start and end
    parts = range.Split("=")[1].Split("-")
    if parts.count() = 2
        startRange = parts[0]
        endRange = parts[1]
    end if
    return { "startRange": startRange, "endRange": endRange }
end function

'------------------------------------------------------------------------------
' Function : sabr_collectBufferedRangesForFormat
' Purpose  : Reads prior SABR spool data for a format so the next request can
'            advertise buffered coverage to the server when building JSON.
'------------------------------------------------------------------------------
function sabr_collectBufferedRangesForFormat(mediaIdHash as string, formatType as string, activeFormat as object, targetByteRange as object, playbackContext = invalid as dynamic) as object
    ranges = []
    if not isValid(activeFormat) then return ranges
    if not isValid(mediaIdHash) or mediaIdHash = "" then return ranges

    spoolRange = sabr_spoolBufferedRangeForFormat(playbackContext, formatType, activeFormat)
    if isValid(spoolRange)
        if isValid(m?.logs)
            sabr_log(m.logs, log_level_Type.DEBUG, `[SabrBuffer] bufferedRange=${FormatJson(spoolRange)}`)
        end if
        ranges.push(spoolRange)
    end if
    return ranges
end function

'------------------------------------------------------------------------------
' Function : sabr_spoolBufferedRangeForFormat
' Purpose  : Scans in-memory UMP spool metadata to find the latest completed
'            segment for the active format and returns its byte coverage info.
'------------------------------------------------------------------------------
function sabr_spoolBufferedRangeForFormat(playbackContext as object, formatType as string, activeFormat as object) as dynamic
    if not IsAssociativeArray(playbackContext) then return invalid
    spoolMaps = playbackContext?.umpSpoolMaps
    if not IsAssociativeArray(spoolMaps) then return invalid

    targetItag = sabr_toInt(activeFormat?.itag)
    trackIdLabel = sabr_toSafeString(activeFormat?.audioTrackId)
    normalizedType = UCase(formatType)

    bestEntry = invalid
    bestSeq = invalid
    bestStart = invalid

    for each key in spoolMaps
        entry = spoolMaps.Lookup(key)
        if not IsAssociativeArray(entry) then continue for
        if entry?.isInitSeg = true then continue for

        entryItag = sabr_toInt(entry?.itag)
        if entryItag = invalid and IsAssociativeArray(entry?.mediaHeader)
            entryItag = sabr_toInt(entry.mediaHeader?.itag)
            if entryItag = invalid and IsAssociativeArray(entry.mediaHeader?.formatId)
                entryItag = sabr_toInt(entry.mediaHeader.formatId?.itag)
            end if
        end if
        if targetItag <> invalid and entryItag <> targetItag then continue for

        entryTrack = ""
        if IsAssociativeArray(entry?.mediaHeader?.formatId)
            entryTrack = sabr_toSafeString(entry.mediaHeader.formatId?.audioTrackId)
        end if
        if trackIdLabel <> "" and entryTrack <> "" and LCase(entryTrack) <> LCase(trackIdLabel)
            continue for
        end if

        seqVal = sabr_toInt(entry?.mediaHeader?.sequenceNumber)
        if seqVal = invalid then seqVal = sabr_toInt(entry?.mediaHeader?.startSequenceNumber)
        if seqVal = invalid then seqVal = sabr_toInt(entry?.mediaHeader?.segmentIndex)
        if seqVal = invalid then seqVal = sabr_toInt(entry?.mediaHeader?.startSegmentIndex)

        startRangeVal = sabr_toInt(entry?.startRange)
        if startRangeVal = invalid and IsAssociativeArray(entry?.mediaHeader)
            startRangeVal = sabr_toInt(entry.mediaHeader?.startRange)
            if startRangeVal = invalid then startRangeVal = sabr_toInt(entry.mediaHeader?.start)
        end if

        if bestEntry = invalid
            bestEntry = entry
            bestSeq = seqVal
            bestStart = startRangeVal
        else
            shouldReplace = false
            if seqVal <> invalid
                if bestSeq = invalid or seqVal > bestSeq
                    shouldReplace = true
                else if seqVal = bestSeq and startRangeVal <> invalid and bestStart <> invalid and startRangeVal > bestStart
                    shouldReplace = true
                end if
            else if startRangeVal <> invalid and bestStart <> invalid and startRangeVal > bestStart
                shouldReplace = true
            end if
            if shouldReplace
                bestEntry = entry
                bestSeq = seqVal
                bestStart = startRangeVal
            end if
        end if
    end for

    if bestEntry = invalid then return invalid

    coverageStartVal = sabr_toInt(bestEntry?.startRange)
    if coverageStartVal = invalid and IsAssociativeArray(bestEntry?.mediaHeader)
        coverageStartVal = sabr_toInt(bestEntry.mediaHeader?.startRange)
        if coverageStartVal = invalid then coverageStartVal = sabr_toInt(bestEntry.mediaHeader?.start)
    end if
    coverageEndVal = sabr_toInt(bestEntry?.endRange)
    if coverageEndVal = invalid and IsAssociativeArray(bestEntry?.mediaHeader)
        contentLengthVal = sabr_toInt(bestEntry.mediaHeader?.contentLength)
        if coverageStartVal <> invalid and contentLengthVal <> invalid and contentLengthVal > 0
            coverageEndVal = coverageStartVal + contentLengthVal - 1
        end if
    end if

    coverage = {}
    if coverageStartVal <> invalid then coverage["rangeStart"] = coverageStartVal
    if coverageEndVal <> invalid then coverage["rangeEnd"] = coverageEndVal
    seqForCoverage = sabr_toInt(bestEntry?.mediaHeader?.sequenceNumber)
    if seqForCoverage = invalid then seqForCoverage = sabr_toInt(bestEntry?.mediaHeader?.startSequenceNumber)
    if seqForCoverage <> invalid then coverage["sequenceNumber"] = seqForCoverage
    if bestEntry?.headerId <> invalid then coverage["headerId"] = bestEntry.headerId

    bufferedRange = sabr_buildBufferedRangeFromSpoolEntry(bestEntry, coverage, activeFormat)
    if not IsAssociativeArray(bufferedRange) then return invalid

    if isValid(m?.logs)
        startLabel = sabr_valueToLabel(bufferedRange?.rangeStart)
        endLabel = sabr_valueToLabel(bufferedRange?.rangeEnd)
        seqLabel = sabr_valueToLabel(coverage?.sequenceNumber)
        itagLabel = sabr_valueToLabel(activeFormat?.itag)
        sabr_log(m.logs, log_level_Type.DEBUG, `[SabrBuffer] spoolRange itag=${itagLabel} start=${startLabel} end=${endLabel} seq=${seqLabel}`)
    end if

    return bufferedRange
end function

'------------------------------------------------------------------------------
' Function : sabr_buildBufferedRangeFromSpoolEntry
' Purpose  : Converts an ump spool part entry into a buffered range descriptor
'            that matches the SABR request schema (ranges, timing, format id).
'------------------------------------------------------------------------------
function sabr_buildBufferedRangeFromSpoolEntry(entry as object, coverage as object, activeFormat as object) as dynamic
    if not IsAssociativeArray(entry) then return invalid

    mediaHeader = entry?.mediaHeader
    startRangeVal = sabr_toInt(coverage?.rangeStart)
    endRangeVal = sabr_toInt(coverage?.rangeEnd)

    startSeq = sabr_toInt(mediaHeader?.startSegmentIndex)
    if startSeq = invalid then startSeq = sabr_toInt(mediaHeader?.sequenceNumber)
    if startSeq = invalid then startSeq = sabr_toInt(entry?.sequenceNumber)
    if startSeq = invalid then startSeq = 0

    endSeq = sabr_toInt(mediaHeader?.endSegmentIndex)
    if endSeq = invalid then endSeq = sabr_toInt(mediaHeader?.sequenceNumber)
    if endSeq = invalid then endSeq = startSeq

    timescale = sabr_toInt(mediaHeader?.timeRange?.timescale)
    if timescale = invalid or timescale <= 0 then timescale = sabr_toInt(mediaHeader?.timescale)
    if timescale = invalid or timescale <= 0 then timescale = 1000

    durationMs = sabr_toInt(mediaHeader?.durationMs)
    durationTicks = sabr_toInt(mediaHeader?.timeRange?.durationTicks)
    if durationMs = invalid and durationTicks <> invalid
        durationMs = int((durationTicks * 1000) / timescale)
    end if
    if durationMs = invalid then durationMs = 0
    if durationTicks = invalid then durationTicks = durationMs

    formatId = invalid
    if IsAssociativeArray(mediaHeader?.formatId) then formatId = mediaHeader.formatId
    if not IsAssociativeArray(formatId)
        formatId = sabr_formatToFormatId(activeFormat)
    end if

    buffered = {
        "formatId": formatId
        "startSegmentIndex": startSeq
        "endSegmentIndex": endSeq
        "durationMs": `${durationMs}`
        "startTimeMs": "0"
        "timeRange": {
            "timescale": timescale
            "startTicks": "0"
            "durationTicks": `${durationTicks}`
        }
    }

    if startRangeVal <> invalid then buffered["rangeStart"] = `${startRangeVal}`
    if endRangeVal <> invalid then buffered["rangeEnd"] = `${endRangeVal}`

    return buffered
end function

'------------------------------------------------------------------------------
' Function : sabr_findSpoolSegmentInCache
' Purpose  : Looks up cached spool metadata for a requested byte range/itag
'            and returns the matching chunk list (with init segment fallback).
'------------------------------------------------------------------------------
function sabr_findSpoolSegmentInCache(playbackContext as object, requestByteRange as object, keyParam as string) as dynamic
    spoolMaps = playbackContext?.umpSpoolMaps
    if not IsAssociativeArray(spoolMaps) then return invalid
    startRange = sabr_toInt(requestByteRange?.startRange)
    endRange = sabr_toInt(requestByteRange?.endRange)
    spoolKey = `${startRange}:${keyParam}`
    spoolEntry = spoolMaps.Lookup(spoolKey)
    if IsAssociativeArray(spoolEntry) and IsArray(spoolEntry?.chunks)
        return { spooledSegment: spoolEntry, spoolKey: spoolKey }
    end if
    ' if we get a miss, it could be an init segment request;
    for each key in spoolMaps
        if Instr(key, `0:${keyParam}`) = 1
            entry = spoolMaps.Lookup(key)
            entryEnd = sabr_toInt(entry?.endRange)
            if IsAssociativeArray(entry) and IsArray(entry?.chunks) and entryEnd = endRange
                return { spooledSegment: entry, spoolKey: key }
            end if
        end if
    end for

    return invalid
end function

'------------------------------------------------------------------------------
' Function : sabr_trimSegmentChunksForRange
' Purpose  : Copies only the requested portion of a spool chunk list so init
'            segment responses can honor byte ranges without extra allocation.
'------------------------------------------------------------------------------
function sabr_trimSegmentChunksForRange(chunks as object, segmentStart as dynamic, requestRange as object) as dynamic
    if not IsArray(chunks) then return invalid
    segmentStartVal = sabr_toInt(segmentStart)
    if segmentStartVal = invalid then return invalid
    requestStartVal = sabr_toInt(requestRange?.startRange)
    requestEndVal = sabr_toInt(requestRange?.endRange)
    if requestStartVal = invalid or requestEndVal = invalid then return invalid
    if requestEndVal < requestStartVal then return invalid

    offsetToSkip = requestStartVal - segmentStartVal
    if offsetToSkip < 0 then offsetToSkip = 0
    bytesNeeded = (requestEndVal - requestStartVal) + 1
    if bytesNeeded <= 0 then return invalid

    trimmedChunks = []
    remaining = bytesNeeded
    skip = offsetToSkip

    for each chunk in chunks
        chunkOffset = sabr_toInt(chunk?.offset)
        chunkLength = sabr_toInt(chunk?.length)
        if chunkOffset = invalid or chunkLength = invalid or chunkLength <= 0 then continue for

        if skip >= chunkLength
            skip = skip - chunkLength
            continue for
        end if

        effectiveOffset = chunkOffset + skip
        effectiveLength = chunkLength - skip
        if effectiveLength > remaining then effectiveLength = remaining

        if effectiveLength > 0
            trimmedChunks.push({
                "offset": effectiveOffset
                "length": effectiveLength
            })
            remaining = remaining - effectiveLength
        end if

        skip = 0
        if remaining <= 0 then exit for
    end for

    trimmedTotal = bytesNeeded - remaining
    if trimmedTotal <= 0 then return invalid

    return {
        "chunks": trimmedChunks
        "totalBytes": trimmedTotal
    }
end function

'------------------------------------------------------------------------------
' Function : sabr_currentPlayerPositionMs
' Purpose  : Derives the player's current playback timestamp from the video
'            node or stored context so SABR requests can reference seek intent.
'------------------------------------------------------------------------------
function sabr_currentPlayerPositionMs(videoNode as object, playbackContext as object) as dynamic
    positionSeconds = invalid
    if isValid(videoNode) and isValid(videoNode.position)
        positionSeconds = videoNode.position
    end if
    if positionSeconds = invalid and isValid(playbackContext?.lastPlayerTimeSecs)
        positionSeconds = playbackContext.lastPlayerTimeSecs
    end if
    if positionSeconds = invalid then return invalid
    return int((positionSeconds ?? 0) * 1000)
end function

'------------------------------------------------------------------------------
' Function : sabr_buildBufferedState
' Purpose  : Aggregates buffered coverage across audio/video formats to inform
'            the next SABR request about which segments are already available.
'------------------------------------------------------------------------------
function sabr_buildBufferedState(mediaIdHash as string, currentFormat as object, activeFormats as object, playbackContext as object, requestedFormatType as string, requestByteRange as object) as object
    rangesByType = {}
    rangesByType["AUDIO"] = []
    rangesByType["VIDEO"] = []

    state = {
        "formatToDiscard": invalid
        "rangesByType": rangesByType
    }

    currentFormatKey = sabr_formatToKey(currentFormat)
    activeFormatKeys = ["audioFormat", "videoFormat"]

    for each fieldName in activeFormatKeys
        format = activeFormats[fieldName]
        if not isValid(format)
            if fieldName = "audioFormat" and isValid(activeFormats.audioFormat)
                format = activeFormats.audioFormat
            else if fieldName = "videoFormat" and isValid(activeFormats.videoFormat)
                format = activeFormats.videoFormat
            end if
        end if

        if not isValid(format) then continue for

        formatType = sabr_formatTypeFromFormat(format)
        if formatType = "" then formatType = "UNKNOWN"

        if not state.rangesByType.DoesExist(formatType)
            state.rangesByType[formatType] = []
        end if

        shouldDiscard = sabr_formatToKey(format) <> currentFormatKey
        bufferedRanges = []
        targetByteRange = invalid
        if shouldDiscard = false and UCase(formatType) = UCase(requestedFormatType)
            targetByteRange = requestByteRange
        end if
        if shouldDiscard
            bufferedRanges = [sabr_createFullBufferRange(format)]
            if not isValid(state["formatToDiscard"])
                state["formatToDiscard"] = format
            end if
        else
            bufferedRanges = sabr_collectBufferedRangesForFormat(mediaIdHash, formatType, format, targetByteRange, playbackContext)
        end if

        if IsArray(bufferedRanges)
            for each bufferedRange in bufferedRanges
                if isValid(bufferedRange)
                    state.rangesByType[formatType].push(bufferedRange)
                end if
            end for
        else if isValid(bufferedRanges)
            state.rangesByType[formatType].push(bufferedRanges)
        end if
    end for

    return state
end function

'------------------------------------------------------------------------------
' Function : sabr_applyBufferedStateToRequest
' Purpose  : Copies buffered range metadata onto the outgoing SABR protobuf
'            so the server can skip formats we already possess locally.
'------------------------------------------------------------------------------
function sabr_applyBufferedStateToRequest(videoPlaybackAbrRequest as object, bufferState as object) as dynamic
    if not IsAssociativeArray(bufferState) then return invalid

    rangeMap = bufferState?.rangesByType
    if IsAssociativeArray(rangeMap)
        for each rangeType in rangeMap
            ranges = rangeMap[rangeType]
            if IsArray(ranges)
                for each bufferedRange in ranges
                    if isValid(bufferedRange)
                        videoPlaybackAbrRequest.bufferedRanges.push(bufferedRange)
                    end if
                end for
            end if
        end for
    end if

    return bufferState?.formatToDiscard
end function

'------------------------------------------------------------------------------
' Function : sabr_pruneBufferedRangesForSeekBack
' Purpose  : Removes buffered ranges that extend beyond the current seek-back
'            targets to avoid advertising coverage the player no longer needs.
'------------------------------------------------------------------------------
sub sabr_pruneBufferedRangesForSeekBack(bufferState as object, formatType as string, maxSegmentIndex as dynamic, maxStartTimeMs as dynamic, logTag as string)    if not IsAssociativeArray(bufferState) then return
    if formatType = "" then return
    rangesMap = bufferState?.rangesByType
    if not IsAssociativeArray(rangesMap) then return

    normalizedType = UCase(formatType)
    if not rangesMap.DoesExist(normalizedType) then return

    targetIndex = sabr_toInt(maxSegmentIndex)

    originalRanges = rangesMap[normalizedType]
    if not IsArray(originalRanges) then return

    keptRanges = []
    removedCount = 0
    targetStartTimeMs = sabr_toInt(maxStartTimeMs)
    for each bufferedRange in originalRanges
        if not isValid(bufferedRange)
            continue for
        end if

        segmentIndex = sabr_toInt(bufferedRange?.startSegmentIndex)
        if segmentIndex = invalid
            segmentIndex = sabr_toInt(bufferedRange?.sequenceNumber)
        end if
        if segmentIndex = invalid
            segmentIndex = sabr_toInt(bufferedRange?.segmentIndex)
        end if

        shouldRemove = false
        if segmentIndex <> invalid and targetIndex <> invalid and segmentIndex > targetIndex
            shouldRemove = true
        else if targetStartTimeMs <> invalid
            startMs = sabr_toInt(bufferedRange?.startTimeMs)
            if startMs = invalid
                timeRange = bufferedRange?.timeRange
                startTicks = sabr_toInt(timeRange?.startTicks)
                timeScale = sabr_toInt(timeRange?.timescale)
                if startTicks <> invalid and timeScale <> invalid and timeScale > 0
                    startMs = int(startTicks * 1000 / timeScale)
                end if
            end if
            if startMs <> invalid and startMs > targetStartTimeMs
                shouldRemove = true
            end if
        end if

        if shouldRemove
            removedCount = removedCount + 1
        else
            keptRanges.push(bufferedRange)
        end if
    end for

    rangesMap[normalizedType] = keptRanges

    if removedCount > 0 and isValid(m?.logs)
        logPieces = [`${logTag} Seek-back detected; pruned ${removedCount} buffered range(s)`]
        if targetIndex <> invalid
            logPieces.push(`segment>${targetIndex}`)
        end if
        if targetStartTimeMs <> invalid
            logPieces.push(`startTime>${targetStartTimeMs}`)
        end if
        sabr_log(m.logs, log_level_Type.DEBUG, logPieces.Join(" "))
    end if
end sub


function sabr_globalSidxIndexMap() as object
    if not IsAssociativeArray(m?.sidxIndexCache)
        m.sidxIndexCache = {}
    end if
    return m.sidxIndexCache
end function

'------------------------------------------------------------------------------
' Function : sabr_requestedByteStart
' Purpose  : Extracts a numeric start byte from a SABR byte range structure,
'            accommodating string labels and legacy segment index fields.
'------------------------------------------------------------------------------
function sabr_requestedByteStart(byteRange as object) as dynamic
    if not IsAssociativeArray(byteRange) then return invalid
    startVal = sabr_toInt(byteRange?.startRange)
    if startVal = invalid then startVal = sabr_toInt(byteRange?.start)
    if startVal = invalid
        label = ""
        if byteRange.DoesExist("startRange") then label = `${byteRange.startRange}`
        if label = "" and byteRange.DoesExist("start") then label = `${byteRange.start}`
        if label <> ""
            startVal = Val(label)
        end if
    end if
    if startVal = invalid and byteRange.DoesExist("segmentIndexInfo")
        info = byteRange.segmentIndexInfo
        if IsAssociativeArray(info)
            startVal = sabr_toInt(info?.rangeStart)
            if startVal = invalid and isValid(info?.rangeStart)
                startLabel = `${info.rangeStart}`
                if startLabel <> ""
                    startVal = Val(startLabel)
                end if
            end if
        end if
    end if
    return startVal
end function

'------------------------------------------------------------------------------
' Function : sabr_resolvePlayerTimeMsForRequest
' Purpose  : Determines the playerTimeMs for the outgoing SABR request using
'            SIDX predictions and repeat-guard heuristics, including nudging.
'------------------------------------------------------------------------------
function sabr_resolvePlayerTimeMsForRequest(playbackContext as object, contentType as string, currentFormat as object, requestByteRange as object, videoNode as object) as object
     result = sabr_lookupPlayerTimeMsFromSidx(playbackContext, contentType, currentFormat, requestByteRange)
    candidate = sabr_toInt(result?.value)

    if candidate <> invalid and candidate >= 0
        durationMs = sabr_toInt(result?.durationMs)
        adjusted = sabr_applyRepeatPlayerTimeNudge(playbackContext, contentType, currentFormat, requestByteRange, candidate, durationMs, result?.source)
        adjustedValue = sabr_toInt(adjusted?.value)
        if adjustedValue = invalid then adjustedValue = candidate
        adjustedSource = `${adjusted?.source ?? result?.source ?? "sidx"}`
        output = { "value": adjustedValue, "source": adjustedSource }
        segmentStartMs = sabr_toInt(result?.segmentStartMs)
        segmentDurationMs = sabr_toInt(result?.segmentDurationMs)
        if segmentStartMs <> invalid then output["segmentStartMs"] = segmentStartMs
        if segmentDurationMs <> invalid then output["segmentDurationMs"] = segmentDurationMs
        return output
    end if

    fallbackValue = sabr_toInt(playbackContext?.lastRequestedPlayerTimeMs)
    fallbackSource = "lastRequestedPlayerTimeMs"
    if fallbackValue = invalid or fallbackValue < 0
        fallbackValue = 0
        fallbackSource = "default"
    end if
    adjustedFallback = sabr_applyRepeatPlayerTimeNudge(playbackContext, contentType, currentFormat, requestByteRange, fallbackValue, invalid, fallbackSource)
    finalValue = sabr_toInt(adjustedFallback?.value)
    if finalValue = invalid then finalValue = fallbackValue
    finalSource = `${adjustedFallback?.source ?? fallbackSource}`
    output = { "value": finalValue, "source": `fallback:${finalSource}` }
    segmentStartMs = sabr_toInt(adjustedFallback?.segmentStartMs)
    segmentDurationMs = sabr_toInt(adjustedFallback?.segmentDurationMs)
    if segmentStartMs <> invalid then output["segmentStartMs"] = segmentStartMs
    if segmentDurationMs <> invalid then output["segmentDurationMs"] = segmentDurationMs
    return output
end function

function sabr_buildPlayerTimeIndexKey(contentType as string, format as object) as string
    typeLabel = `${contentType ?? ""}`
    if typeLabel = "" then typeLabel = sabr_formatTypeFromFormat(format)
    if typeLabel = "" then typeLabel = "UNKNOWN"
    return `${typeLabel}|${sabr_formatToKey(format)}`
end function

'------------------------------------------------------------------------------
' Function : sabr_getSidxEntrySet
' Purpose  : Retrieves the SIDX entry list and metadata previously extracted
'            from init segments for the active format, tracking the data source.
'------------------------------------------------------------------------------
function sabr_getSidxEntrySet(playbackContext as object, contentType as string, currentFormat as object) as dynamic
    result = {
        "entries": invalid
        "source": ""
        "indexEntry": invalid
    }
    if not IsAssociativeArray(playbackContext) then return result
    key = sabr_buildPlayerTimeIndexKey(contentType, currentFormat)
    if key = "" then return result

    indexMap = sabr_globalSidxIndexMap()
    entrySource = "global"
    indexEntry = invalid
    if IsAssociativeArray(indexMap) and indexMap.DoesExist(key)
        indexEntry = indexMap.Lookup(key)
    end if

    if not IsAssociativeArray(indexEntry)
        playbackMap = playbackContext?.sidxIndexByFormat
        if IsAssociativeArray(playbackMap) and playbackMap.DoesExist(key)
            indexEntry = playbackMap.Lookup(key)
            entrySource = "context"
        end if
    end if

    if IsAssociativeArray(indexEntry)
        result.entries = indexEntry.Lookup("entries")
        result.source = entrySource
        result.indexEntry = indexEntry
    end if
    return result
end function

'------------------------------------------------------------------------------
' Function : sabr_fetchSidxNeighbors
' Purpose  : Finds the SIDX entry that matches the requested byte start along
'            with the nearest predecessor/successor to aid time predictions.
'------------------------------------------------------------------------------
function sabr_fetchSidxNeighbors(playbackContext as object, contentType as string, currentFormat as object, targetStart as integer) as object
    neighbors = {
        "exact": invalid
        "previous": invalid
        "next": invalid
        "source": ""
    }
    if targetStart = invalid then return neighbors

    entrySet = sabr_getSidxEntrySet(playbackContext, contentType, currentFormat)
    entries = entrySet?.entries
    if not IsArray(entries) or entries.count() = 0 then return neighbors

    neighbors.source = entrySet?.source

    maxPrevStart = invalid
    minNextStart = invalid

    for each entry in entries
        if not IsAssociativeArray(entry) then continue for
        startVal = sabr_toInt(entry?.rangeStart)
        if startVal = invalid and entry.DoesExist("rangeStartLabel")
            startLabel = `${entry.rangeStartLabel ?? ""}`
            if startLabel <> "" then startVal = Val(startLabel)
        end if
        if startVal = invalid then continue for

        endVal = sabr_toInt(entry?.rangeEnd)
        if endVal = invalid and entry.DoesExist("rangeEndLabel")
            endLabel = `${entry.rangeEndLabel ?? ""}`
            if endLabel <> "" then endVal = Val(endLabel)
        end if

        if startVal <= targetStart and (endVal = invalid or targetStart <= endVal)
            neighbors["exact"] = entry
        end if

        if startVal < targetStart
            if maxPrevStart = invalid or startVal > maxPrevStart
                maxPrevStart = startVal
                neighbors["previous"] = entry
            end if
        else if startVal > targetStart
            if minNextStart = invalid or startVal < minNextStart
                minNextStart = startVal
                neighbors["next"] = entry
            end if
        end if
    end for

    if not IsAssociativeArray(neighbors.exact) and IsAssociativeArray(neighbors.previous)
        prevEnd = sabr_toInt(neighbors.previous?.rangeEnd)
        if prevEnd = invalid and neighbors.previous.DoesExist("rangeEndLabel")
            prevLabel = `${neighbors.previous.rangeEndLabel ?? ""}`
            if prevLabel <> "" then prevEnd = Val(prevLabel)
        end if
        if prevEnd <> invalid and targetStart <= prevEnd
            neighbors["exact"] = neighbors.previous
        end if
    end if

    neighbors["indexEntry"] = entrySet?.indexEntry
    return neighbors
end function

'------------------------------------------------------------------------------
' Function : sabr_lookupPlayerTimeMsFromSidx
' Purpose  : Matches a requested byte range against cached SIDX metadata to
'            estimate playerTimeMs and duration information for SABR requests.
'------------------------------------------------------------------------------
function sabr_lookupPlayerTimeMsFromSidx(playbackContext as object, contentType as string, currentFormat as object, requestByteRange as object) as object
    result = {
        "value": invalid
        "source": "sidx"
    }
    if not IsAssociativeArray(playbackContext) then return result

    indexMap = sabr_globalSidxIndexMap()
    if not IsAssociativeArray(indexMap)
        indexMap = {}
    end if

    key = sabr_buildPlayerTimeIndexKey(contentType, currentFormat)
    if key = "" then return result

    entrySet = sabr_getSidxEntrySet(playbackContext, contentType, currentFormat)
    indexEntry = entrySet?.indexEntry
    entrySource = entrySet?.source
    if not IsAssociativeArray(indexEntry) then return result

    if indexEntry.DoesExist("unsupportedReason")
        reasonLabel = `${indexEntry.Lookup("unsupportedReason") ?? ""}`
        if reasonLabel <> ""
            result["source"] = `sidx:unsupported:${reasonLabel}`
            if isValid(m?.logs)
                sabr_log(m.logs, log_level_Type.DEBUG, `[YTSABR-PlayerTime] SIDX unsupported for ${key} source=${entrySource} reason=${reasonLabel}`)
            end if
            return result
        end if
    end if

    entries = entrySet?.entries
    if not IsArray(entries) or entries.count() = 0 then return result

    targetStart = sabr_requestedByteStart(requestByteRange)
    if targetStart = invalid then return result
    targetValue = targetStart

    if isValid(m?.logs)
        firstEntry = entries[0]
        sabr_log(m.logs, log_level_Type.DEBUG, `[YTSABR-PlayerTime] SIDX lookup ${key} source=${entrySource} target=${targetValue} entries=${entries.count()} firstStart=${firstEntry?.rangeStart} duration=${firstEntry?.durationMs}`)
    end if

    neighbors = sabr_fetchSidxNeighbors(playbackContext, contentType, currentFormat, targetValue)
    candidateEntry = neighbors?.exact
    label = "sidx"
    if IsAssociativeArray(candidateEntry)
        startVal = sabr_toInt(candidateEntry?.rangeStart)
        if startVal = invalid and candidateEntry.DoesExist("rangeStartLabel")
            startLabel = `${candidateEntry.rangeStartLabel ?? ""}`
            if startLabel <> "" then startVal = Val(startLabel)
        end if
        if startVal <> invalid and startVal <> targetValue
            label = "sidx:contains"
        else
            label = "sidx:exact"
        end if
    else
        prevEntry = neighbors?.previous
        nextEntry = neighbors?.next

        prevStart = invalid
        nextStart = invalid
        if IsAssociativeArray(prevEntry)
            prevStart = sabr_toInt(prevEntry?.rangeStart)
            if prevStart = invalid and prevEntry.DoesExist("rangeStartLabel")
                prevLabel = `${prevEntry.rangeStartLabel ?? ""}`
                if prevLabel <> "" then prevStart = Val(prevLabel)
            end if
        end if
        if IsAssociativeArray(nextEntry)
            nextStart = sabr_toInt(nextEntry?.rangeStart)
            if nextStart = invalid and nextEntry.DoesExist("rangeStartLabel")
                nextLabel = `${nextEntry.rangeStartLabel ?? ""}`
                if nextLabel <> "" then nextStart = Val(nextLabel)
            end if
        end if

        if IsAssociativeArray(prevEntry) and IsAssociativeArray(nextEntry)
            diffPrev = 2147483647
            diffNext = 2147483647
            if prevStart <> invalid then diffPrev = targetValue - prevStart
            if nextStart <> invalid then diffNext = nextStart - targetValue
            if diffNext < 0 then diffNext = 2147483647
            if diffPrev < 0 then diffPrev = 2147483647
            if diffNext < diffPrev
                candidateEntry = nextEntry
                label = "sidx:nearest-next"
            else
                candidateEntry = prevEntry
                label = "sidx:nearest-prev"
            end if
        else if IsAssociativeArray(nextEntry)
            candidateEntry = nextEntry
            label = "sidx:nearest-next"
        else if IsAssociativeArray(prevEntry)
            candidateEntry = prevEntry
            label = "sidx:nearest-prev"
        end if
    end if

    if not IsAssociativeArray(candidateEntry)
        if isValid(m?.logs)
            sabr_log(m.logs, log_level_Type.DEBUG, `[YTSABR-PlayerTime] SIDX lookup miss for ${key} target=${targetValue}`)
        end if
        return result
    end if

    predicted = sabr_predictPlayerTimeFromSidxEntry(candidateEntry, targetStart)
    durationMs = sabr_toInt(candidateEntry?.durationMs)
    if predicted = invalid then return result

    if isValid(m?.logs)
        logMsg = `[YTSABR-PlayerTime] SIDX match ${label} start=${candidateEntry?.rangeStart ?? candidateEntry?.rangeStartLabel} `
        logMsg = `${logMsg}end=${candidateEntry?.rangeEnd ?? candidateEntry?.rangeEndLabel} startMs=${candidateEntry?.startTimeMs ?? "?"} durationMs=${candidateEntry?.durationMs ?? "?"} predicted=${predicted}`
        sabr_log(m.logs, log_level_Type.DEBUG, logMsg)
    end if

    result["value"] = predicted
    result["source"] = label
    segmentStartMs = sabr_toInt(candidateEntry?.startTimeMs)
    if segmentStartMs <> invalid
        result["segmentStartMs"] = segmentStartMs
    end if
    if durationMs <> invalid and durationMs > 0
        result["durationMs"] = durationMs
        result["segmentDurationMs"] = durationMs
    end if
    return result
end function

'------------------------------------------------------------------------------
' Function : sabr_predictPlayerTimeFromSidxEntry
' Purpose  : Converts a SIDX entry and requested byte start into a playback
'            timestamp by interpolating within the entry's byte/time coverage.
'------------------------------------------------------------------------------
function sabr_predictPlayerTimeFromSidxEntry(entry as object, targetStart as dynamic) as dynamic
    if not IsAssociativeArray(entry) then return invalid
    startMs = sabr_toInt(entry?.startTimeMs)
    if startMs = invalid then return invalid

    durationMs = sabr_toInt(entry?.durationMs)
    rangeStart = sabr_toInt(entry?.rangeStart)
    if rangeStart = invalid and entry.DoesExist("rangeStartLabel")
        labelStart = `${entry.rangeStartLabel ?? ""}`
        if labelStart <> ""
            rangeStart = sabr_toInt(labelStart)
            if rangeStart = invalid
                rangeStart = Val(labelStart)
            end if
        end if
    end if
    rangeEnd = sabr_toInt(entry?.rangeEnd)
    if rangeEnd = invalid and entry.DoesExist("rangeEndLabel")
        labelEnd = `${entry.rangeEndLabel ?? ""}`
        if labelEnd <> ""
            rangeEnd = sabr_toInt(labelEnd)
            if rangeEnd = invalid
                rangeEnd = Val(labelEnd)
            end if
        end if
    end if
    if durationMs = invalid or rangeStart = invalid or rangeEnd = invalid then return startMs

    span = rangeEnd - rangeStart + 1
    if span <= 0 then return startMs

    targetValue = targetStart * 1.0
    offset = targetStart - rangeStart
    if offset <= 0 then return startMs

    predicted = startMs + int((offset * durationMs) / span)
    if predicted < startMs then predicted = startMs
    maxMs = startMs
    if durationMs <> invalid and durationMs >= 0
        maxMs = startMs + durationMs
    end if
    if predicted > maxMs then predicted = maxMs
    return predicted
end function

'------------------------------------------------------------------------------
' Function : sabr_applyRepeatPlayerTimeNudge
' Purpose  : Applies a defensive time bump when repeat-guard detects the same
'            request arriving multiple times, nudging SABR toward future data.
'------------------------------------------------------------------------------
function sabr_applyRepeatPlayerTimeNudge(playbackContext as object, contentType as string, currentFormat as object, requestByteRange as object, baseValue as integer, durationMs = invalid as dynamic, sourceLabel = "" as string) as object
    result = {
        "value": baseValue
        "source": sourceLabel
    }
    if not IsAssociativeArray(playbackContext) then return result

    repeatKey = sabr_buildRepeatRequestKey(contentType, currentFormat, requestByteRange)
    if repeatKey = "" then return result

    repeatState = playbackContext?.repeatRequestState
    if not IsAssociativeArray(repeatState) then return result
    if `${repeatState?.lastKey ?? ""}` <> repeatKey then return result

    failureStreak = sabr_toInt(repeatState?.failureStreak)
    if failureStreak = invalid or failureStreak <= 0 then return result

    priorKey = `${playbackContext?.lastRepeatPlayerTimeKey ?? ""}`
    if priorKey = repeatKey
        priorCandidate = sabr_toInt(playbackContext?.lastRepeatPlayerTimeCandidate)
        if priorCandidate <> invalid and priorCandidate > baseValue
            baseValue = priorCandidate
        end if
    end if

    bump = sabr_toInt(durationMs)
    if bump = invalid or bump <= 0 then bump = 1000
    bump = int(bump / 2)
    if bump < 250 then bump = 250
    if bump > 2000 then bump = 2000

    adjustedValue = baseValue + bump
    if adjustedValue < 0 then adjustedValue = baseValue

    repeatSuffix = `+repeat${failureStreak}`
    newSource = sourceLabel
    if newSource = ""
        newSource = repeatSuffix
    else
        newSource = `${newSource}${repeatSuffix}`
    end if

    if isValid(m?.logs)
        sabr_log(m.logs, log_level_Type.DEBUG, `[YTSABR-PlayerTime] Repeat bump applied key=${repeatKey} failures=${failureStreak} base=${baseValue} bump=${bump} => ${adjustedValue}`)
    end if

    playbackContext["lastRepeatPlayerTimeBumpMs"] = bump
    playbackContext["lastRepeatPlayerTimeCandidate"] = adjustedValue
    playbackContext["lastRepeatPlayerTimeKey"] = repeatKey

    result["value"] = adjustedValue
    result["source"] = newSource
    result["bumpMs"] = bump
    return result
end function

'------------------------------------------------------------------------------
' Function : sabr_storeSidxIndexUpdate
' Purpose  : Normalizes SIDX updates extracted from spool metadata and merges
'            them into the playback context/global caches for future lookups.
'------------------------------------------------------------------------------
sub sabr_storeSidxIndexUpdate(playbackContext as object, contentType as string, update as object)    if not IsAssociativeArray(playbackContext) then return
    if not IsAssociativeArray(update) then return

    formatKey = `${update?.formatKey ?? ""}`
    if formatKey = "" and update.DoesExist("format_id")
        inferred = update.Lookup("format_id")
        if IsAssociativeArray(inferred)
            itagLabel = sabr_valueToLabel(inferred.Lookup("itag"))
            xtagLabel = sabr_valueToLabel(inferred.Lookup("xtags"))
            formatKey = `${itagLabel}:${xtagLabel}`
        end if
    end if
    if formatKey = "" then return

    typeLabel = `${update?.contentType ?? contentType ?? ""}`
    if typeLabel = "" then typeLabel = contentType
    indexKey = `${typeLabel ?? ""}`
    if indexKey = "" then indexKey = "UNKNOWN"
    indexKey = `${indexKey}|${formatKey}`

    sanitized = {
        "formatKey": formatKey
        "entries": []
        "timescale": sabr_toInt(update?.timescale)
        "earliestPresentationTime": update?.earliestPresentationTime
        "contentType": typeLabel
    }

    if update.DoesExist("unsupportedReason")
        sanitized["unsupportedReason"] = `${update.Lookup("unsupportedReason")}`
    end if

    entryList = update?.entries
    if IsArray(entryList)
        cleaned = []
        for each entry in entryList
            if not IsAssociativeArray(entry) then continue for
            startNumeric = sabr_toInt(entry?.rangeStart)
            if startNumeric = invalid and isValid(entry?.rangeStart)
                labelStart = `${entry.rangeStart}`
                if labelStart <> ""
                    startNumeric = Val(labelStart)
                end if
            end if
            endNumeric = sabr_toInt(entry?.rangeEnd)
            if endNumeric = invalid and isValid(entry?.rangeEnd)
                labelEndVal = `${entry.rangeEnd}`
                if labelEndVal <> ""
                    endNumeric = Val(labelEndVal)
                end if
            end if
            cleanedEntry = {
                "rangeStart": startNumeric
                "rangeEnd": endNumeric
                "startTimeMs": sabr_toInt(entry?.startTimeMs)
                "durationMs": sabr_toInt(entry?.durationMs)
                "referenceType": sabr_toInt(entry?.referenceType)
            }
            if isValid(entry?.rangeStart)
                cleanedEntry["rangeStartLabel"] = `${entry.rangeStart}`
            end if
            if isValid(entry?.rangeEnd)
                cleanedEntry["rangeEndLabel"] = `${entry.rangeEnd}`
            end if
            cleaned.push(cleanedEntry)
        end for
        sanitized["entries"] = cleaned
    end if

    map = playbackContext?.sidxIndexByFormat
    if not IsAssociativeArray(map)
        map = {}
    end if
    map[indexKey] = sanitized
    playbackContext["sidxIndexByFormat"] = map

    globalMap = sabr_globalSidxIndexMap()
    globalMap[indexKey] = sanitized
    m.sidxIndexCache = globalMap

    if isValid(m?.logs)
        entryCount = IsArray(sanitized.entries) ? sanitized.entries.count() : 0
        reason = sanitized?.unsupportedReason
        if isValid(reason) and reason <> ""
            sabr_log(m.logs, log_level_Type.DEBUG, `[YTSABR-PlayerTime] Stored SIDX index for ${indexKey} entries=${entryCount} unsupported=${reason}`)
        else
            sabr_log(m.logs, log_level_Type.DEBUG, `[YTSABR-PlayerTime] Stored SIDX index for ${indexKey} entries=${entryCount}`)
            if entryCount > 0
                preview = sanitized.entries[0]
                sabr_log(m.logs, log_level_Type.DEBUG, `[YTSABR-PlayerTime] SIDX preview start=${preview?.rangeStart} duration=${preview?.durationMs} bytes=${preview?.rangeStart}-${preview?.rangeEnd}`)
            end if
        end if
    end if
end sub

'------------------------------------------------------------------------------
' Function : sabr_isInit
' Purpose  : Checks whether the requested byte range targets an init or index
'            segment for the active format and logs the detection for tracing.
'------------------------------------------------------------------------------
function sabr_isInit(contentType as string, format as object, requestByteRange as object, requestRef = invalid as dynamic) as boolean
    logTag = sabr_utilLogTag(contentType, requestRef)
    if sabr_rangesMatch(format?.initRange, requestByteRange)
        sabr_log(m.logs, log_level_Type.INFO, `${logTag} SABR format itag ${format.itag} init range requested: ${FormatJson(requestByteRange)}`)
        return true
    end if

    if sabr_rangesMatch(format?.indexRange, requestByteRange)
        sabr_log(m.logs, log_level_Type.INFO, `${logTag} SABR format itag ${format.itag} index range requested: ${FormatJson(requestByteRange)}`)
        return true
    end if
    return false
end function

sub sabr_ensureInfrastructure()
    if not isValid(m.sabrRequestMetadataManager)
        m.sabrRequestMetadataManager = sabr_createRequestMetadataManager()
    end if
end sub

'------------------------------------------------------------------------------
' Function : sabr_buildSegmentCacheKeyForRange
' Purpose  : Builds a stable identifier for a segment based on byte coverage
'            and format fields so cached spool data can be retrieved quickly.
'------------------------------------------------------------------------------
function sabr_buildSegmentCacheKeyForRange(format as object, byteRange as object) as string
    if not isValid(format) then return ""
    startLabel = sabr_valueToLabel(byteRange?.startRange)
    if startLabel = "" then startLabel = sabr_valueToLabel(byteRange?.start)
    if startLabel = "" then startLabel = "0"
    endLabel = sabr_valueToLabel(byteRange?.endRange)
    if endLabel = "" then endLabel = sabr_valueToLabel(byteRange?.end)
    if endLabel = "" then endLabel = "0"
    if startLabel = "" and endLabel = "" then return ""
    rangeLabel = startLabel
    if startLabel <> "" and endLabel <> ""
        rangeLabel = `${startLabel}-${endLabel}`
    end if

    itagPart = `${format?.itag ?? ""}`
    xtagsPart = `${format?.xtags ?? ""}`

    return `${rangeLabel}-${itagPart}-${xtagsPart}`
end function

function sabr_buildRepeatRequestKey(contentType as string, format as object, byteRange as object) as string
    if not isValid(byteRange) then return ""
    segmentKey = sabr_buildSegmentCacheKeyForRange(format, byteRange)
    if segmentKey = "" then return ""
    typeLabel = contentType ?? ""
    if typeLabel = "" then typeLabel = "UNKNOWN"
    return `${typeLabel}|${segmentKey}`
end function

'------------------------------------------------------------------------------
' Function : sabr_debugLogRepeatState
' Purpose  : Emits structured logs describing the repeat-guard state machine
'            whenever we transition or inspect repeat detection metadata.
'------------------------------------------------------------------------------
sub sabr_debugLogRepeatState(contentType as string, requestNumber as dynamic, playbackContext as object, label as string, extra = invalid as dynamic)    if not isValid(m?.logs) then return
    logTag = sabr_utilLogTag(contentType, `${requestNumber}`)
    state = playbackContext?.repeatRequestState

    extraParts = []
    if isValid(extra)
        if IsString(extra)
            extraParts.push(extra)
        else if IsAssociativeArray(extra)
            for each key in extra
                extraParts.push(`${key}=${extra[key]}`)
            end for
        end if
    end if

    if not IsAssociativeArray(state)
        message = `${logTag} RepeatState ${label}: none`
        if extraParts.count() > 0 then message = `${message} ${extraParts.Join(" ")}`
        sabr_log(m.logs, log_level_Type.DEBUG, message)
        return
    end if

    pieces = [
        `key=${state?.lastKey ?? ""}`
        `count=${state?.count ?? ""}`
        `success=${state?.successStreak ?? ""}`
        `failure=${state?.failureStreak ?? ""}`
        `lastStatus=${state?.lastStatus ?? ""}`
        `lastResult=${state?.lastResult ?? ""}`
    ]
    if state?.updatedAt <> invalid
        pieces.push(`updatedAt=${state.updatedAt}`)
    end if
    if extraParts.count() > 0
        for each part in extraParts
            pieces.push(part)
        end for
    end if
    sabr_log(m.logs, log_level_Type.DEBUG, `${logTag} RepeatState ${label}: ${pieces.Join(" ")}`)
end sub

'------------------------------------------------------------------------------
' Function : sabr_logBufferedRanges
' Purpose  : Logs a concise summary of bufferedRanges attached to a SABR
'            request for debugging decisions made by the ABR controller.
'------------------------------------------------------------------------------
sub sabr_logBufferedRanges(logTag as string, requestJson as object)    if not isValid(m?.logs) then return
    if not IsAssociativeArray(requestJson) then return
    ranges = invalid
    if requestJson.DoesExist("clientAbrState") and IsAssociativeArray(requestJson.clientAbrState)
        ranges = requestJson.clientAbrState.Lookup("bufferedRanges")
    else if requestJson.DoesExist("bufferedRanges")
        ranges = requestJson.Lookup("bufferedRanges")
    end if

    summary = []
    if IsArray(ranges)
        for each entry in ranges
            if not IsAssociativeArray(entry) then continue for
            startLabel = sabr_valueToLabel(entry?.rangeStart)
            if startLabel = "" then startLabel = sabr_valueToLabel(entry?.startRange)
            endLabel = sabr_valueToLabel(entry?.rangeEnd)
            if endLabel = "" then endLabel = sabr_valueToLabel(entry?.endRange)
            entryType = sabr_valueToLabel(entry?.type)
            formatKey = sabr_valueToLabel(entry?.formatKey)
            summary.push(`${startLabel}-${endLabel}@${entryType}:${formatKey}`)
        end for
    end if

    selected = []
    selectedIds = requestJson?.selectedFormatIds
    if IsArray(selectedIds)
        for each id in selectedIds
            if IsAssociativeArray(id)
                itagLabel = sabr_valueToLabel(id?.itag)
                xtagLabel = sabr_valueToLabel(id?.xtags)
                selected.push(`${itagLabel}:${xtagLabel}`)
            else
                selected.push(`${id}`)
            end if
        end for
    end if

    if summary.count() = 0 and isValid(ranges)
        rawSummary = ""
        try
            rawSummary = FormatJson(ranges)
        catch e
            rawSummary = "<unserializable>"
        end try
        sabr_log(m.logs, log_level_Type.DEBUG, `${logTag} bufferedRangesRaw=${rawSummary}`)
    end if

    sabr_log(m.logs, log_level_Type.DEBUG, `${logTag} bufferedRanges=${summary.Join(" ")} selected=${selected.Join(",")}`)
end sub

'------------------------------------------------------------------------------
' Function : sabr_guardRepeatedRequests
' Purpose  : Maintains per-segment repeat counters and optionally blocks the
'            response when the player keeps requesting the same byte range.
'------------------------------------------------------------------------------
function sabr_guardRepeatedRequests(playbackContext as object, contentType as string, currentFormat as object, requestMetadataEntry as object, requestNumber as string, videoNode as object, mediaIdHash as string) as dynamic
    if not isValid(playbackContext) then return invalid
    if requestMetadataEntry?.isInit = true then return invalid

    repeatKey = sabr_buildRepeatRequestKey(contentType, currentFormat, requestMetadataEntry?.byteRange)
    if repeatKey = "" then return invalid
    requestMetadataEntry["repeatKey"] = repeatKey

    nowTs = sabr_currentTimestampMs()
    logTag = sabr_utilLogTag(contentType, requestNumber)
    repeatState = playbackContext?.repeatRequestState
    consecutiveCount = 1
    lastKey = ""
    lastCount = 0
    lastUpdated = invalid
    successStreak = 0
    failureStreak = 0

    if IsAssociativeArray(repeatState)
        lastKey = repeatState?.lastKey ?? ""
        lastCount = sabr_toInt(repeatState?.count)
        lastUpdated = sabr_toInt(repeatState?.updatedAt)
        successStreak = sabr_toInt(repeatState?.successStreak)
        failureStreak = sabr_toInt(repeatState?.failureStreak)
    end if

    if lastKey = repeatKey and lastCount <> invalid and lastCount > 0
        if lastUpdated = invalid or (nowTs - lastUpdated) <= SABR_REPEAT_SEGMENT_WINDOW_MS
            consecutiveCount = lastCount + 1
        end if
    else
        successStreak = 0
        failureStreak = 0
    end if

    rangeLabel = sabr_formatRequestedRangeForPath(requestMetadataEntry?.byteRange)
    newState = {
        "lastKey": repeatKey
        "count": consecutiveCount
        "updatedAt": nowTs
        "lastRequestNumber": requestNumber
        "range": rangeLabel
        "formatKey": sabr_formatToKey(currentFormat)
        "successStreak": successStreak
        "failureStreak": failureStreak
        "lastResult": repeatState?.lastResult ?? ""
        "lastStatus": repeatState?.lastStatus
    }
    playbackContext["repeatRequestState"] = newState

    deltaMs = -1
    if lastUpdated <> invalid then deltaMs = nowTs - lastUpdated
    extra = `key=${repeatKey} deltaMs=${deltaMs} range=${rangeLabel}`
    sabr_debugLogRepeatState(contentType, requestNumber, playbackContext, "before_guard", extra)

    if failureStreak < 4 then return invalid

    fatalMessage = `Repeated SABR requests detected for segment ${repeatKey} (range ${rangeLabel}); aborting playback`
    playbackContext["sabrFatalError"] = {
        "reason": fatalMessage
        "requestNumber": requestNumber
        "timestamp": nowTs
    }
    newState["aborted"] = true
    playbackContext["repeatRequestState"] = newState

    sabr_debugLogRepeatState(contentType, requestNumber, playbackContext, "guard_abort", extra)

    sabr_log(m.logs, log_level_Type.WARN, `${logTag} ${fatalMessage}`, false)

    if isValid(videoNode)
        try
            videoNode.control = "stop"
        catch e
            sabr_log(m.logs, log_level_Type.DEBUG, `${logTag} Failed to stop video node after repeat guard: ${e?.message}`)
        end try
    end if

    serialized = FormatJson(playbackContext)
    if isValid(serialized) and serialized <> ""
        writeFile(`tmp:/${mediaIdHash}/playbackContext.json`, serialized)
    end if

    return sabr_buildErrorResponseForPlayer(502, fatalMessage)
end function

'------------------------------------------------------------------------------
' Function : sabr_recordRepeatResult
' Purpose  : Updates repeat-guard success/failure counters based on the latest
'            response so future requests can be nudged or aborted if needed.
'------------------------------------------------------------------------------
sub sabr_recordRepeatResult(playbackContext as object, requestMetadataEntry as object, response as object, contentType = "" as string, requestNumber = invalid as dynamic)    if not isValid(playbackContext) then return
    repeatKey = `${requestMetadataEntry?.repeatKey ?? ""}`
    if repeatKey = "" then return

    repeatState = playbackContext?.repeatRequestState
    if not IsAssociativeArray(repeatState) then return
    if `${repeatState?.lastKey ?? ""}` <> repeatKey then return

    statusVal = sabr_toInt(response?.status)
    success = false
    if statusVal <> invalid
        if statusVal = 206 or ((statusVal >= 200 and statusVal < 300) and statusVal <> 204)
            success = true
        end if
    end if

    if success
        body = response?.body
        bodyPath = sabr_toSafeString(response?.bodyPath)
        if GetInterface(body, "ifByteArray") <> invalid and body.count() = 0 and bodyPath = ""
            success = false
        end if
    end if

    successCount = sabr_toInt(repeatState?.successStreak)
    if successCount = invalid then successCount = 0
    failureCount = sabr_toInt(repeatState?.failureStreak)
    if failureCount = invalid then failureCount = 0

    if success
        repeatState["successStreak"] = successCount + 1
        repeatState["failureStreak"] = 0
    else
        repeatState["failureStreak"] = failureCount + 1
        repeatState["successStreak"] = 0
    end if

    repeatState["lastResult"] = success ? "success" : "failure"
    repeatState["lastStatus"] = statusVal
    repeatState["updatedAt"] = sabr_currentTimestampMs()

    playbackContext["repeatRequestState"] = repeatState

    if contentType <> ""
        if requestNumber = invalid then requestNumber = requestMetadataEntry?.requestNumber
        extra = `key=${repeatKey} status=${statusVal} success=${success}`
        sabr_debugLogRepeatState(contentType, requestNumber, playbackContext, "after_result", extra)
    end if
end sub

function sabr_formatTypeFromFormat(format as dynamic) as string
    mimeType = format?.mimeType ?? ""
    if mimeType.inStr("audio") > -1 then return "AUDIO"
    if mimeType.inStr("video") > -1 then return "VIDEO"
    if isValid(format?.width) then return "VIDEO"
    return "AUDIO"
end function

'------------------------------------------------------------------------------
' Function : sabr_normalizeByteRange
' Purpose  : Produces a canonical byte range map with string fields so cache
'            keys and SABR payloads avoid inconsistencies in field naming.
'------------------------------------------------------------------------------
function sabr_normalizeByteRange(rawRange as object, context = invalid as dynamic) as object
    normalized = {
        "startRange": ""
        "endRange": ""
    }

    if isValid(rawRange)
        startLabel = `${rawRange?.startRange ?? ""}`
        if startLabel = "" then startLabel = `${rawRange?.start ?? ""}`
        endLabel = `${rawRange?.endRange ?? ""}`
        if endLabel = "" then endLabel = `${rawRange?.end ?? ""}`
        if startLabel <> "" then normalized["startRange"] = startLabel
        if endLabel <> "" then normalized["endRange"] = endLabel
    end if

    if isValid(context?.segmentIndexInfo)
        normalized["segmentIndexInfo"] = context.segmentIndexInfo
    end if
    if isValid(context?.sequenceNumber)
        normalized["sequenceNumber"] = `${context.sequenceNumber}`
    end if

    return normalized
end function

'------------------------------------------------------------------------------
' Function : sabr_byteRangeToCoverage
' Purpose  : Converts SABR byte-range structures into numeric start/end pairs
'            suitable for logging, caching, and Content-Range calculations.
'------------------------------------------------------------------------------
function sabr_byteRangeToCoverage(byteRange as object) as dynamic
    startVal = invalid
    endVal = invalid

    startLabel = `${byteRange?.startRange ?? ""}`
    if startLabel = "" then startLabel = `${byteRange?.start ?? ""}`
    if startLabel <> ""
        startVal = sabr_toInt(startLabel)
    end if

    endLabel = `${byteRange?.endRange ?? ""}`
    if endLabel = "" then endLabel = `${byteRange?.end ?? ""}`
    if endLabel <> ""
        endVal = sabr_toInt(endLabel)
    end if

    if not isValid(startVal) then return invalid
    if not isValid(endVal) then return invalid
    if endVal < startVal then return invalid

    return {
        "rangeStart": startVal
        "rangeEnd": endVal
    }
end function

'------------------------------------------------------------------------------
' Function : sabr_rangesMatch
' Purpose  : Compares two byte-range objects regardless of field naming so we
'            can identify init/index requests reliably.
'------------------------------------------------------------------------------
function sabr_rangesMatch(rangeObj as dynamic, requestRange as object) as boolean
    if not isValid(rangeObj) then return false

    expectedStart = `${rangeObj?.start ?? "0"}`
    if expectedStart = "" then expectedStart = `${rangeObj?.startRange ?? "0"}`
    expectedEnd = `${rangeObj?.end ?? "0"}`
    if expectedEnd = "" then expectedEnd = `${rangeObj?.endRange ?? "0"}`

    requestStart = `${requestRange?.startRange ?? "0"}`
    if requestStart = "" then requestStart = `${requestRange?.start ?? "0"}`
    requestEnd = `${requestRange?.endRange ?? "0"}`
    if requestEnd = "" then requestEnd = `${requestRange?.end ?? "0"}`

    if expectedStart = "" or expectedEnd = "" then return false
    if requestStart = "" or requestEnd = "" then return false
    return (expectedStart = requestStart) and (expectedEnd = requestEnd)
end function


'------------------------------------------------------------------------------
' Function : sabr_deleteFileIfExists
' Purpose  : Deletes a file path defensively when cleaning up tmp artifacts.
'------------------------------------------------------------------------------
sub sabr_deleteFileIfExists(path as dynamic)    if not isValid(path) then return
    if not IsString(path) then return
    if path = "" then return

    fs = CreateObject("roFileSystem")
    if fs.Exists(path)
        fs.Delete(path)
    end if
end sub

function sabr_utilLogTag(contentType as string, requestRef = invalid as dynamic) as string
    rn = sabr_extractRequestNumber(requestRef)
    if rn = ""
        return `[YTSABR-Util-${contentType}]`
    end if
    return `[YTSABR-Util-${contentType}-${rn}]`
end function

'------------------------------------------------------------------------------
' Function : sabr_getActiveFormats
' Purpose  : Chooses the best guess for active audio/video formats by checking
'            the current selection, playback context history, and fallback picks.
'------------------------------------------------------------------------------
function sabr_getActiveFormats(currentFormat as object, sabr as object, playbackContext as object) as object
    formats = sabr.adaptiveFormats
    videoFormat = invalid
    audioFormat = invalid

    mimeType = currentFormat?.mimeType ?? ""
    if mimeType.inStr("video") > -1 or isValid(currentFormat?.width)
        videoFormat = currentFormat
    else if mimeType.inStr("audio") > -1 or not isValid(currentFormat?.width)
        audioFormat = currentFormat
    end if

    if not isValid(videoFormat)
        videoFormat = playbackContext?.lastVideoFormat
    end if
    if not isValid(audioFormat)
        audioFormat = playbackContext?.lastAudioFormat
    end if

    if not isValid(videoFormat)
        videoFormat = sabr_pickBestFormat(formats, "video")
    end if
    if not isValid(audioFormat)
        audioFormat = sabr_pickBestFormat(formats, "audio")
    end if

    if isValid(videoFormat)
        playbackContext["lastVideoFormat"] = videoFormat
    end if
    if isValid(audioFormat)
        playbackContext["lastAudioFormat"] = audioFormat
    end if

    return {
        "videoFormat": videoFormat,
        "audioFormat": audioFormat
    }
end function

'------------------------------------------------------------------------------
' Function : sabr_pickBestFormat
' Purpose  : Selects the highest bitrate format matching the requested media
'            type from YouTube SABR adaptive format listings.
'------------------------------------------------------------------------------
function sabr_pickBestFormat(formats as dynamic, mediaType as string) as dynamic
    if not isValid(formats) then return invalid
    bestFormat = invalid
    bestBitrate = 0
    targetKeyword = mediaType = "audio" ? "audio" : "video"

    for each format in formats
        mimeType = format?.mimeType ?? ""
        if mimeType.inStr(targetKeyword) > -1
            bitrate = sabr_toInt(format?.bitrate)
            if bitrate = invalid then bitrate = sabr_toInt(format?.averageBitrate)
            if bitrate <> invalid and bitrate > bestBitrate
                bestBitrate = bitrate
                bestFormat = format
            end if
        end if
    end for

    return bestFormat
end function

function sabr_pickMeasuredBitrate(info as dynamic) as dynamic
    if not isValid(info) then return invalid
    if isValid(info.measuredBitrate) and info.measuredBitrate > 0 then return info.measuredBitrate
    if isValid(info.streamBitrate) and info.streamBitrate > 0 then return info.streamBitrate
    return invalid
end function

'------------------------------------------------------------------------------
' Function : sabr_createVideoPlaybackAbrRequest
' Purpose  : Builds the VideoPlaybackAbrRequest protobuf for the current
'            segment, wiring in buffered ranges, playerTime, and metadata hints.
'------------------------------------------------------------------------------
function sabr_createVideoPlaybackAbrRequest(request as object, contentType as string, sabr as object, currentFormat as object, activeFormats as object, playbackContext as object, playerTimeOverride as dynamic, videoNode as object, requestRef = invalid as dynamic) as object
    ' Create the ABR request object
    logTag = sabr_utilLogTag(contentType, requestRef)
    if not isValid(sabr.ustreamerConfig)
        sabr_log(m.logs, log_level_Type.WARN, `${logTag} No SABR ustreamerConfig available`, false)
        return {}
    end if

    streamerContext = {
        "poToken": sabr.poToken,
        "playbackCookie": invalid, ' the playbackContext.lastPlaybackCookie will be set on handling the response nextRequestPolicy.playbackCookie
        "clientInfo": sabr.clientInfo,
        "sabrContexts": [],
        "unsentSabrContexts": [],
    }

    if isValid(playbackContext.lastPlaybackCookie)
        streamerContext["playbackCookie"] = playbackContext.lastPlaybackCookie
    end if

    if isValid(playbackContext.sabrContexts)
        streamerContext["sabrContexts"] = []
        for each key in playbackContext.sabrContexts
            streamerContext.sabrContexts.push(playbackContext.sabrContexts[key])
        end for
    end if

    playbackContext["lastPlayerTimeSecs"] = videoNode.position

    sabr_log(m.logs, log_level_Type.INFO, `${logTag} streamingSegment : ${FormatJson(videoNode.streamingSegment)}`)

    bandwidthEstimate = sabr_pickMeasuredBitrate(videoNode.completedStreamInfo)
    if not isValid(bandwidthEstimate)
        bandwidthEstimate = sabr_pickMeasuredBitrate(videoNode.streamInfo)
    end if
    if not isValid(bandwidthEstimate) and isValid(videoNode.streamingSegment) and isValid(videoNode.streamingSegment.segBitrateBps)
        bandwidthEstimate = videoNode.streamingSegment.segBitrateBps
    end if
    ' if not isValid(bandwidthEstimate) and isValid(videoNode.segment) and isValid(videoNode.segment.bandwidth)
    '     bandwidthEstimate = videoNode.segment.bandwidth
    ' end if
    if not isValid(bandwidthEstimate) or bandwidthEstimate <= 0
        bandwidthEstimate = currentFormat?.bitrate ?? 0
    end if
    if bandwidthEstimate <= 0 then bandwidthEstimate = 2000000
    if SABR_BANDWIDTH_OVERRIDE_BPS > 0
        bandwidthEstimate = SABR_BANDWIDTH_OVERRIDE_BPS
    else if SABR_BANDWIDTH_MULTIPLIER <> 1.0 and SABR_BANDWIDTH_MULTIPLIER > 0
        bandwidthEstimate = Int(bandwidthEstimate * SABR_BANDWIDTH_MULTIPLIER)
    end if

    AUDIO_ONLY = 1
    VIDEO_ONLY = 2

    overrideMs = sabr_toInt(playerTimeOverride)
    overrideUsed = overrideMs <> invalid
    desiredPlayerTimeMs = overrideMs
    if desiredPlayerTimeMs = invalid or desiredPlayerTimeMs < 0
        desiredPlayerTimeMs = sabr_toInt(playbackContext?.lastRequestedPlayerTimeMs)
        if desiredPlayerTimeMs = invalid or desiredPlayerTimeMs < 0 then desiredPlayerTimeMs = 0
        overrideUsed = false
    end if

    playbackContext["lastRequestedPlayerTimeMs"] = desiredPlayerTimeMs
    playbackContext["lastPlayerTimeSecs"] = videoNode.position

    ' include the request byte range in the log
    overrideNote = overrideUsed ? " (derived from byte range)" : " (fallback)"
    sabr_log(m.logs, log_level_Type.INFO, `${logTag} Creating SABR ABR request with playerTimeMs=${desiredPlayerTimeMs}, byteRange=${FormatJson(request.search)}, bandwidthEstimate=${bandwidthEstimate}${overrideNote}`)

    req = {
        "clientAbrState": {
            "playbackRate": videoNode.playbackSpeed ?? 1.0,
            "playerTimeMs": desiredPlayerTimeMs.toStr(),
            "clientViewportIsFlexible": false,
            "bandwidthEstimate": bandwidthEstimate.toStr(),
            "drcEnabled": currentFormat.isDrc ?? false,
            "enabledTrackTypesBitfield": isValid(currentFormat.width) ? VIDEO_ONLY : AUDIO_ONLY,
            "audioTrackId": currentFormat.audioTrackId
        },
        "bufferedRanges": [],
        "selectedFormatIds": [],
        "preferredAudioFormatIds": [activeFormats.audioFormat ?? {}],
        "preferredVideoFormatIds": [activeFormats.videoFormat ?? {}],
        "preferredSubtitleFormatIds": [],
        "videoPlaybackUstreamerConfig": sabr.ustreamerConfig,
        "streamerContext": streamerContext,
        "field1000": []
    }

    return req

end function

'     playbackContext["initializedFormats"] = initializedFormats
'     return initializedFormats
' end function

'------------------------------------------------------------------------------
' Function : sabr_createFullBufferRange
' Purpose  : Creates a sentinel buffered range that convinces SABR the player
'            already owns an entire format, forcing it to skip delivery.
'------------------------------------------------------------------------------
function sabr_createFullBufferRange(format as object) as object
    MAX_INT32_VALUE = 2147483647
    return {
        "formatId": sabr_formatToFormatId(format),
        "durationMs": MAX_INT32_VALUE,
        "startTimeMs": "0",
        "startSegmentIndex": MAX_INT32_VALUE,
        "endSegmentIndex": MAX_INT32_VALUE,
        "timeRange": {
            "durationTicks": MAX_INT32_VALUE,
            "startTicks": "0",
            "timescale": 1000
        }
    }
end function

'------------------------------------------------------------------------------
' Function : sabr_buildResponseForPlayer
' Purpose  : Converts UMP spool results into an HTTP response tailored for the
'            Roku video player, including headers, coverage, and chunk plan.
'------------------------------------------------------------------------------
function sabr_buildResponseForPlayer(requestMetadata as object, umpResult as dynamic, currentFormat as object, requestByteRange as object, contentType as string) as object
     headers = CreateObject("roAssociativeArray")
    itagLabelForHeader = sabr_valueToLabel(currentFormat?.itag)
    if itagLabelForHeader = "" then itagLabelForHeader = `${requestMetadata?.format?.itag ?? ""}`
    if itagLabelForHeader <> ""
        headers["X-Cache-Itag"] = itagLabelForHeader
    end if

    mimeType = currentFormat?.mimeType
    if not isValid(mimeType) or mimeType = ""
        upperType = UCase(contentType)
        if upperType = "AUDIO"
            mimeType = "audio/mp4"
        else if upperType = "VIDEO"
            mimeType = "video/mp4"
        else
            mimeType = "application/octet-stream"
        end if
    end if
    headers["Content-Type"] = mimeType
    headers["Accept-Ranges"] = "bytes"

    requestedCoverage = sabr_byteRangeToCoverage(requestByteRange)

    chunkPlan = invalid
    chunkPath = ""
    coverage = invalid
    if IsAssociativeArray(umpResult)
        chunkPlan = umpResult.Lookup("chunks")
        chunkPath = sabr_toSafeString(umpResult?.path)
        coverage = umpResult?.coverage
    end if

    if IsArray(chunkPlan) and chunkPlan.count() > 0 and chunkPath <> ""
        totalBytes = sabr_toInt(umpResult?.totalBytes)
        if totalBytes = invalid or totalBytes <= 0
            totalBytes = 0
            for each chunkEntry in chunkPlan
                lenVal = sabr_toInt(chunkEntry?.length)
                if lenVal <> invalid then totalBytes = totalBytes + lenVal
            end for
        end if
        if totalBytes < 0 then totalBytes = 0

        rangeInfo = coverage
        if not IsAssociativeArray(rangeInfo)
            rangeInfo = {}
        end if
        rangeStart = sabr_toInt(rangeInfo?.rangeStart)
        rangeEnd = sabr_toInt(rangeInfo?.rangeEnd)
        if rangeStart = invalid and IsAssociativeArray(requestedCoverage)
            rangeStart = sabr_toInt(requestedCoverage?.rangeStart)
        end if
        if rangeStart = invalid then rangeStart = 0
        if rangeEnd = invalid and totalBytes > 0
            rangeEnd = rangeStart + totalBytes - 1
        end if

        requestedStart = invalid
        requestedEnd = invalid
        if IsAssociativeArray(requestedCoverage)
            requestedStart = sabr_toInt(requestedCoverage?.rangeStart)
            requestedEnd = sabr_toInt(requestedCoverage?.rangeEnd)
        end if

        status = 200
        if requestedStart <> invalid
            status = 206
            if requestedEnd = invalid
                if rangeEnd <> invalid
                    requestedEnd = rangeEnd
                else
                    requestedEnd = requestedStart + totalBytes - 1
                end if
            end if
            totalLabel = "*"
            if rangeEnd <> invalid
                totalLabel = (rangeEnd + 1).toStr()
            end if
            headers["Content-Range"] = `bytes ${requestedStart}-${requestedEnd}/${totalLabel}`
        end if

        headers["Content-Length"] = totalBytes.toStr()

        coverageReturn = CreateObject("roAssociativeArray")
        if rangeStart <> invalid then coverageReturn["rangeStart"] = rangeStart
        if rangeEnd <> invalid then coverageReturn["rangeEnd"] = rangeEnd

        response = {
            "status": status
            "headers": headers
            "path": chunkPath
            "chunks": chunkPlan
            "totalBytes": totalBytes
        }
        if coverageReturn.Count() > 0
            response["coverage"] = coverageReturn
        end if
        if umpResult?.isInitSeg = true
            response["isInitSeg"] = true
        end if
        return response
    end if

    dataBytes = invalid
    if IsAssociativeArray(umpResult)
        dataCandidate = umpResult.Lookup("data")
        if GetInterface(dataCandidate, "ifByteArray") <> invalid
            dataBytes = dataCandidate
        end if
    end if

    if dataBytes <> invalid and dataBytes.count() > 0
        totalBytes = dataBytes.count()
        requestedStart = invalid
        requestedEnd = invalid
        if IsAssociativeArray(requestedCoverage)
            requestedStart = sabr_toInt(requestedCoverage?.rangeStart)
            requestedEnd = sabr_toInt(requestedCoverage?.rangeEnd)
        end if
        status = 200
        if requestedStart <> invalid
            status = 206
            if requestedEnd = invalid then requestedEnd = requestedStart + totalBytes - 1
            headers["Content-Range"] = `bytes ${requestedStart}-${requestedEnd}/*`
        end if
        headers["Content-Length"] = totalBytes.toStr()
        return {
            "status": status
            "headers": headers
            "body": dataBytes
        }
    end if

    pathCandidate = ""
    if IsAssociativeArray(umpResult)
        pathCandidate = sabr_toSafeString(umpResult?.path)
    end if
    if pathCandidate <> ""
        sizeVal = sabr_fsGetFileSize(pathCandidate)
        if sizeVal <> invalid and sizeVal > 0
            requestedStart = invalid
            requestedEnd = invalid
            if IsAssociativeArray(requestedCoverage)
                requestedStart = sabr_toInt(requestedCoverage?.rangeStart)
                requestedEnd = sabr_toInt(requestedCoverage?.rangeEnd)
            end if
            status = 200
            if requestedStart <> invalid
                status = 206
                if requestedEnd = invalid then requestedEnd = requestedStart + sizeVal - 1
                headers["Content-Range"] = `bytes ${requestedStart}-${requestedEnd}/${sizeVal}`
            end if
            headers["Content-Length"] = sizeVal.toStr()
            return {
                "status": status
                "headers": headers
                "bodyPath": pathCandidate
                "bodyOffset": 0
                "bodyLength": sizeVal
            }
        end if
    end if

    headers["Content-Length"] = "0"
    emptyBody = CreateObject("roByteArray")
    return {
        "status": 204
        "headers": headers
        "body": emptyBody
    }
end function

'------------------------------------------------------------------------------
' Function : sabr_buildEmptyResponseForPlayer
' Purpose  : Produces a 204 response with appropriate headers when SABR has no
'            payload to send but the player still expects a valid reply.
'------------------------------------------------------------------------------
function sabr_buildEmptyResponseForPlayer(contentType as string, currentFormat as object) as object
    body = CreateObject("roByteArray")

    mimeType = currentFormat?.mimeType ?? ""
    if mimeType = ""
        if contentType = "VIDEO"
            mimeType = "video/mp4"
        else if contentType = "AUDIO"
            mimeType = "audio/mp4"
        else
            mimeType = "application/octet-stream"
        end if
    end if

    headers = {
        "Content-Length": "0"
        "Accept-Ranges": "bytes"
        "Cache-Control": "no-store"
        "Content-Type": mimeType
    }

    return {
        "status": 204
        "headers": headers
        "body": body
    }
end function

'------------------------------------------------------------------------------
' Function : sabr_fsGetFileSize
' Purpose  : Wraps roFileSystem.Stat so we can safely query file sizes without
'            duplicating error handling at every call site.
'------------------------------------------------------------------------------
function sabr_fsGetFileSize(path as string) as dynamic
    if not IsString(path) or path = "" then return invalid
    fs = CreateObject("roFileSystem")
    stat = invalid
    try
        stat = fs.Stat(path)
    catch e
        stat = invalid
    end try
    if IsAssociativeArray(stat)
        sizeVal = stat.Lookup("size")
        if sizeVal = invalid then sizeVal = stat.Lookup("length")
        return sizeVal
    end if
    return invalid
end function

'------------------------------------------------------------------------------
' Function : sabr_buildErrorResponseForPlayer
' Purpose  : Returns a simple text/plain HTTP response for SABR failures so the
'            Roku player sees a concrete status and diagnostic message.
'------------------------------------------------------------------------------
function sabr_buildErrorResponseForPlayer(status as integer, message as string) as object
    body = CreateObject("roByteArray")
    if isValid(message) and message <> ""
        body.FromAsciiString(message)
    end if

    headers = {
        "Content-Type": "text/plain"
        "Content-Length": body.count().toStr()
        "Connection": "close"
    }

    return {
        "status": status
        "headers": headers
        "body": body
    }
end function

function sabr_isFileStreamingEnabled() as boolean
    return true
end function

'------------------------------------------------------------------------------
' Function : sabr_applyStreamInfoUpdates
' Purpose  : Merges stream-level metadata from a SABR response (next request
'            policy, context updates, playback cookies) into local state.
'------------------------------------------------------------------------------
sub sabr_applyStreamInfoUpdates(playbackContext as object, streamInfo as object, contentType as string, deliveredSegment = true as boolean, requestMetadataEntry = invalid as dynamic)    if not isValid(streamInfo) then return

    sidxUpdates = streamInfo?.sidxIndexUpdates
    if IsArray(sidxUpdates)
        for each sidxUpdate in sidxUpdates
            sabr_storeSidxIndexUpdate(playbackContext, contentType, sidxUpdate)
        end for
    else if IsAssociativeArray(streamInfo?.sidxIndexUpdate)
        sabr_storeSidxIndexUpdate(playbackContext, contentType, streamInfo.sidxIndexUpdate)
    end if

    if isValid(streamInfo.nextRequestPolicy)
        playbackContext["nextRequestPolicy"] = streamInfo.nextRequestPolicy
        if isValid(streamInfo.nextRequestPolicy.playbackCookie)
            playbackContext["lastPlaybackCookie"] = PlaybackCookieEncode(streamInfo.nextRequestPolicy.playbackCookie)
        end if
        playbackContext["backoffTimeMs"] = streamInfo.nextRequestPolicy.backoffTimeMs
    end if

    if isValid(streamInfo.sabrContextSendingPolicy)
        playbackContext["sabrContextSendingPolicy"] = streamInfo.sabrContextSendingPolicy
    end if

    if isValid(streamInfo.formatInitMetadata)
        playbackContext["formatInitializationMetadata"] = streamInfo.formatInitMetadata
    end if

    if isValid(streamInfo.streamProtectionStatus)
        playbackContext["streamProtectionStatus"] = streamInfo.streamProtectionStatus
    end if

    if IsAssociativeArray(streamInfo) and streamInfo.DoesExist("deliveredCoverage")
        streamInfo.Delete("deliveredCoverage")
    end if
end sub

'------------------------------------------------------------------------------
' Function : sabr_logSpoolSummary
' Purpose  : Emits a concise overview of a decoded UMP spool map including
'            size, duration, and diagnostic counters for troubleshooting.
'------------------------------------------------------------------------------
sub sabr_logSpoolSummary(logs as object, logTag as string, spoolMap as dynamic)    if not IsAssociativeArray(spoolMap) then return

    parts = spoolMap?.parts
    partCount = 0
    if IsArray(parts)
        partCount = parts.count()
    end if

    durationMs = sabr_toInt(spoolMap?.durationMs)
    if durationMs = invalid then durationMs = 0
    totalBytes = sabr_toInt(spoolMap?.totalbytes)
    if totalBytes = invalid then totalBytes = 0
    readsVal = sabr_toInt(spoolMap?.reads)
    actualBytes = sabr_toInt(spoolMap?.actualBytesRead)

    summary = `${logTag} UMP spool scan duration=${durationMs}ms parts=${partCount} bytes=${totalBytes}`
    if readsVal <> invalid then summary = `${summary} reads=${readsVal}`
    if actualBytes <> invalid then summary = `${summary} actualBytesRead=${actualBytes}`
    if spoolMap?.containsInit = true then summary = `${summary} init=true`
    sabr_log(logs, log_level_Type.INFO, summary)

    if not IsArray(parts) then return
    previewCount = parts.count()
    if previewCount <= 0 then return
    if previewCount > 5 then previewCount = 5

    previews = []
    for idx = 0 to previewCount - 1
        part = parts[idx]
        typeLabel = sabr_toSafeString(part?.typeLabel)
        if typeLabel = "" then typeLabel = sabr_toSafeString(part?.type)
        offsetLabel = sabr_toSafeString(part?.offset)
        sizeLabel = sabr_toSafeString(part?.payloadSize)
        preview = `${typeLabel}@${offsetLabel}+${sizeLabel}`
        header = part?.mediaHeader
        if IsAssociativeArray(header)
            startVal = sabr_toInt(header?.startRange)
            if startVal = invalid then startVal = sabr_toInt(header?.start)
            lengthVal = sabr_toInt(header?.contentLength)
            if startVal <> invalid and lengthVal <> invalid and lengthVal > 0
                preview = `${preview}[${startVal}-${startVal + lengthVal - 1}]`
            end if
            if header.DoesExist("isInitSeg") and header.isInitSeg = true
                preview = `${preview}{init}`
            end if
        end if
        previews.push(preview)
    end for

    previewSummary = previews.Join(", ")
    if previewSummary <> ""
        sabr_log(logs, log_level_Type.DEBUG, `${logTag} UMP spool preview ${previewSummary}`)
    end if
end sub
