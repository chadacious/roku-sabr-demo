import "pkg:/source/ytproto/generated/runtime.brs"
import "pkg:/source/ytproto/generated/messages/VideoPlaybackAbrRequest.brs"
import "pkg:/source/ytproto/generated/messages/ClientAbrState.brs"
import "pkg:/source/ytproto/generated/messages/FormatId.brs"
import "pkg:/source/ytproto/generated/messages/StreamerContext.brs"
import "pkg:/source/ytproto/generated/messages/ClientInfo.brs"
import "pkg:/source/ytproto/generated/messages/TimeRange.brs"
import "pkg:/source/ytproto/generated/messages/BufferedRange.brs"
import "pkg:/source/ytproto/generated/messages/StreamerContext.brs"
import "pkg:/source/ytproto/generated/messages/SabrContext.brs"
import "pkg:/source/ytproto/generated/messages/GLDeviceInfo.brs"
import "pkg:/source/ytproto/generated/messages/MediaCapabilities.brs"
import "pkg:/source/ytproto/generated/messages/VideoFormatCapability.brs"
import "pkg:/source/ytproto/generated/messages/AudioFormatCapability.brs"
import "pkg:/source/ytproto/generated/messages/PlaybackAuthorization.brs"
import "pkg:/source/ytproto/generated/messages/AuthorizedFormat.brs"
import "pkg:/source/ytproto/generated/messages/Range.brs"
import "pkg:/source/ytproto/generated/messages/PlaybackCookie.brs"
import "pkg:/source/ytproto/generated/messages/UnknownInnerMessage.brs"
import "pkg:/source/ytproto/generated/messages/UnknownInnerMessage1.brs"
import "pkg:/source/ytproto/generated/messages/UnknownMessage3.brs"
import "pkg:/source/ytproto/generated/messages/VideoStreamingBufferedRangeUnknownMessage1.brs"
import "pkg:/source/ytproto/generated/messages/VideoStreamingBufferedRangeUnknownMessage2.brs"
import "pkg:/source/ytproto/generated/messages/VideoStreamingStreamerContextUnknownMessage1.brs"
import "pkg:/source/ytproto/generated/messages/VideoStreamingUnknownMessage1.brs"
import "pkg:/source/ytproto/generated/messages/VideoStreamingUnknownMessage2.brs"
import "pkg:/source/SabrUmpProcessor.bs"
import "pkg:/source/SabrRequestMetadataManager.bs"
import "pkg:/source/isItem.bs"
import "pkg:/source/httpRequest.bs"
import "pkg:/source/SabrDebug.bs"
import "pkg:/source/SabrUtils.bs"
import "pkg:/source/taskUtils.bs"
import "pkg:/source/SabrInstrumentation.bs"

' Number of repeated requests before repeat guard fires
const SABR_REPEAT_SEGMENT_THRESHOLD = 4
' Time window (ms) for repeat guard to track duplicate requests
const SABR_REPEAT_SEGMENT_WINDOW_MS = 5000
' Base limit for buffered ranges reported to SABR per content type
const SABR_BASE_BUFFERED_RANGE_LIMIT = 1

' Optional knobs to push the SABR server toward higher-bitrate renditions
' Force all ABR requests to advertise this bandwidth (0 disables override)
const SABR_BANDWIDTH_OVERRIDE_BPS = 0 ' i.e. 25000000
' Scale measured bandwidth by this factor when override is zero
const SABR_BANDWIDTH_MULTIPLIER = 1.0 ' i.e. 1.5
' Toggle between streaming cached segments from disk and loading them into memory.
const SABR_ENABLE_FILE_STREAMING = true
' Default fallback amount (ms) to bump playerTimeMs beyond the segment start to avoid repeat coverage.
const SABR_PLAYER_TIME_DEFAULT_BUMP_MS = 2000

' Buffered range synthesis modes used to influence SABR responses.
const SABR_BUFFER_MODE_BASELINE = "baseline"
const SABR_BUFFER_MODE_SEEK_PREVIOUS = "seek-guard-previous"
const SABR_BUFFER_MODE_BOUNDED = "bounded"
' Active buffering mode (baseline: only real cached coverage)
const SABR_BUFFER_MODE = SABR_BUFFER_MODE_BASELINE ' switch to bounded/seek modes for experiments

const SABR_MAX_RESP_SECONDS = 110
const SABR_PENDING_SEGMENT_TIMEOUT_MS = 10000

' Player-time resolution strategies supported by the adapter
const PLAYER_TIME_STRATEGY_SIDX = "sidx"
const PLAYER_TIME_STRATEGY_METADATA = "metadata"
const PLAYER_TIME_STRATEGY_HYBRID = "hybrid"
' Default player-time strategy used when no override is provided
const DEFAULT_PLAYER_TIME_STRATEGY = PLAYER_TIME_STRATEGY_HYBRID


' Handles an intercepted SABR segment request from the Roku video stack.
' - request: parsed HTTP request from the local SABR server.
' - contentType: "VIDEO" or "AUDIO" to drive format selection.
' - mediaIdHash: unique directory key where SABR payloads live under tmp:/.
' - sabr: decoded SABR payload metadata (formats, context, etc).
' - videoNode: player node for querying seek position and playback hints.
' - redirectDepth: recursion guard when SABR instructs us to retry/redirect.
' Returns a response object (status, headers, body or bodyPath) ready to send.
function sabr_handleRequest(request as object, contentType as string, mediaIdHash as string, sabr as object, videoNode as object, queuedAtMs = invalid as dynamic, redirectDepth = 0 as integer) as object
    sabr_traceCall("sabr_handleRequest")
    ok = true

    sabrAbrUrl = ""
    playbackContext = invalid
    response = invalid
    requestTimer = invalid
    requestLogTag = `[YTSABR-${contentType}]`
    if isValid(m?.logs)
        requestTimer = m.logs.mark()
    end if
    sessionKey = invalid
    requestStartMs = sabr_currentTimestampMs()
    timingInfo = CreateObject("roAssociativeArray")
    timingInfo["requestStartMs"] = requestStartMs
    queuedAtValue = sabr_toInt(queuedAtMs)
    if queuedAtValue <> invalid
        timingInfo["queuedAtMs"] = queuedAtValue
    end if

    ' Load playback context for media and validate cached metadata from tmp:/${mediaIdHash}/playbackContext.json
    playbackContextPath = `tmp:/${mediaIdHash}/playbackContext.json`
    fileContent = getFile(playbackContextPath)
    if fileContent = invalid or fileContent = ""
        sabr_log(m.logs, log_level_Type.WARN, `[YTSABR-Util-${contentType}] No SABR playbackContext file found for mediaIdHash: ${mediaIdHash}`, false)
    else
        parsedOk = true
        try
            playbackContext = ParseJson(fileContent)
        catch e
            parsedOk = false
            detail = sabr_formatExceptionDetail(e)
            snippet = fileContent.left(256)
            sabr_log(m.logs, log_level_Type.WARN, `[YTSABR-Util-${contentType}] Failed to parse playbackContext (${playbackContextPath}): ${detail}`, false)
            sabr_log(m.logs, log_level_Type.DEBUG, `[YTSABR-Util-${contentType}] playbackContext snippet: ${snippet}`, true)
        end try
        if parsedOk = false or not IsAssociativeArray(playbackContext)
            playbackContext = invalid
            sabr_log(m.logs, log_level_Type.WARN, `[YTSABR-Util-${contentType}] Invalid SABR playbackContext file for mediaIdHash: ${mediaIdHash}; rebuilding`, false)
        else
            sabr_log(m.logs, log_level_Type.INFO, `[YTSABR-Util-${contentType}] Loaded SABR playbackContext from file for mediaIdHash: ${mediaIdHash}`)
        end if
    end if

    if not IsAssociativeArray(playbackContext)
        playbackContext = CreateObject("roAssociativeArray")
        playbackContext["mediaIdHash"] = mediaIdHash
        sabr_log(m.logs, log_level_Type.WARN, `[YTSABR-Util-${contentType}] No valid SABR playback context available; initialized empty context`, false)
    else if not playbackContext.DoesExist("mediaIdHash")
        playbackContext["mediaIdHash"] = mediaIdHash
    end if

    fatalInfo = playbackContext?.sabrFatalError
    if isValid(fatalInfo)
        fatalReason = fatalInfo?.reason ?? "SABR fatal error"
        sabr_log(m.logs, log_level_Type.WARN, `[YTSABR-Util-${contentType}] Blocking SABR request due to fatal error: ${fatalReason}`, false)
        return sabr_buildErrorResponseForPlayer(502, fatalReason)
    end if

    ' Ensure cache/task infrastructure exists before handling segments
    sabr_ensureInfrastructure()
    metadataManager = m.sabrRequestMetadataManager
    debugUploadUrl = m.top.debugUploadUrl ?? ""

    formats = sabr?.adaptiveFormats
    if not isValid(formats) or formats.count() = 0
        formats = sabr?.hlsFormats
        if not isValid(formats) or formats.count() = 0
            ok = false
            sabr_log(m.logs, log_level_Type.WARN, `[YTSABR-Util-${contentType}] No SABR formats available`, false)
        end if
    end if

    sabrAbrUrl = sabr?.serverAbrStreamingUrl
    if not isValid(sabrAbrUrl) or sabrAbrUrl = ""
        ok = false
        sabr_log(m.logs, log_level_Type.WARN, `[YTSABR-Util-${contentType}] No SABR URL provided`, false)
    end if

    ' Assign a unique request number and patch SABR URL
    ' nextRequestId = generateSabrRequestNumber(playbackContext, contentType)
    nextRequestId = m.top.utilsTask.callFunc("getNextId", "sabrRequestNumber")
    playbackContext["requestNumber"] = nextRequestId
    requestLogTag = sabr_utilLogTag(contentType, nextRequestId)
    sabr_log(m.logs, log_level_Type.INFO, `${requestLogTag} SABR playback request number: ${nextRequestId}`)

    ' Update SABR URL with request number token param (or create it) to be the request number
    regexRn = CreateObject("roRegex", "([&?])rn=[^&]*", "i")
    if regexRn.match(sabrAbrUrl).count() > 0
        sabrAbrUrl = regexRn.replaceAll(sabrAbrUrl, `\1rn=${nextRequestId}`)
    else
        sep = sabrAbrUrl.inStr("?") > -1 ? "&" : "?"
        sabrAbrUrl = `${sabrAbrUrl}${sep}rn=${nextRequestId}`
    end if
    sabr_log(m.logs, log_level_Type.INFO, `${requestLogTag} URL: ${sabrAbrUrl}`)

    ' Resolve requested format from query params

    keyParam = request.search.key
    try
        if not isValid(keyParam) or keyParam = ""
            ok = false
            sabr_log(m.logs, log_level_Type.WARN, `${requestLogTag} No SABR itag key provided`, false)
        else
            keyParts = keyParam.split(":")
            currentKeyItag = sabr_toInt(keyParts[0])
            currentKeyXTag = keyParts.count() > 1 ? keyParts[1] : ""
            currentFormat = invalid
            for each format in formats
                if format.itag = currentKeyItag and (format?.xTag ?? "") = currentKeyXTag
                    currentFormat = format
                    exit for
                end if
            end for
        end if
    catch e
        ok = false
        sabr_log(m.logs, log_level_Type.WARN, `${requestLogTag} Error finding format for itag: ${keyParam} - ${e.message}`, false)
    end try

    if not isValid(currentFormat)
        ok = false
        sabr_log(m.logs, log_level_Type.WARN, `${requestLogTag} No matching format for itag: ${keyParam}`, false)
    end if

    activeFormats = sabr_getActiveFormats(currentFormat, sabr, playbackContext)

    ' Normalize requested byte range for downstream lookups
    requestByteRange = sabr_getHeaderByteRange(request)
    requestByteRange = sabr_normalizeByteRange(requestByteRange, {
        "mediaIdHash": mediaIdHash
        "contentType": contentType
        "format": currentFormat
    })
    ' Log normalized range for diagnostics
    sabr_log(m.logs, log_level_Type.DEBUG, `${requestLogTag} Normalized byteRange start=${requestByteRange?.startRange ?? ""} end=${requestByteRange?.endRange ?? ""} seq=${requestByteRange?.sequenceNumber ?? ""}`)
    streamInfoForFormat = sabr_fetchStreamInfoForFormat(playbackContext, contentType, currentFormat)
    isInitSegmentRequest = sabr_isInit(contentType, currentFormat, requestByteRange, nextRequestId)

    formatKeyForLog = sabr_formatToKey(currentFormat)
    sabr_log(m.logs, log_level_Type.DEBUG, `${requestLogTag} Resolving segment start; init=${isInitSegmentRequest} formatKey=${formatKeyForLog}`)

    cachedSpoolSegment = invalid
    ' spoolKey = `${requestByteRange?.startRange}:${keyParam}`
    cachedSegment = sabr_findSpoolSegmentInCache(playbackContext, requestByteRange, keyParam)
    if IsAssociativeArray(cachedSegment)
        spooledSegment = cachedSegment.spooledSegment
        spoolKey = cachedSegment.spoolKey
        coverageStartVal = sabr_toInt(spooledSegment?.startRange)
        coverageEndVal = sabr_toInt(spooledSegment?.endRange)
        sabr_log(m.logs, log_level_Type.DEBUG, `${requestLogTag} Spool map hit key=${spoolKey} isInitSeg=${spooledSegment.isInitSeg} requestRange=${requestByteRange?.startRange}-${requestByteRange?.endRange} coverage=${coverageStartVal}-${coverageEndVal}`)
        if coverageEndVal <> sabr_toInt(requestByteRange?.endRange) and not spooledSegment.isInitSeg
            sabr_log(m.logs, log_level_Type.WARN, `${requestLogTag} Spool map miss key=${spoolKey} requestRange=${requestByteRange?.startRange}-${requestByteRange?.endRange}`)
        else
            ' immediately stream this identified spooled segment to the player through the socket
            chunks = spooledSegment?.chunks
            totalBytes = sabr_toInt(spooledSegment?.totalBytes)
            if totalBytes = invalid
                totalBytes = 0
                if IsArray(chunks)
                    for each chunk in chunks
                        chunkLen = sabr_toInt(chunk?.length)
                        if chunkLen <> invalid then totalBytes = totalBytes + chunkLen
                    end for
                end if
            end if
            if spooledSegment?.isInitSeg = true
                trimmed = sabr_trimSegmentChunksForRange(chunks, spooledSegment?.startRange, requestByteRange)
                if IsAssociativeArray(trimmed)
                    trimmedChunks = trimmed?.chunks
                    trimmedBytes = sabr_toInt(trimmed?.totalBytes)
                    if IsArray(trimmedChunks) and trimmedChunks.count() > 0 and trimmedBytes <> invalid and trimmedBytes > 0
                        chunks = trimmedChunks
                        totalBytes = trimmedBytes
                    end if
                end if
            end if
            coverageInfo = CreateObject("roAssociativeArray")
            if coverageStartVal <> invalid then coverageInfo["rangeStart"] = coverageStartVal
            if coverageEndVal <> invalid then coverageInfo["rangeEnd"] = coverageEndVal

            spoolResponse = {
                "path": spooledSegment.path
                "chunks": chunks
                "totalBytes": totalBytes
            }
            if spooledSegment?.isInitSeg = true
                spoolResponse["isInitSeg"] = true
            end if
            if coverageInfo.Count() > 0
                spoolResponse["coverage"] = coverageInfo
            end if

            cacheRequestMetadata = {
                "format": currentFormat
                "byteRange": requestByteRange
            }
            responseForPlayer = sabr_buildResponseForPlayer(cacheRequestMetadata, spoolResponse, currentFormat, requestByteRange, contentType)
            sabr_log(m.logs, log_level_Type.INFO, `${requestLogTag} Serving spooled segment to player key=${spoolKey} requestByteRange=${formatJson(requestByteRange)} isInitSeg=${spooledSegment.isInitSeg}`)
            sabr_log(m.logs, log_level_Type.INFO, `${requestLogTag} Serving spooled segment to player key=${spoolKey} chunkCount=${IsArray(chunks) ? chunks.count() : 0} totalBytes=${totalBytes}`)
            return responseForPlayer
        end if
    else
        sabr_log(m.logs, log_level_Type.DEBUG, `${requestLogTag} No cached spool map for lookup keys key=${sabr_valueToLabel(keyParam)} requestRange=${requestByteRange?.startRange}-${requestByteRange?.endRange}`)
    end if

    bufferState = sabr_buildBufferedState(mediaIdHash, currentFormat, activeFormats, playbackContext, contentType, requestByteRange)

    playerTimeInfo = sabr_resolvePlayerTimeMsForRequest(playbackContext, contentType, currentFormat, requestByteRange, videoNode)
    previousResolvedPlayerTime = sabr_toInt(playbackContext?.lastResolvedPlayerTimeMs)
    previousRequestedPlayerTime = sabr_toInt(playbackContext?.lastRequestedPlayerTimeMs)
    previousMaxResolvedPlayerTime = sabr_toInt(playbackContext?.maxResolvedPlayerTimeMs)
    storedPruneThresholdMs = sabr_toInt(playbackContext?.bufferPruneThresholdMs)
    toleranceMs = 1000

    ' Resolve player-time prediction and update context
    playerTimeOverride = sabr_toInt(playerTimeInfo?.value)
    if playerTimeOverride = invalid or playerTimeOverride < 0
        playerTimeOverride = 0
    end if
    playerTimeSourceLabel = `${playerTimeInfo?.source ?? "unknown"}`
    segmentStartMs = sabr_toInt(playerTimeInfo?.segmentStartMs)
    segmentDurationMs = sabr_toInt(playerTimeInfo?.segmentDurationMs)
    if segmentStartMs <> invalid
        if playerTimeOverride < segmentStartMs
            playerTimeOverride = segmentStartMs
        end if
        fudgeMs = 1
        if segmentDurationMs <> invalid and segmentDurationMs > 0
            fudgeMs = Int(segmentDurationMs / 100)
            if fudgeMs < 1 then fudgeMs = 1
            if fudgeMs > 50 then fudgeMs = 50
        end if
        candidateOverride = playerTimeOverride
        if candidateOverride <= segmentStartMs
            candidateOverride = segmentStartMs + fudgeMs
            if segmentDurationMs <> invalid and segmentDurationMs > 0
                maxAllowed = segmentStartMs + segmentDurationMs
                if candidateOverride > maxAllowed then candidateOverride = maxAllowed
            end if
        end if
        if candidateOverride > playerTimeOverride
            sabr_log(m.logs, log_level_Type.DEBUG, `${requestLogTag} PlayerTime cheat bump start=${segmentStartMs} duration=${segmentDurationMs} bump=${candidateOverride - playerTimeOverride}`)
            playerTimeOverride = candidateOverride
        end if
    end if
    defaultBumpMs = SABR_PLAYER_TIME_DEFAULT_BUMP_MS
    if segmentDurationMs <> invalid and segmentDurationMs > 0
        computedBump = Int(segmentDurationMs / 2)
        if computedBump <= 0 then computedBump = SABR_PLAYER_TIME_DEFAULT_BUMP_MS
        defaultBumpMs = computedBump
    end if
    if defaultBumpMs > 0
        targetOverride = playerTimeOverride + defaultBumpMs
        if segmentStartMs <> invalid and segmentDurationMs <> invalid and segmentDurationMs > 0
            maxAllowedOverride = segmentStartMs + segmentDurationMs
            if targetOverride > maxAllowedOverride then targetOverride = maxAllowedOverride
        end if
        if targetOverride > playerTimeOverride
            sabr_log(m.logs, log_level_Type.DEBUG, `${requestLogTag} PlayerTime default bump applied value=${playerTimeOverride} -> ${targetOverride}`)
            playerTimeOverride = targetOverride
        end if
    end if
    playbackContext["lastResolvedPlayerTimeMs"] = playerTimeOverride
    playbackContext["lastResolvedPlayerTimeSource"] = playerTimeSourceLabel

    sabr_log(m.logs, log_level_Type.DEBUG, `${requestLogTag} Resolved playerTimeMs=${playerTimeOverride} source=${playerTimeSourceLabel}`)
    rangeLabelForLog = sabr_formatRequestedRangeForPath(requestByteRange)
    sabr_log(m.logs, log_level_Type.DEBUG, `${requestLogTag} Using playerTimeMs=${playerTimeOverride} for range ${rangeLabelForLog}`)

    seekBackDetected = false
    if playerTimeOverride <> invalid
        if previousResolvedPlayerTime <> invalid and playerTimeOverride + toleranceMs < previousResolvedPlayerTime
            seekBackDetected = true
        else if previousRequestedPlayerTime <> invalid and playerTimeOverride + toleranceMs < previousRequestedPlayerTime
            seekBackDetected = true
        else if previousMaxResolvedPlayerTime <> invalid and playerTimeOverride + toleranceMs < previousMaxResolvedPlayerTime
            seekBackDetected = true
        end if
    end if

    newMaxResolvedPlayerTime = previousMaxResolvedPlayerTime
    if playerTimeOverride <> invalid
        if newMaxResolvedPlayerTime = invalid or playerTimeOverride > newMaxResolvedPlayerTime or seekBackDetected
            newMaxResolvedPlayerTime = playerTimeOverride
        end if
        playbackContext["maxResolvedPlayerTimeMs"] = newMaxResolvedPlayerTime
    end if

    ' Work out requested segment indices/timing for logging
    targetSegmentIndex = invalid
    segmentIndexInfo = requestByteRange?.segmentIndexInfo
    if IsAssociativeArray(segmentIndexInfo)
        targetSegmentIndex = sabr_toInt(segmentIndexInfo?.segmentIndex)
        if targetSegmentIndex = invalid
            targetSegmentIndex = sabr_toInt(segmentIndexInfo?.sequenceNumber)
        end if
        if targetSegmentIndex = invalid
            targetSegmentIndex = sabr_toInt(segmentIndexInfo?.startSegmentIndex)
        end if
    end if
    if targetSegmentIndex = invalid
        targetSegmentIndex = sabr_toInt(requestByteRange?.sequenceNumber)
    end if

    ' Track buffer prune thresholds to help repeat guard
    pruneCutoffMs = storedPruneThresholdMs
    if playerTimeOverride <> invalid
        if pruneCutoffMs = invalid or playerTimeOverride < pruneCutoffMs
            pruneCutoffMs = playerTimeOverride
        end if
    end if

    if seekBackDetected and playerTimeOverride <> invalid
        pruneCutoffMs = playerTimeOverride
        playbackContext["bufferPruneThresholdMs"] = playerTimeOverride
    else if storedPruneThresholdMs <> invalid and playerTimeOverride <> invalid and playerTimeOverride > storedPruneThresholdMs + toleranceMs
        playbackContext.Delete("bufferPruneThresholdMs")
        pruneCutoffMs = playerTimeOverride
    end if

    pruneRangeStart = sabr_toInt(requestByteRange?.startRange)
    if pruneRangeStart = invalid then pruneRangeStart = sabr_toInt(requestByteRange?.start)

    if pruneCutoffMs <> invalid or targetSegmentIndex <> invalid
        sabr_pruneBufferedRangesForSeekBack(bufferState, contentType, targetSegmentIndex, pruneCutoffMs, requestLogTag)
    else if seekBackDetected and isValid(m?.logs)
        sabr_log(m.logs, log_level_Type.DEBUG, `${requestLogTag} Seek-back detected but no pruning constraints available`)
    end if

    sabr_bufferingAugmentState(bufferState, {
        "contentType": contentType
        "currentFormat": currentFormat
        "playbackContext": playbackContext
        "requestByteRange": requestByteRange
        "seekBackDetected": seekBackDetected
        "requestLogTag": requestLogTag
    })

    sabrRequestJson = sabr_createVideoPlaybackAbrRequest(request, contentType, sabr, currentFormat, activeFormats, playbackContext, playerTimeOverride, videoNode, nextRequestId)

    if isValid(currentFormat.height)
        sabrRequestJson.clientAbrState["stickyResolution"] = currentFormat.height
        sabrRequestJson.clientAbrState["lastManualSelectedResolution"] = currentFormat.height
    end if

    formatToDiscard = sabr_applyBufferedStateToRequest(sabrRequestJson, bufferState)

    if isValid(formatToDiscard)
        ' the formatToDiscard is the one that we are faking out the youtube server to "not" send us any data.
        ' in this way, if this is a video request, we can get the video segment data but not the audio and vice versa
        ' Sabr wants to send us both audio and video segments in the same response, but we only want one or the other
        sabrRequestJson.selectedFormatIds.push(formatToDiscard)
    end if

    sabr_logBufferedRanges(requestLogTag, sabrRequestJson)

    requestMetadataEntry = {
        "requestNumber": nextRequestId
        "isInit": isInitSegmentRequest
        "byteRange": {
            "start": requestByteRange.startRange
            "end": requestByteRange.endRange
            "startRange": requestByteRange.startRange
            "endRange": requestByteRange.endRange
            "sequenceNumber": requestByteRange.DoesExist("sequenceNumber") ? requestByteRange.sequenceNumber : invalid
            "segmentIndexInfo": requestByteRange.DoesExist("segmentIndexInfo") ? requestByteRange.segmentIndexInfo : invalid
        }
        "format": currentFormat
        "contentType": contentType
        "mediaIdHash": mediaIdHash
        "streamInfo": streamInfoForFormat
        "timestamp": sabr_currentTimestampMs()
        "debugUploadUrl": debugUploadUrl
        "sabrKey": keyParam
        "requestPath": request.path
    }
    if queuedAtValue <> invalid
        requestMetadataEntry["queuedAtMs"] = queuedAtValue
    end if
    requestMetadataEntry["requestStartMs"] = requestStartMs
    if requestByteRange.DoesExist("segmentIndexInfo")
        requestMetadataEntry["segmentIndexInfo"] = requestByteRange.segmentIndexInfo
    end if
    if requestByteRange.DoesExist("sequenceNumber")
        requestMetadataEntry["sequenceNumber"] = sabr_toInt(requestByteRange.sequenceNumber)
    end if
    if isValid(metadataManager)
        metadataManager.store(metadataManager, `${nextRequestId}`, requestMetadataEntry)
    end if

    sabr_debugLogRepeatState(contentType, nextRequestId, playbackContext, "pre_guard", `range=${rangeLabelForLog}`)

    repeatGuardResponse = sabr_guardRepeatedRequests(playbackContext, contentType, currentFormat, requestMetadataEntry, `${nextRequestId}`, videoNode, mediaIdHash)
    if isValid(repeatGuardResponse)
        return repeatGuardResponse
    end if

    batchCounter = m.top.utilsTask.callFunc("getNextId", "sabrBatchCounter")
    playbackContext["lastDumpIndex"] = batchCounter
    requestMetadataEntry["batchIndex"] = batchCounter

    ' Build and send SABR request when cache misses
    ' Build and send SABR request when cache misses
    if ok
        if not isInitSegmentRequest and isValid(currentFormat)
            sabrRequestJson.selectedFormatIds.push(currentFormat)
        end if

        if isValid(m?.logs)
            selectedSummary = ""
            if IsArray(sabrRequestJson?.selectedFormatIds) and sabrRequestJson.selectedFormatIds.count() > 0
                try
                    selectedSummary = FormatJson(sabrRequestJson.selectedFormatIds)
                catch e
                    selectedSummary = "<FormatJson error>"
                end try
            end if
            if selectedSummary <> ""
                sabr_log(m.logs, log_level_Type.DEBUG, `${requestLogTag} selectedFormatIdsJson=${selectedSummary}`)
            end if
        end if

        ' clone the object as the encode will add snake case object keys alongside camel case ones
        playbackContext["lastSabrRequest"] = sabrRequestJson
        ' Optionally upload debug artifacts for the response
        if debugUploadUrl <> ""
            requestPayloadJson = FormatJson(sabrRequestJson)
            if isValid(requestPayloadJson) and requestPayloadJson <> ""
                rangeLabel = sabr_formatRequestedRangeForPath(requestMetadataEntry.byteRange)
                dumpCounter = invalid
                if isValid(m.top?.utilsTask)
                    dumpCounter = m.top.utilsTask.callFunc("getNextId", "sabrDumpCounterBatch")
                end if
                dumpLabel = sabr_debugBuildDumpLabel(playbackContext, "sabr-request", `${nextRequestId}`, rangeLabel, contentType, currentFormat, dumpCounter)
                debugFolder = LCase(contentType) = "audio" ? "audio" : "video"
                spoolMaps = playbackContext?.umpSpoolMaps
                if IsAssociativeArray(spoolMaps) and spoolMaps.Count() > 0
                    spoolJson = ""
                    try
                        spoolJson = FormatJson(spoolMaps)
                    catch err
                        spoolJson = "<FormatJson error>"
                    end try
                    if spoolJson <> ""
                        sabr_debugUploadText(debugUploadUrl, `${debugFolder}/${dumpLabel}-spool.json`, spoolJson, m.logs)
                    end if
                end if
                sabr_debugUploadText(debugUploadUrl, `${debugFolder}/${dumpLabel}.json`, requestPayloadJson, m.logs)
            end if
        end if
        encodedProto = ""
        protoBytes = invalid
        protoFilePath = ""
        responseFilePath = ""
        encodeTimer = invalid
        if isValid(m?.logs)
            encodeTimer = m.logs.mark()
        end if
        try
            sabr_log(m.logs, log_level_Type.INFO, `${requestLogTag} Encoding SABR proto for itag: ${currentFormat.itag}`)
            ' sabr_log(m.logs, log_level_Type.VERBOSE, FormatJson(sabrRequestJson))
            encodedProto = VideoPlaybackAbrRequestEncode(sabrRequestJson)
            if IsString(encodedProto) and encodedProto <> ""
                protoBytes = CreateObject("roByteArray")
                protoBytes.FromBase64String(encodedProto)
                ' sanity check on the decode
                decodedProto = VideoPlaybackAbrRequestDecode(encodedProto)
                if not isValid(decodedProto)
                    ok = false
                    sabr_log(m.logs, log_level_Type.WARN, `${requestLogTag} Error decoding SABR proto after encode`, false)
                else
                    ' sabr_log(m.logs, log_level_Type.VERBOSE, `${requestLogTag} Decoded SABR proto: ${FormatJson(decodedProto)}`)
                    if debugUploadUrl <> ""
                        requestPayloadJson = FormatJson(decodedProto)
                        if isValid(requestPayloadJson) and requestPayloadJson <> ""
                            rangeLabelDecode = sabr_formatRequestedRangeForPath(requestMetadataEntry.byteRange)
                            dumpCounterDecode = invalid
                            if isValid(m.top?.utilsTask)
                                dumpCounterDecode = m.top.utilsTask.callFunc("getNextId", "sabrDumpCounterBatch")
                            end if
                            dumpLabel = sabr_debugBuildDumpLabel(playbackContext, "sabr-request-decode", `${nextRequestId}`, rangeLabelDecode, contentType, currentFormat, dumpCounterDecode)
                            debugFolder = LCase(contentType) = "audio" ? "audio" : "video"
                            sabr_debugUploadText(debugUploadUrl, `${debugFolder}/${dumpLabel}.json`, requestPayloadJson, m.logs)
                        end if
                    end if
                end if
            end if
        catch e
            ok = false
            sabr_log(m.logs, log_level_Type.WARN, `${requestLogTag} Error encoding SABR proto: ${e.message}`, false)
        end try
        if encodeTimer <> invalid
            m.logs.printTime(log_level_Type.INFO, `${requestLogTag} Proto encode duration`, encodeTimer, -1)
        end if

        ' prepare the SABR request now
        if ok and IsValid(protoBytes)
            sabr_log(m.logs, log_level_Type.INFO, `${requestLogTag} proto payload`)

            shouldSendSabr = false
            if contentType = "VIDEO"
                shouldSendSabr = true
            else if playbackContext.hasVideoParts = true
                shouldSendSabr = true
            end if

            hasVideoPartsFlag = false
            if playbackContext?.hasVideoParts = true then hasVideoPartsFlag = true
            sabr_log(m.logs, log_level_Type.DEBUG, `${requestLogTag} SABR send decision contentType=${contentType} type=${Type(contentType)} hasVideoParts=${hasVideoPartsFlag} shouldSend=${shouldSendSabr}`)

            if shouldSendSabr
                sabr_log(m.logs, log_level_Type.INFO, `${requestLogTag} Sending SABR request to URL: ${sabrAbrUrl}`)
                ' write the protoBytes to a file and send that file to the SABR URL
                protoFilePath = `tmp:/${mediaIdHash}/sabrRequest-${contentType}-${nextRequestId}.bin`
                protoBytes.writeFile(protoFilePath)
                sabrRequest = {
                    "url": sabrAbrUrl, ' "http://192.168.119.94:8000/sabr"
                    "requestType": "proxy",
                    "timeout": 10000,
                    "options": {
                        "method": "POST_FILE_TO_FILE_WITH_DECODINGS",
                        "body": protoFilePath
                    }
                }

                sabr_log(m.logs, log_level_Type.INFO, `[RELAY] Performing proxied request to: ${FormatJson(sabrAbrUrl)}`)
                requestSpan = invalid
                if isValid(m?.logs)
                    requestSpan = m.logs.mark()
                end if
                res = makeRequest(sabrRequest)
                if requestSpan <> invalid
                    m.logs.printTime(log_level_Type.INFO, `${requestLogTag} SABR proxy round-trip`, requestSpan, -1)
                end if
                if not isValid(res?.status)
                    ok = false
                    sabr_log(m.logs, log_level_Type.WARN, `${requestLogTag} No response status from SABR UMP request`, false)
                    response = sabr_buildErrorResponseForPlayer(500, "SABR request failed")
                else if res.status >= 200 and res?.status <= 206
                    responseFilePath = res.body
                    fatalReason = ""
                    segmentInfo = invalid
                    umpResult = invalid
                    segmentScanSummary = invalid
                    spoolResultForResponse = invalid
                    requestMetadata = {
                        "isUMP": true
                        "isSABR": true
                        "isInit": isInitSegmentRequest
                        "requestNumber": nextRequestId
                        "format": currentFormat
                        "streamInfo": {}
                        "debugUploadUrl": debugUploadUrl
                        "mediaIdHash": mediaIdHash
                        "contentType": contentType
                        "umpMode": "target"
                    }
                    if IsAssociativeArray(requestMetadataEntry.byteRange)
                        requestMetadata["byteRange"] = requestMetadataEntry.byteRange
                    end if

                    if isValid(responseFilePath) and responseFilePath <> ""
                        spoolMap = sabr_ump_buildSpoolPartMap(responseFilePath, 16, keyParam)
                        sabr_logSpoolSummary(m.logs, requestLogTag, spoolMap)
                        if IsAssociativeArray(spoolMap) and (spoolMap?.error ?? "") = ""
                            if not IsAssociativeArray(playbackContext["umpSpoolMaps"]) then playbackContext["umpSpoolMaps"] = {}
                            segmentIndex = spoolMap?.segmentIndex
                            if IsAssociativeArray(segmentIndex)
                                for each segmentKey in segmentIndex.Keys()
                                    entry = segmentIndex.Lookup(segmentKey)
                                    playbackContext["umpSpoolMaps"][segmentKey] = entry
                                    sidxUpdate = entry?.sidxIndex
                                    if IsAssociativeArray(sidxUpdate)
                                        sabr_storeSidxIndexUpdate(playbackContext, contentType, sidxUpdate)
                                    end if
                                end for
                            end if
                        end if

                        spoolFetch = sabr_findSpoolSegmentInCache(playbackContext, requestByteRange, keyParam)
                        if IsAssociativeArray(spoolFetch)
                            spoolSegment = spoolFetch.spooledSegment
                            spoolChunks = spoolSegment?.chunks
                            if IsArray(spoolChunks) and spoolChunks.count() > 0
                                totalBytesForResponse = sabr_toInt(spoolSegment?.totalBytes)
                                if spoolSegment?.isInitSeg = true
                                    trimmed = sabr_trimSegmentChunksForRange(spoolChunks, spoolSegment?.startRange, requestByteRange)
                                    if IsAssociativeArray(trimmed)
                                        trimmedChunks = trimmed?.chunks
                                        trimmedBytes = sabr_toInt(trimmed?.totalBytes)
                                        if IsArray(trimmedChunks) and trimmedChunks.count() > 0
                                            spoolChunks = trimmedChunks
                                            if trimmedBytes <> invalid then totalBytesForResponse = trimmedBytes
                                        end if
                                    end if
                                end if
                                if totalBytesForResponse = invalid or totalBytesForResponse <= 0
                                    totalBytesForResponse = 0
                                    for each chunkEntry in spoolChunks
                                        lenVal = sabr_toInt(chunkEntry?.length)
                                        if lenVal <> invalid then totalBytesForResponse = totalBytesForResponse + lenVal
                                    end for
                                end if
                                coverageStartVal = sabr_toInt(spoolSegment?.startRange)
                                coverageEndVal = sabr_toInt(spoolSegment?.endRange)
                                if spoolSegment?.isInitSeg = true
                                    trimmedCoverage = sabr_byteRangeToCoverage(requestByteRange)
                                    if IsAssociativeArray(trimmedCoverage)
                                        covStartTrim = sabr_toInt(trimmedCoverage?.rangeStart)
                                        covEndTrim = sabr_toInt(trimmedCoverage?.rangeEnd)
                                        if covStartTrim <> invalid then coverageStartVal = covStartTrim
                                        if covEndTrim <> invalid then coverageEndVal = covEndTrim
                                    end if
                                end if
                                if totalBytesForResponse > 0 and sabr_toSafeString(spoolSegment?.path) <> ""
                                    spoolResultForResponse = {
                                        "path": spoolSegment.path
                                        "chunks": spoolChunks
                                        "totalBytes": totalBytesForResponse
                                        "coverage": {
                                            "rangeStart": coverageStartVal
                                            "rangeEnd": coverageEndVal
                                        }
                                    }
                                    if spoolSegment?.isInitSeg = true
                                        spoolResultForResponse["isInitSeg"] = true
                                    end if
                                end if
                            end if
                        end if

                        controlEffects = sabr_ump_extractControlParts(spoolMap, responseFilePath)
                        streamInfoSeed = {}
                        if IsAssociativeArray(controlEffects)
                            if isValid(controlEffects.nextRequestPolicy)
                                streamInfoSeed["nextRequestPolicy"] = controlEffects.nextRequestPolicy
                                cookieProto = controlEffects.nextRequestPolicy?.playbackCookie
                                if isValid(cookieProto)
                                    requestMetadata["playbackCookie"] = PlaybackCookieEncode(cookieProto)
                                end if
                            end if
                            if isValid(controlEffects.sabrContextUpdate)
                                streamInfoSeed["sabrContextUpdate"] = controlEffects.sabrContextUpdate
                            end if
                            if isValid(controlEffects.sabrContextSendingPolicy)
                                streamInfoSeed["sabrContextSendingPolicy"] = controlEffects.sabrContextSendingPolicy
                            end if
                            if isValid(controlEffects.redirect)
                                streamInfoSeed["redirect"] = controlEffects.redirect
                            end if
                            if isValid(controlEffects.reloadPlaybackContext)
                                streamInfoSeed["reloadPlaybackContext"] = controlEffects.reloadPlaybackContext
                            end if
                            if isValid(controlEffects.sabrError)
                                requestMetadata["error"] = { "sabrError": controlEffects.sabrError }
                                fatalReason = "SABR error received"
                                sabr_log(m.logs, log_level_Type.WARN, `${requestLogTag} SABR error received: ${FormatJson(controlEffects.sabrError)}`, false)
                            end if
                        end if
                        requestMetadata["streamInfo"] = streamInfoSeed
                    else
                        fatalReason = "SABR UMP response path missing"
                        sabr_log(m.logs, log_level_Type.WARN, `${requestLogTag} ${fatalReason}`, false)
                    end if

                    if not isValid(umpResult) and IsAssociativeArray(spoolResultForResponse)
                        umpResult = spoolResultForResponse
                    end if

                    if fatalReason <> ""
                        playbackContext["sabrFatalError"] = {
                            "reason": fatalReason
                            "requestNumber": nextRequestId
                            "timestamp": sabr_currentTimestampMs()
                        }
                        sabr_log(m.logs, log_level_Type.WARN, `${requestLogTag} Fatal SABR error: ${fatalReason}`, false)
                        if response = invalid
                            response = sabr_buildErrorResponseForPlayer(502, fatalReason)
                        end if
                    else
                        if isValid(segmentInfo)
                            sabr_log(m.logs, log_level_Type.INFO, `${requestLogTag} Segment info available after processing: ${FormatJson(segmentInfo)}`)
                        end if

                        if IsArray(segmentScanSummary?.segments)
                            segmentCount = segmentScanSummary.segments.count()
                            matchedFlag = segmentScanSummary?.matched
                            if matchedFlag = invalid then matchedFlag = false
                            sabr_log(m.logs, log_level_Type.INFO, `${requestLogTag} SABR scan summary segments=${segmentCount} matched=${matchedFlag}`)
                            for each scanEntry in segmentScanSummary.segments
                                headerLabel = sabr_valueToLabel(scanEntry?.headerId)
                                seqLabel = sabr_valueToLabel(scanEntry?.sequenceNumber)
                                startLabel = sabr_valueToLabel(scanEntry?.start)
                                matchedLabel = scanEntry?.matched
                                if matchedLabel = invalid then matchedLabel = false
                                sabr_log(m.logs, log_level_Type.DEBUG, `${requestLogTag} SABR scan header=${headerLabel} seq=${seqLabel} start=${startLabel} matched=${matchedLabel}`)
                            end for
                        end if

                        playbackContext["lastSabrStreamInfo"] = requestMetadata.streamInfo
                        playbackCookieValue = requestMetadata.playbackCookie
                        if isValid(playbackCookieValue) and playbackCookieValue <> ""
                            playbackContext["lastPlaybackCookie"] = playbackCookieValue
                            if isValid(sabr)
                                sabr.playbackCookie = playbackCookieValue
                            end if
                        end if
                        redirectUrl = requestMetadata.streamInfo?.redirect?.url ?? ""
                        redirectTriggered = false
                        if redirectUrl <> ""
                            if isValid(sabr)
                                sabr.serverAbrStreamingUrl = redirectUrl
                            end if
                            playbackContext["serverAbrStreamingUrl"] = redirectUrl
                            sabr_log(m.logs, log_level_Type.INFO, `${requestLogTag} Updated SABR server URL via redirect: ${redirectUrl}`)
                            if not isValid(umpResult?.data) or umpResult.data.count() = 0
                                redirectTriggered = true
                            end if
                        end if
                        requestMetadataEntry["streamInfo"] = requestMetadata.streamInfo

                        if redirectTriggered
                            if redirectDepth >= 3
                                fatalReason = "SABR redirect limit reached"
                                sabr_log(m.logs, log_level_Type.WARN, `${requestLogTag} ${fatalReason}`, false)
                            else
                                sabr_log(m.logs, log_level_Type.INFO, `${requestLogTag} Following SABR redirect to ${redirectUrl}`)
                                ' Cleanup temp files for proto/response
                                ' sabr_deleteFileIfExists(responseFilePath)
                                sabr_deleteFileIfExists(protoFilePath)
                                writeFile(`tmp:/${mediaIdHash}/playbackContext.json`, FormatJson(playbackContext))
                                return sabr_handleRequest(request, contentType, mediaIdHash, sabr, videoNode, queuedAtValue, redirectDepth + 1)
                            end if
                        end if

                        if not isValid(umpResult)
                            pendingSummary = []
                            processedParts = []
                            streamInfoKeys = []
                            if IsAssociativeArray(requestMetadata?.streamInfo)
                                for each infoKey in requestMetadata.streamInfo
                                    streamInfoKeys.push(infoKey)
                                end for
                            end if

                            logDetails = {
                                "requestNumber": nextRequestId
                                "requestedRange": sabr_formatRequestedRangeForPath(requestMetadataEntry?.byteRange)
                                "pendingSegments": pendingSummary
                                "processedParts": processedParts
                                "streamInfoKeys": streamInfoKeys
                            }
                            if not isValid(umpResult)
                                logDetails["result"] = "missing"
                            end if
                            sabr_log(m.logs, log_level_Type.WARN, `${requestLogTag} No segment data returned from UMP response: ${FormatJson(logDetails)}`, false)
                        else
                            requestMetadataEntry["streamInfo"] = requestMetadata.streamInfo

                            coverageInfo = umpResult?.coverage
                            deliveredSegment = false
                            if isValid(umpResult?.data) and GetInterface(umpResult.data, "ifByteArray") <> invalid
                                segmentBytes = umpResult.data
                                deliveredSegment = segmentBytes.count() > 0
                                if deliveredSegment
                                    coverageRange = sabr_byteRangeToCoverage(requestMetadataEntry.byteRange)
                                    if not isValid(coverageRange) and isValid(coverageInfo)
                                        coverageRange = coverageInfo
                                    end if
                                    rangeLabel = sabr_formatRequestedRangeForPath(requestMetadataEntry.byteRange)
                                    deliveredLabel = coverageRange
                                    if not isValid(deliveredLabel) and isValid(coverageInfo)
                                        deliveredLabel = coverageInfo
                                    end if
                                    if IsAssociativeArray(deliveredLabel)
                                        deliveredLabel = `${deliveredLabel?.rangeStart ?? ""}-${deliveredLabel?.rangeEnd ?? ""}`
                                    end if
                                    deliveredInfo = {
                                        "coverageLabel": deliveredLabel
                                        "rangeLabel": rangeLabel
                                        "bytes": segmentBytes.count()
                                    }
                                    sabr_log(m.logs, log_level_Type.INFO, `${requestLogTag} SABR delivered segment ${FormatJson(deliveredInfo)}`)
                                    requestMetadataEntry["coverage"] = coverageRange
                                    requestMetadataEntry["segmentIndexKey"] = sabr_formatToKey(currentFormat)
                                    if IsAssociativeArray(requestMetadata?.streamInfo) and isValid(coverageRange)
                                        requestMetadata.streamInfo["deliveredCoverage"] = coverageRange
                                    end if
                                    playerTimeForStore = sabr_toInt(playerTimeOverride)
                                    if playerTimeForStore <> invalid and playerTimeForStore >= 0
                                        requestMetadataEntry["playerTimeMs"] = playerTimeForStore
                                    end if
                                end if
                            else if IsArray(umpResult?.chunks)
                                chunkList = umpResult.chunks
                                chunkTotalBytes = sabr_toInt(umpResult?.totalBytes)
                                if chunkTotalBytes = invalid or chunkTotalBytes <= 0
                                    chunkTotalBytes = 0
                                    for each chunkEntry in chunkList
                                        chunkLenVal = sabr_toInt(chunkEntry?.length)
                                        if chunkLenVal <> invalid then chunkTotalBytes = chunkTotalBytes + chunkLenVal
                                    end for
                                end if
                                if chunkTotalBytes > 0
                                    deliveredSegment = true
                                    coverageRange = sabr_byteRangeToCoverage(requestMetadataEntry.byteRange)
                                    if not isValid(coverageRange) and isValid(coverageInfo)
                                        coverageRange = coverageInfo
                                    end if
                                    rangeLabel = sabr_formatRequestedRangeForPath(requestMetadataEntry.byteRange)
                                    deliveredLabel = coverageRange
                                    if not isValid(deliveredLabel) and isValid(coverageInfo)
                                        deliveredLabel = coverageInfo
                                    end if
                                    if IsAssociativeArray(deliveredLabel)
                                        deliveredLabel = `${deliveredLabel?.rangeStart ?? ""}-${deliveredLabel?.rangeEnd ?? ""}`
                                    end if
                                    deliveredInfo = {
                                        "coverageLabel": deliveredLabel
                                        "rangeLabel": rangeLabel
                                        "bytes": chunkTotalBytes
                                        "chunks": chunkList.count()
                                    }
                                    sabr_log(m.logs, log_level_Type.INFO, `${requestLogTag} SABR delivered segment (chunks) ${FormatJson(deliveredInfo)}`)
                                    requestMetadataEntry["coverage"] = coverageRange
                                    requestMetadataEntry["segmentIndexKey"] = sabr_formatToKey(currentFormat)
                                    if IsAssociativeArray(requestMetadata?.streamInfo) and isValid(coverageRange)
                                        requestMetadata.streamInfo["deliveredCoverage"] = coverageRange
                                    end if
                                    playerTimeForStore = sabr_toInt(requestMetadataEntry?.playerTimeMs)
                                    if playerTimeForStore = invalid or playerTimeForStore < 0
                                        playerTimeForStore = sabr_toInt(playbackContext?.lastResolvedPlayerTimeMs)
                                    end if
                                    if playerTimeForStore = invalid or playerTimeForStore < 0
                                        playerTimeForStore = sabr_toInt(playbackContext?.lastRequestedPlayerTimeMs)
                                    end if
                                    if playerTimeForStore <> invalid and playerTimeForStore >= 0
                                        requestMetadataEntry["playerTimeMs"] = playerTimeForStore
                                    end if
                                end if
                            end if

                            if isValid(metadataManager)
                                metadataManager.store(metadataManager, `${nextRequestId}`, requestMetadataEntry)
                            end if

                            prefetchInfo = sabr_buildPrefetchInfo(requestMetadataEntry.streamInfo, currentFormat, requestMetadataEntry)
                            sabr_maybeSchedulePrefetch(playbackContext, videoNode, prefetchInfo, contentType)

                            sabr_applyStreamInfoUpdates(playbackContext, requestMetadata.streamInfo, contentType, deliveredSegment, requestMetadataEntry)
                            if deliveredSegment = true
                                sabr_storeStreamInfoForFormat(playbackContext, contentType, currentFormat, requestMetadata.streamInfo)
                            end if
                            if isValid(requestMetadata.streamInfo) and IsAssociativeArray(requestMetadata.streamInfo)
                                if requestMetadata.streamInfo.DoesExist("deliveredCoverage")
                                    requestMetadata.streamInfo.Delete("deliveredCoverage")
                                end if
                            end if

                            if response = invalid and isValid(umpResult)
                                response = sabr_buildResponseForPlayer(requestMetadataEntry, umpResult, currentFormat, requestByteRange, contentType)
                            end if
                        end if
                    end if
                else
                    sabr_log(m.logs, log_level_Type.WARN, `${requestLogTag} SABR UMP request failed with status: ${res?.status}`, false)
                    response = sabr_buildErrorResponseForPlayer(sabr_toInt(`${res?.status ?? 0}`), `SABR request failed`)
                end if
            else
                sabr_log(m.logs, log_level_Type.INFO, `${requestLogTag} ignoring audio SABR request for now`)
            end if
        else
            sabr_log(m.logs, log_level_Type.WARN, `${requestLogTag} No valid SABR proto bytes to send`, false)
        end if

    end if

    if IsAssociativeArray(timingInfo)
        timingInfo["responseBuildMs"] = sabr_currentTimestampMs()
    end if

    if IsAssociativeArray(response) and IsAssociativeArray(timingInfo)
        response["timing"] = timingInfo
    end if

    if debugUploadUrl <> "" and isValid(response)
        bodyByteArray = invalid
        bodyPathForDump = sabr_toSafeString(response?.bodyPath)
        bytesCount = 0

        if GetInterface(response.body, "ifByteArray") <> invalid and response.body.count() > 0
            bodyByteArray = response.body
            bytesCount = response.body.count()
        else if bodyPathForDump <> ""
            fs = CreateObject("roFileSystem")
            if fs.Exists(bodyPathForDump)
                fileStats = fs.Stat(bodyPathForDump)
                if isValid(fileStats) and fileStats.DoesExist("size")
                    bytesCount = sabr_toInt(fileStats.size)
                end if
            end if
        else if isValid(response?.bodyLength)
            bytesCount = sabr_toInt(response.bodyLength)
        end if

        rangeLabelResponse = sabr_formatRequestedRangeForPath(requestByteRange)
        dumpCounterResponse = invalid
        if isValid(m.top?.utilsTask)
            dumpCounterResponse = m.top.utilsTask.callFunc("getNextId", "sabrDumpCounterBatch")
        end if
        dumpBase = sabr_debugBuildDumpLabel(playbackContext, "response", `${nextRequestId}`, rangeLabelResponse, contentType, currentFormat, dumpCounterResponse)
        debugFolder = LCase(contentType) = "audio" ? "audio" : "video"
        if isValid(bodyByteArray)
            sabr_log(m.logs, log_level_Type.INFO, `${requestLogTag} Response body size=${bytesCount} bytes for request ${nextRequestId}`)
            sabr_debugUploadBytes(debugUploadUrl, `${debugFolder}/${dumpBase}-bytes`, bodyByteArray, m.logs)
        else if bodyPathForDump <> ""
            sabr_log(m.logs, log_level_Type.INFO, `${requestLogTag} Response body size=${bytesCount} bytes for request ${nextRequestId} (streaming)`)
            sabr_debugUploadBytes(debugUploadUrl, `${debugFolder}/${dumpBase}-bytes`, bodyPathForDump, m.logs)
        else
            sabr_log(m.logs, log_level_Type.INFO, `${requestLogTag} Response body size=${bytesCount} bytes for request ${nextRequestId} (no body data)`)
        end if

        responseInfo = {
            "status": response.status
            "headers": response.headers
            "isInit": isInitSegmentRequest
            "requestNumber": nextRequestId
            "contentType": contentType
        }
        sabr_debugUploadText(debugUploadUrl, `${debugFolder}/${dumpBase}-meta.json`, FormatJson(responseInfo), m.logs)
    end if

    if isValid(sessionKey) and sessionKey <> ""
        m.sabrActiveSessions.Delete(sessionKey)
    end if

    ' Cleanup temp files for proto/response
    ' sabr_deleteFileIfExists(responseFilePath)
    sabr_deleteFileIfExists(protoFilePath)

    sabr_recordRepeatResult(playbackContext, requestMetadataEntry, response, contentType, `${nextRequestId}`)

    if not IsAssociativeArray(response)
        response = sabr_buildEmptyResponseForPlayer(contentType, currentFormat)
        if IsAssociativeArray(response) and IsAssociativeArray(timingInfo)
            response["timing"] = timingInfo
        end if
    end if

    if IsAssociativeArray(response.headers) and not response.headers.DoesExist("Content-Range")
        response.headers["X-Cache-Range"] = sabr_formatRequestedRangeForPath(requestByteRange)
    end if

    ' Persist playback context to tmp so next request sees fresh state to preserve state
    sabr_log(m.logs, log_level_Type.INFO, `${requestLogTag} Storing SABR playbackContext to file for mediaIdHash: ${mediaIdHash}`)
    if isValid(playbackContext?.sidxIndexByFormat)
        sabr_log(m.logs, log_level_Type.DEBUG, `${requestLogTag} SIDX map snapshot ${FormatJson(playbackContext.sidxIndexByFormat)}`)
    end if
    ' sabr_log(m.logs, log_level_Type.VERBOSE, FormatJson(playbackContext))
    contextStoreTimer = invalid
    if isValid(m?.logs)
        contextStoreTimer = m.logs.mark()
    end if
    writeFile(`tmp:/${mediaIdHash}/playbackContext.json`, FormatJson(playbackContext))
    if contextStoreTimer <> invalid
        m.logs.printTime(log_level_Type.INFO, `${requestLogTag} Playback context persisted`, contextStoreTimer, -1)
    end if

    if requestTimer <> invalid
        m.logs.printTime(log_level_Type.INFO, `${requestLogTag} Total request duration`, requestTimer, -1)
    end if

    if SABR_TRACE_ENABLED
        sabr_traceLogSummary(`req=${nextRequestId}`)
    end if

    return response

end function


function sabr_getHeaderByteRange(request as object) as object
    sabr_traceCall("sabr_getHeaderByteRange")
    range = "bytes=0-"
    if isValid(request.headers.Range)
        range = request.headers.Range
    else if isValid(request.headers.range)
        range = request.headers.range
    end if
    ' split the range into start and end
    parts = range.Split("=")[1].Split("-")
    if parts.count() = 2
        startRange = parts[0]
        endRange = parts[1]
    end if
    return { "startRange": startRange, "endRange": endRange }
end function

' Collects cached segment coverage for a given format so we can seed SABR
' buffering metadata. Returns an array of entries sorted newest-first.
function sabr_collectBufferedRangesForFormat(mediaIdHash as string, formatType as string, activeFormat as object, targetByteRange as object, playbackContext = invalid as dynamic) as object
    sabr_traceCall("sabr_collectBufferedRangesForFormat")
    ranges = []
    if not isValid(activeFormat) then return ranges
    if not isValid(mediaIdHash) or mediaIdHash = "" then return ranges

    spoolRange = sabr_spoolBufferedRangeForFormat(playbackContext, formatType, activeFormat)
    if isValid(spoolRange)
        if isValid(m?.logs)
            sabr_log(m.logs, log_level_Type.DEBUG, `[SabrBuffer] bufferedRange=${FormatJson(spoolRange)}`)
        end if
        ranges.push(spoolRange)
    end if
    return ranges
end function

function sabr_spoolBufferedRangeForFormat(playbackContext as object, formatType as string, activeFormat as object) as dynamic
    sabr_traceCall("sabr_spoolBufferedRangeForFormat")
    if not IsAssociativeArray(playbackContext) then return invalid
    spoolMaps = playbackContext?.umpSpoolMaps
    if not IsAssociativeArray(spoolMaps) then return invalid

    targetItag = sabr_toInt(activeFormat?.itag)
    trackIdLabel = sabr_toSafeString(activeFormat?.audioTrackId)
    normalizedType = UCase(formatType)

    bestEntry = invalid
    bestSeq = invalid
    bestStart = invalid

    for each key in spoolMaps
        entry = spoolMaps.Lookup(key)
        if not IsAssociativeArray(entry) then continue for
        if entry?.isInitSeg = true then continue for

        entryItag = sabr_toInt(entry?.itag)
        if entryItag = invalid and IsAssociativeArray(entry?.mediaHeader)
            entryItag = sabr_toInt(entry.mediaHeader?.itag)
            if entryItag = invalid and IsAssociativeArray(entry.mediaHeader?.formatId)
                entryItag = sabr_toInt(entry.mediaHeader.formatId?.itag)
            end if
        end if
        if targetItag <> invalid and entryItag <> targetItag then continue for

        entryTrack = ""
        if IsAssociativeArray(entry?.mediaHeader?.formatId)
            entryTrack = sabr_toSafeString(entry.mediaHeader.formatId?.audioTrackId)
        end if
        if trackIdLabel <> "" and entryTrack <> "" and LCase(entryTrack) <> LCase(trackIdLabel)
            continue for
        end if

        seqVal = sabr_toInt(entry?.mediaHeader?.sequenceNumber)
        if seqVal = invalid then seqVal = sabr_toInt(entry?.mediaHeader?.startSequenceNumber)
        if seqVal = invalid then seqVal = sabr_toInt(entry?.mediaHeader?.segmentIndex)
        if seqVal = invalid then seqVal = sabr_toInt(entry?.mediaHeader?.startSegmentIndex)

        startRangeVal = sabr_toInt(entry?.startRange)
        if startRangeVal = invalid and IsAssociativeArray(entry?.mediaHeader)
            startRangeVal = sabr_toInt(entry.mediaHeader?.startRange)
            if startRangeVal = invalid then startRangeVal = sabr_toInt(entry.mediaHeader?.start)
        end if

        if bestEntry = invalid
            bestEntry = entry
            bestSeq = seqVal
            bestStart = startRangeVal
        else
            shouldReplace = false
            if seqVal <> invalid
                if bestSeq = invalid or seqVal > bestSeq
                    shouldReplace = true
                else if seqVal = bestSeq and startRangeVal <> invalid and bestStart <> invalid and startRangeVal > bestStart
                    shouldReplace = true
                end if
            else if startRangeVal <> invalid and bestStart <> invalid and startRangeVal > bestStart
                shouldReplace = true
            end if
            if shouldReplace
                bestEntry = entry
                bestSeq = seqVal
                bestStart = startRangeVal
            end if
        end if
    end for

    if bestEntry = invalid then return invalid

    coverageStartVal = sabr_toInt(bestEntry?.startRange)
    if coverageStartVal = invalid and IsAssociativeArray(bestEntry?.mediaHeader)
        coverageStartVal = sabr_toInt(bestEntry.mediaHeader?.startRange)
        if coverageStartVal = invalid then coverageStartVal = sabr_toInt(bestEntry.mediaHeader?.start)
    end if
    coverageEndVal = sabr_toInt(bestEntry?.endRange)
    if coverageEndVal = invalid and IsAssociativeArray(bestEntry?.mediaHeader)
        contentLengthVal = sabr_toInt(bestEntry.mediaHeader?.contentLength)
        if coverageStartVal <> invalid and contentLengthVal <> invalid and contentLengthVal > 0
            coverageEndVal = coverageStartVal + contentLengthVal - 1
        end if
    end if

    coverage = {}
    if coverageStartVal <> invalid then coverage["rangeStart"] = coverageStartVal
    if coverageEndVal <> invalid then coverage["rangeEnd"] = coverageEndVal
    seqForCoverage = sabr_toInt(bestEntry?.mediaHeader?.sequenceNumber)
    if seqForCoverage = invalid then seqForCoverage = sabr_toInt(bestEntry?.mediaHeader?.startSequenceNumber)
    if seqForCoverage <> invalid then coverage["sequenceNumber"] = seqForCoverage
    if bestEntry?.headerId <> invalid then coverage["headerId"] = bestEntry.headerId

    metadata = sabr_mediaHeaderToSegmentMetadata(bestEntry?.mediaHeader, coverage)
    if not IsAssociativeArray(metadata) then return invalid

    if isValid(m?.logs)
        startLabel = sabr_valueToLabel(metadata?.rangeStart)
        endLabel = sabr_valueToLabel(metadata?.rangeEnd)
        seqLabel = sabr_valueToLabel(metadata?.sequenceNumber)
        itagLabel = sabr_valueToLabel(activeFormat?.itag)
        sabr_log(m.logs, log_level_Type.DEBUG, `[SabrBuffer] spoolRange itag=${itagLabel} start=${startLabel} end=${endLabel} seq=${seqLabel}`)
    end if

    return sabr_buildBufferedRangeFromMetadata(metadata)
end function

' Applies the active buffering mode to the state passed to SABR, optionally
' synthesizing additional coverage entries to steer future responses.
sub sabr_bufferingAugmentState(bufferState as object, params as object)
    sabr_traceCall("sabr_bufferingAugmentState")
    ' buffering augmentation disabled; baseline mode is a no-op
    return
end sub

function sabr_findSpoolSegmentInCache(playbackContext as object, requestByteRange as object, keyParam as string) as dynamic
    sabr_traceCall("sabr_findSpoolSegmentInCache")
    spoolMaps = playbackContext?.umpSpoolMaps
    if not IsAssociativeArray(spoolMaps) then return invalid
    startRange = sabr_toInt(requestByteRange?.startRange)
    endRange = sabr_toInt(requestByteRange?.endRange)
    spoolKey = `${startRange}:${keyParam}`
    spoolEntry = spoolMaps.Lookup(spoolKey)
    if IsAssociativeArray(spoolEntry) and IsArray(spoolEntry?.chunks)
        return { spooledSegment: spoolEntry, spoolKey: spoolKey }
    end if
    ' if we get a miss, it could be an init segment request;
    for each key in spoolMaps
        if Instr(key, `0:${keyParam}`) = 1
            entry = spoolMaps.Lookup(key)
            entryEnd = sabr_toInt(entry?.endRange)
            if IsAssociativeArray(entry) and IsArray(entry?.chunks) and entryEnd = endRange
                return { spooledSegment: entry, spoolKey: key }
            end if
        end if
    end for

    return invalid
end function

function sabr_trimSegmentChunksForRange(chunks as object, segmentStart as dynamic, requestRange as object) as dynamic
    sabr_traceCall("sabr_trimSegmentChunksForRange")
    if not IsArray(chunks) then return invalid
    segmentStartVal = sabr_toInt(segmentStart)
    if segmentStartVal = invalid then return invalid
    requestStartVal = sabr_toInt(requestRange?.startRange)
    requestEndVal = sabr_toInt(requestRange?.endRange)
    if requestStartVal = invalid or requestEndVal = invalid then return invalid
    if requestEndVal < requestStartVal then return invalid

    offsetToSkip = requestStartVal - segmentStartVal
    if offsetToSkip < 0 then offsetToSkip = 0
    bytesNeeded = (requestEndVal - requestStartVal) + 1
    if bytesNeeded <= 0 then return invalid

    trimmedChunks = []
    remaining = bytesNeeded
    skip = offsetToSkip

    for each chunk in chunks
        chunkOffset = sabr_toInt(chunk?.offset)
        chunkLength = sabr_toInt(chunk?.length)
        if chunkOffset = invalid or chunkLength = invalid or chunkLength <= 0 then continue for

        if skip >= chunkLength
            skip = skip - chunkLength
            continue for
        end if

        effectiveOffset = chunkOffset + skip
        effectiveLength = chunkLength - skip
        if effectiveLength > remaining then effectiveLength = remaining

        if effectiveLength > 0
            trimmedChunks.push({
                "offset": effectiveOffset
                "length": effectiveLength
            })
            remaining = remaining - effectiveLength
        end if

        skip = 0
        if remaining <= 0 then exit for
    end for

    trimmedTotal = bytesNeeded - remaining
    if trimmedTotal <= 0 then return invalid

    return {
        "chunks": trimmedChunks
        "totalBytes": trimmedTotal
    }
end function

' Attempts to inject synthetic coverage for the segment prior to the request.
function sabr_currentPlayerPositionMs(videoNode as object, playbackContext as object) as dynamic
    sabr_traceCall("sabr_currentPlayerPositionMs")
    positionSeconds = invalid
    if isValid(videoNode) and isValid(videoNode.position)
        positionSeconds = videoNode.position
    end if
    if positionSeconds = invalid and isValid(playbackContext?.lastPlayerTimeSecs)
        positionSeconds = playbackContext.lastPlayerTimeSecs
    end if
    if positionSeconds = invalid then return invalid
    return int((positionSeconds ?? 0) * 1000)
end function

' Builds the buffered state payload that we attach to SABR requests so the
' server knows what segments already exist locally for video/audio tracks.
function sabr_buildBufferedState(mediaIdHash as string, currentFormat as object, activeFormats as object, playbackContext as object, requestedFormatType as string, requestByteRange as object) as object
    sabr_traceCall("sabr_buildBufferedState")
    rangesByType = {}
    rangesByType["AUDIO"] = []
    rangesByType["VIDEO"] = []

    state = {
        "formatToDiscard": invalid
        "rangesByType": rangesByType
    }

    currentFormatKey = sabr_formatToKey(currentFormat)
    activeFormatKeys = ["audioFormat", "videoFormat"]

    for each fieldName in activeFormatKeys
        format = activeFormats[fieldName]
        if not isValid(format)
            if fieldName = "audioFormat" and isValid(activeFormats.audioFormat)
                format = activeFormats.audioFormat
            else if fieldName = "videoFormat" and isValid(activeFormats.videoFormat)
                format = activeFormats.videoFormat
            end if
        end if

        if not isValid(format) then continue for

        formatType = sabr_formatTypeFromFormat(format)
        if formatType = "" then formatType = "UNKNOWN"

        if not state.rangesByType.DoesExist(formatType)
            state.rangesByType[formatType] = []
        end if

        shouldDiscard = sabr_formatToKey(format) <> currentFormatKey
        bufferedRanges = []
        targetByteRange = invalid
        if shouldDiscard = false and UCase(formatType) = UCase(requestedFormatType)
            targetByteRange = requestByteRange
        end if
        if shouldDiscard
            bufferedRanges = [sabr_createFullBufferRange(format)]
            if not isValid(state["formatToDiscard"])
                state["formatToDiscard"] = format
            end if
        else
            bufferedRanges = sabr_collectBufferedRangesForFormat(mediaIdHash, formatType, format, targetByteRange, playbackContext)
        end if

        if IsArray(bufferedRanges)
            for each bufferedRange in bufferedRanges
                if isValid(bufferedRange)
                    state.rangesByType[formatType].push(bufferedRange)
                end if
            end for
        else if isValid(bufferedRanges)
            state.rangesByType[formatType].push(bufferedRanges)
        end if
    end for

    return state
end function

' Writes buffer state information onto the outgoing SABR protobuf request.
' Returns the modified request to support call chaining.
function sabr_applyBufferedStateToRequest(videoPlaybackAbrRequest as object, bufferState as object) as dynamic
    sabr_traceCall("sabr_applyBufferedStateToRequest")
    if not IsAssociativeArray(bufferState) then return invalid

    rangeMap = bufferState?.rangesByType
    if IsAssociativeArray(rangeMap)
        for each rangeType in rangeMap
            ranges = rangeMap[rangeType]
            if IsArray(ranges)
                for each bufferedRange in ranges
                    if isValid(bufferedRange)
                        videoPlaybackAbrRequest.bufferedRanges.push(bufferedRange)
                    end if
                end for
            end if
        end for
    end if

    return bufferState?.formatToDiscard
end function


sub sabr_pruneBufferedRangesForSeekBack(bufferState as object, formatType as string, maxSegmentIndex as dynamic, maxStartTimeMs as dynamic, logTag as string)
    sabr_traceCall("sabr_pruneBufferedRangesForSeekBack")
    if not IsAssociativeArray(bufferState) then return
    if formatType = "" then return
    rangesMap = bufferState?.rangesByType
    if not IsAssociativeArray(rangesMap) then return

    normalizedType = UCase(formatType)
    if not rangesMap.DoesExist(normalizedType) then return

    targetIndex = sabr_toInt(maxSegmentIndex)

    originalRanges = rangesMap[normalizedType]
    if not IsArray(originalRanges) then return

    keptRanges = []
    removedCount = 0
    targetStartTimeMs = sabr_toInt(maxStartTimeMs)
    for each bufferedRange in originalRanges
        if not isValid(bufferedRange)
            continue for
        end if

        segmentIndex = sabr_toInt(bufferedRange?.startSegmentIndex)
        if segmentIndex = invalid
            segmentIndex = sabr_toInt(bufferedRange?.sequenceNumber)
        end if
        if segmentIndex = invalid
            segmentIndex = sabr_toInt(bufferedRange?.segmentIndex)
        end if

        shouldRemove = false
        if segmentIndex <> invalid and targetIndex <> invalid and segmentIndex > targetIndex
            shouldRemove = true
        else if targetStartTimeMs <> invalid
            startMs = sabr_toInt(bufferedRange?.startTimeMs)
            if startMs = invalid
                timeRange = bufferedRange?.timeRange
                startTicks = sabr_toInt(timeRange?.startTicks)
                timeScale = sabr_toInt(timeRange?.timescale)
                if startTicks <> invalid and timeScale <> invalid and timeScale > 0
                    startMs = int(startTicks * 1000 / timeScale)
                end if
            end if
            if startMs <> invalid and startMs > targetStartTimeMs
                shouldRemove = true
            end if
        end if

        if shouldRemove
            removedCount = removedCount + 1
        else
            keptRanges.push(bufferedRange)
        end if
    end for

    rangesMap[normalizedType] = keptRanges

    if removedCount > 0 and isValid(m?.logs)
        logPieces = [`${logTag} Seek-back detected; pruned ${removedCount} buffered range(s)`]
        if targetIndex <> invalid
            logPieces.push(`segment>${targetIndex}`)
        end if
        if targetStartTimeMs <> invalid
            logPieces.push(`startTime>${targetStartTimeMs}`)
        end if
        sabr_log(m.logs, log_level_Type.DEBUG, logPieces.Join(" "))
    end if
end sub


sub sabr_ensurePlayerTimeStrategy(playbackContext as object) as void
    sabr_traceCall("sabr_ensurePlayerTimeStrategy")
    if not IsAssociativeArray(playbackContext) then return
    current = playbackContext?.playerTimeStrategy
    if isValid(current) and current <> "" then return

    defaultStrategy = DEFAULT_PLAYER_TIME_STRATEGY
    override = invalid
    if isValid(m?.top?.playerTimeStrategy)
        override = `${m.top.playerTimeStrategy}`
    end if
    if isValid(override) and override <> ""
        defaultStrategy = LCase(override)
    end if
    playbackContext["playerTimeStrategy"] = defaultStrategy
end sub

function sabr_determinePlayerTimeStrategy(playbackContext as object) as string
    sabr_traceCall("sabr_determinePlayerTimeStrategy")
    if not IsAssociativeArray(playbackContext) then return DEFAULT_PLAYER_TIME_STRATEGY
    sabr_ensurePlayerTimeStrategy(playbackContext)
    strategy = playbackContext?.playerTimeStrategy
    if not isValid(strategy) or strategy = "" then return DEFAULT_PLAYER_TIME_STRATEGY
    normalized = LCase(`${strategy}`)
    if normalized = PLAYER_TIME_STRATEGY_SIDX or normalized = PLAYER_TIME_STRATEGY_METADATA or normalized = PLAYER_TIME_STRATEGY_HYBRID
        return normalized
    end if
    return DEFAULT_PLAYER_TIME_STRATEGY
end function

function sabr_globalSidxIndexMap() as object
    sabr_traceCall("sabr_globalSidxIndexMap")
    if not IsAssociativeArray(m?.sidxIndexCache)
        m.sidxIndexCache = {}
    end if
    return m.sidxIndexCache
end function

function sabr_requestedByteStart(byteRange as object) as dynamic
    sabr_traceCall("sabr_requestedByteStart")
    if not IsAssociativeArray(byteRange) then return invalid
    startVal = sabr_toInt(byteRange?.startRange)
    if startVal = invalid then startVal = sabr_toInt(byteRange?.start)
    if startVal = invalid
        label = ""
        if byteRange.DoesExist("startRange") then label = `${byteRange.startRange}`
        if label = "" and byteRange.DoesExist("start") then label = `${byteRange.start}`
        if label <> ""
            startVal = Val(label)
        end if
    end if
    if startVal = invalid and byteRange.DoesExist("segmentIndexInfo")
        info = byteRange.segmentIndexInfo
        if IsAssociativeArray(info)
            startVal = sabr_toInt(info?.rangeStart)
            if startVal = invalid and isValid(info?.rangeStart)
                startLabel = `${info.rangeStart}`
                if startLabel <> ""
                    startVal = Val(startLabel)
                end if
            end if
        end if
    end if
    return startVal
end function

' Resolves the playerTimeMs and coverage metadata SABR requires for the current
' byte-range request. Returns a small object describing the result and source.
function sabr_resolvePlayerTimeMsForRequest(playbackContext as object, contentType as string, currentFormat as object, requestByteRange as object, videoNode as object) as object
    sabr_traceCall("sabr_resolvePlayerTimeMsForRequest")
    sabr_ensurePlayerTimeStrategy(playbackContext)

    strategy = sabr_determinePlayerTimeStrategy(playbackContext)
    attempts = []
    if strategy = PLAYER_TIME_STRATEGY_SIDX
        attempts = [PLAYER_TIME_STRATEGY_SIDX]
    else if strategy = PLAYER_TIME_STRATEGY_METADATA
        attempts = [PLAYER_TIME_STRATEGY_METADATA]
    else
        attempts = [PLAYER_TIME_STRATEGY_SIDX, PLAYER_TIME_STRATEGY_METADATA]
    end if

    if isValid(m?.logs)
        entryStatus = "none"
        globalKeys = []
        globalMap = sabr_globalSidxIndexMap()
        if IsAssociativeArray(globalMap)
            for each keyName in globalMap
                globalKeys.push(keyName)
            end for
            entryStatus = `global:${globalKeys.count()}${FormatJson(globalKeys)}`
        end if
        contextKeys = []
        contextMap = playbackContext?.sidxIndexByFormat
        if IsAssociativeArray(contextMap)
            for each ctxKey in contextMap
                contextKeys.push(ctxKey)
            end for
            entryStatus = `${entryStatus}|context:${contextKeys.count()}${FormatJson(contextKeys)}`
        end if
        sabr_log(m.logs, log_level_Type.DEBUG, `[YTSABR-PlayerTime] Strategy ${strategy} sidxIndex=${entryStatus}`)
    end if

    for each attempt in attempts
        result = invalid
        if attempt = PLAYER_TIME_STRATEGY_SIDX
            result = sabr_lookupPlayerTimeMsFromSidx(playbackContext, contentType, currentFormat, requestByteRange)
        else if attempt = PLAYER_TIME_STRATEGY_METADATA
            result = sabr_lookupPlayerTimeMsFromMetadata(playbackContext, contentType, currentFormat, requestByteRange)
        end if

        candidate = sabr_toInt(result?.value)
        if candidate <> invalid and candidate >= 0
            label = result?.source
            if not isValid(label) or label = "" then label = attempt
            durationMs = sabr_toInt(result?.durationMs)
            adjusted = sabr_applyRepeatPlayerTimeNudge(playbackContext, contentType, currentFormat, requestByteRange, candidate, durationMs, label)
            adjustedValue = sabr_toInt(adjusted?.value)
            if adjustedValue = invalid then adjustedValue = candidate
            adjustedSource = `${adjusted?.source ?? label}`
            segmentStartMs = sabr_toInt(result?.segmentStartMs)
            segmentDurationMs = sabr_toInt(result?.segmentDurationMs)
            output = {
                "value": adjustedValue
                "source": adjustedSource
            }
            if segmentStartMs <> invalid
                output["segmentStartMs"] = segmentStartMs
            end if
            if segmentDurationMs <> invalid
                output["segmentDurationMs"] = segmentDurationMs
            end if
            return output
        end if
    end for

    actualPositionMs = sabr_currentPlayerPositionMs(videoNode, playbackContext)
    if actualPositionMs <> invalid and actualPositionMs >= 0
        adjusted = sabr_applyRepeatPlayerTimeNudge(playbackContext, contentType, currentFormat, requestByteRange, actualPositionMs, invalid, "playerPosition")
        adjustedValue = sabr_toInt(adjusted?.value)
        if adjustedValue = invalid then adjustedValue = actualPositionMs
        adjustedSource = `${adjusted?.source ?? "playerPosition"}`
        output = {
            "value": adjustedValue
            "source": adjustedSource
        }
        segmentStartMs = sabr_toInt(result?.segmentStartMs)
        if segmentStartMs <> invalid
            output["segmentStartMs"] = segmentStartMs
        end if
        segmentDurationMs = sabr_toInt(result?.segmentDurationMs)
        if segmentDurationMs <> invalid
            output["segmentDurationMs"] = segmentDurationMs
        end if
        return output
    end if

    fallbackValue = sabr_toInt(playbackContext?.lastRequestedPlayerTimeMs)
    fallbackSource = "lastRequestedPlayerTimeMs"
    if fallbackValue = invalid or fallbackValue < 0
        fallbackValue = 0
        fallbackSource = "default"
    end if
    adjustedFallback = sabr_applyRepeatPlayerTimeNudge(playbackContext, contentType, currentFormat, requestByteRange, fallbackValue, invalid, fallbackSource)
    finalValue = sabr_toInt(adjustedFallback?.value)
    if finalValue = invalid then finalValue = fallbackValue
    finalSource = `${adjustedFallback?.source ?? fallbackSource}`
    output = {
        "value": finalValue
        "source": `fallback:${finalSource}`
    }
    segmentStartMs = sabr_toInt(adjustedFallback?.segmentStartMs)
    if segmentStartMs <> invalid
        output["segmentStartMs"] = segmentStartMs
    end if
    segmentDurationMs = sabr_toInt(adjustedFallback?.segmentDurationMs)
    if segmentDurationMs <> invalid
        output["segmentDurationMs"] = segmentDurationMs
    end if
    return output
end function

function sabr_buildPlayerTimeIndexKey(contentType as string, format as object) as string
    sabr_traceCall("sabr_buildPlayerTimeIndexKey")
    typeLabel = `${contentType ?? ""}`
    if typeLabel = "" then typeLabel = sabr_formatTypeFromFormat(format)
    if typeLabel = "" then typeLabel = "UNKNOWN"
    return `${typeLabel}|${sabr_formatToKey(format)}`
end function

function sabr_parseFormatKey(formatKey as string) as object
    sabr_traceCall("sabr_parseFormatKey")
    info = {
        "itag": invalid
        "xtags": ""
    }
    if not isValid(formatKey) then return info
    parts = formatKey.Split(":")
    if parts.count() >= 1
        info.itag = sabr_toInt(parts[0])
    end if
    if parts.count() >= 2
        info.xtags = `${parts[1]}`
    end if
    return info
end function

sub sabr_seedMetadataFromSidx(playbackContext as object, contentType as string, formatKey as string, sidxEntry as object)
    sabr_traceCall("sabr_seedMetadataFromSidx")
    if not IsAssociativeArray(playbackContext) then return
    if not IsAssociativeArray(sidxEntry) then return

    entries = sidxEntry?.entries
    if not IsArray(entries) or entries.count() = 0 then return

    byRange = sabr_getSegmentMetadataByRangeKey(playbackContext, contentType, formatKey, true)
    if not IsAssociativeArray(byRange) then return

    formatInfo = sabr_parseFormatKey(formatKey)

    for each entry in entries
        startVal = sabr_toInt(entry?.rangeStart)
        if startVal = invalid then startVal = sabr_toInt(entry?.rangeStartLabel)
        endVal = sabr_toInt(entry?.rangeEnd)
        if endVal = invalid then endVal = sabr_toInt(entry?.rangeEndLabel)
        if startVal = invalid or endVal = invalid then continue for

        startTimeMs = sabr_toInt(entry?.startTimeMs)
        durationMs = sabr_toInt(entry?.durationMs)

        meta = {
            "formatId": {}
            "rangeStart": startVal
            "rangeEnd": endVal
            "startTimeMs": `${startTimeMs <> invalid ? startTimeMs : 0}`
            "durationMs": `${durationMs <> invalid ? durationMs : 0}`
            "timeRange": {
                "timescale": 1000
                "startTicks": startTimeMs <> invalid ? startTimeMs : 0
                "durationTicks": durationMs <> invalid ? durationMs : 0
            }
        }

        if isValid(formatInfo.itag)
            meta.formatId["itag"] = formatInfo.itag
        end if
        if formatInfo.xtags <> ""
            meta.formatId["xtags"] = formatInfo.xtags
        end if

        byRange[`${startVal}`] = meta
    end for

end sub

' Attempts to map the requested byte-range to a SIDX entry gathered from the
' init segment. Returns timing details when a match (or nearest predecessor) exists.
function sabr_getSidxEntrySet(playbackContext as object, contentType as string, currentFormat as object) as dynamic
    sabr_traceCall("sabr_getSidxEntrySet")
    result = {
        "entries": invalid
        "source": ""
        "indexEntry": invalid
    }
    if not IsAssociativeArray(playbackContext) then return result
    key = sabr_buildPlayerTimeIndexKey(contentType, currentFormat)
    if key = "" then return result

    indexMap = sabr_globalSidxIndexMap()
    entrySource = "global"
    indexEntry = invalid
    if IsAssociativeArray(indexMap) and indexMap.DoesExist(key)
        indexEntry = indexMap.Lookup(key)
    end if

    if not IsAssociativeArray(indexEntry)
        playbackMap = playbackContext?.sidxIndexByFormat
        if IsAssociativeArray(playbackMap) and playbackMap.DoesExist(key)
            indexEntry = playbackMap.Lookup(key)
            entrySource = "context"
        end if
    end if

    if IsAssociativeArray(indexEntry)
        result.entries = indexEntry.Lookup("entries")
        result.source = entrySource
        result.indexEntry = indexEntry
    end if
    return result
end function

function sabr_fetchSidxNeighbors(playbackContext as object, contentType as string, currentFormat as object, targetStart as integer) as object
    sabr_traceCall("sabr_fetchSidxNeighbors")
    neighbors = {
        "exact": invalid
        "previous": invalid
        "next": invalid
        "source": ""
    }
    if targetStart = invalid then return neighbors

    entrySet = sabr_getSidxEntrySet(playbackContext, contentType, currentFormat)
    entries = entrySet?.entries
    if not IsArray(entries) or entries.count() = 0 then return neighbors

    neighbors.source = entrySet?.source

    maxPrevStart = invalid
    minNextStart = invalid

    for each entry in entries
        if not IsAssociativeArray(entry) then continue for
        startVal = sabr_toInt(entry?.rangeStart)
        if startVal = invalid and entry.DoesExist("rangeStartLabel")
            startLabel = `${entry.rangeStartLabel ?? ""}`
            if startLabel <> "" then startVal = Val(startLabel)
        end if
        if startVal = invalid then continue for

        endVal = sabr_toInt(entry?.rangeEnd)
        if endVal = invalid and entry.DoesExist("rangeEndLabel")
            endLabel = `${entry.rangeEndLabel ?? ""}`
            if endLabel <> "" then endVal = Val(endLabel)
        end if

        if startVal <= targetStart and (endVal = invalid or targetStart <= endVal)
            neighbors["exact"] = entry
        end if

        if startVal < targetStart
            if maxPrevStart = invalid or startVal > maxPrevStart
                maxPrevStart = startVal
                neighbors["previous"] = entry
            end if
        else if startVal > targetStart
            if minNextStart = invalid or startVal < minNextStart
                minNextStart = startVal
                neighbors["next"] = entry
            end if
        end if
    end for

    if not IsAssociativeArray(neighbors.exact) and IsAssociativeArray(neighbors.previous)
        prevEnd = sabr_toInt(neighbors.previous?.rangeEnd)
        if prevEnd = invalid and neighbors.previous.DoesExist("rangeEndLabel")
            prevLabel = `${neighbors.previous.rangeEndLabel ?? ""}`
            if prevLabel <> "" then prevEnd = Val(prevLabel)
        end if
        if prevEnd <> invalid and targetStart <= prevEnd
            neighbors["exact"] = neighbors.previous
        end if
    end if

    neighbors["indexEntry"] = entrySet?.indexEntry
    return neighbors
end function

function sabr_lookupPlayerTimeMsFromSidx(playbackContext as object, contentType as string, currentFormat as object, requestByteRange as object) as object
    sabr_traceCall("sabr_lookupPlayerTimeMsFromSidx")
    result = {
        "value": invalid
        "source": "sidx"
    }
    if not IsAssociativeArray(playbackContext) then return result

    indexMap = sabr_globalSidxIndexMap()
    if not IsAssociativeArray(indexMap)
        indexMap = {}
    end if

    key = sabr_buildPlayerTimeIndexKey(contentType, currentFormat)
    if key = "" then return result

    entrySet = sabr_getSidxEntrySet(playbackContext, contentType, currentFormat)
    indexEntry = entrySet?.indexEntry
    entrySource = entrySet?.source
    if not IsAssociativeArray(indexEntry) then return result

    if indexEntry.DoesExist("unsupportedReason")
        reasonLabel = `${indexEntry.Lookup("unsupportedReason") ?? ""}`
        if reasonLabel <> ""
            result["source"] = `sidx:unsupported:${reasonLabel}`
            if isValid(m?.logs)
                sabr_log(m.logs, log_level_Type.DEBUG, `[YTSABR-PlayerTime] SIDX unsupported for ${key} source=${entrySource} reason=${reasonLabel}`)
            end if
            return result
        end if
    end if

    entries = entrySet?.entries
    if not IsArray(entries) or entries.count() = 0 then return result

    targetStart = sabr_requestedByteStart(requestByteRange)
    if targetStart = invalid then return result
    targetValue = targetStart

    if isValid(m?.logs)
        firstEntry = entries[0]
        sabr_log(m.logs, log_level_Type.DEBUG, `[YTSABR-PlayerTime] SIDX lookup ${key} source=${entrySource} target=${targetValue} entries=${entries.count()} firstStart=${firstEntry?.rangeStart} duration=${firstEntry?.durationMs}`)
    end if

    neighbors = sabr_fetchSidxNeighbors(playbackContext, contentType, currentFormat, targetValue)
    candidateEntry = neighbors?.exact
    label = "sidx"
    if IsAssociativeArray(candidateEntry)
        startVal = sabr_toInt(candidateEntry?.rangeStart)
        if startVal = invalid and candidateEntry.DoesExist("rangeStartLabel")
            startLabel = `${candidateEntry.rangeStartLabel ?? ""}`
            if startLabel <> "" then startVal = Val(startLabel)
        end if
        if startVal <> invalid and startVal <> targetValue
            label = "sidx:contains"
        else
            label = "sidx:exact"
        end if
    else
        prevEntry = neighbors?.previous
        nextEntry = neighbors?.next

        prevStart = invalid
        nextStart = invalid
        if IsAssociativeArray(prevEntry)
            prevStart = sabr_toInt(prevEntry?.rangeStart)
            if prevStart = invalid and prevEntry.DoesExist("rangeStartLabel")
                prevLabel = `${prevEntry.rangeStartLabel ?? ""}`
                if prevLabel <> "" then prevStart = Val(prevLabel)
            end if
        end if
        if IsAssociativeArray(nextEntry)
            nextStart = sabr_toInt(nextEntry?.rangeStart)
            if nextStart = invalid and nextEntry.DoesExist("rangeStartLabel")
                nextLabel = `${nextEntry.rangeStartLabel ?? ""}`
                if nextLabel <> "" then nextStart = Val(nextLabel)
            end if
        end if

        if IsAssociativeArray(prevEntry) and IsAssociativeArray(nextEntry)
            diffPrev = 2147483647
            diffNext = 2147483647
            if prevStart <> invalid then diffPrev = targetValue - prevStart
            if nextStart <> invalid then diffNext = nextStart - targetValue
            if diffNext < 0 then diffNext = 2147483647
            if diffPrev < 0 then diffPrev = 2147483647
            if diffNext < diffPrev
                candidateEntry = nextEntry
                label = "sidx:nearest-next"
            else
                candidateEntry = prevEntry
                label = "sidx:nearest-prev"
            end if
        else if IsAssociativeArray(nextEntry)
            candidateEntry = nextEntry
            label = "sidx:nearest-next"
        else if IsAssociativeArray(prevEntry)
            candidateEntry = prevEntry
            label = "sidx:nearest-prev"
        end if
    end if

    if not IsAssociativeArray(candidateEntry)
        if isValid(m?.logs)
            sabr_log(m.logs, log_level_Type.DEBUG, `[YTSABR-PlayerTime] SIDX lookup miss for ${key} target=${targetValue}`)
        end if
        return result
    end if

    predicted = sabr_predictPlayerTimeFromSidxEntry(candidateEntry, targetStart)
    durationMs = sabr_toInt(candidateEntry?.durationMs)
    if predicted = invalid then return result

    if isValid(m?.logs)
        logMsg = `[YTSABR-PlayerTime] SIDX match ${label} start=${candidateEntry?.rangeStart ?? candidateEntry?.rangeStartLabel} `
        logMsg = `${logMsg}end=${candidateEntry?.rangeEnd ?? candidateEntry?.rangeEndLabel} startMs=${candidateEntry?.startTimeMs ?? "?"} durationMs=${candidateEntry?.durationMs ?? "?"} predicted=${predicted}`
        sabr_log(m.logs, log_level_Type.DEBUG, logMsg)
    end if

    result["value"] = predicted
    result["source"] = label
    segmentStartMs = sabr_toInt(candidateEntry?.startTimeMs)
    if segmentStartMs <> invalid
        result["segmentStartMs"] = segmentStartMs
    end if
    if durationMs <> invalid and durationMs > 0
        result["durationMs"] = durationMs
        result["segmentDurationMs"] = durationMs
    end if
    return result
end function

function sabr_predictPlayerTimeFromSidxEntry(entry as object, targetStart as dynamic) as dynamic
    sabr_traceCall("sabr_predictPlayerTimeFromSidxEntry")
    if not IsAssociativeArray(entry) then return invalid
    startMs = sabr_toInt(entry?.startTimeMs)
    if startMs = invalid then return invalid

    durationMs = sabr_toInt(entry?.durationMs)
    rangeStart = sabr_toInt(entry?.rangeStart)
    if rangeStart = invalid and entry.DoesExist("rangeStartLabel")
        labelStart = `${entry.rangeStartLabel ?? ""}`
        if labelStart <> ""
            rangeStart = sabr_toInt(labelStart)
            if rangeStart = invalid
                rangeStart = Val(labelStart)
            end if
        end if
    end if
    rangeEnd = sabr_toInt(entry?.rangeEnd)
    if rangeEnd = invalid and entry.DoesExist("rangeEndLabel")
        labelEnd = `${entry.rangeEndLabel ?? ""}`
        if labelEnd <> ""
            rangeEnd = sabr_toInt(labelEnd)
            if rangeEnd = invalid
                rangeEnd = Val(labelEnd)
            end if
        end if
    end if
    if durationMs = invalid or rangeStart = invalid or rangeEnd = invalid then return startMs

    span = rangeEnd - rangeStart + 1
    if span <= 0 then return startMs

    targetValue = targetStart * 1.0
    offset = targetStart - rangeStart
    if offset <= 0 then return startMs

    predicted = startMs + int((offset * durationMs) / span)
    if predicted < startMs then predicted = startMs
    maxMs = startMs
    if durationMs <> invalid and durationMs >= 0
        maxMs = startMs + durationMs
    end if
    if predicted > maxMs then predicted = maxMs
    return predicted
end function

' Uses previously delivered SABR metadata to estimate the requested segments
' start time and duration when no SIDX entry is available.
function sabr_lookupPlayerTimeMsFromMetadata(playbackContext as object, contentType as string, currentFormat as object, requestByteRange as object) as object
    sabr_traceCall("sabr_lookupPlayerTimeMsFromMetadata")
    result = {
        "value": invalid
        "source": "metadata"
    }
    if not IsAssociativeArray(playbackContext) then return result

    targetStart = sabr_requestedByteStart(requestByteRange)
    if targetStart = invalid then return result

    metadataByRange = sabr_getSegmentMetadataByRange(playbackContext, contentType, currentFormat, false)
    if not IsAssociativeArray(metadataByRange) or metadataByRange.Count() = 0
        key = sabr_buildPlayerTimeIndexKey(contentType, currentFormat)
        indexMap = sabr_globalSidxIndexMap()
        if key <> "" and IsAssociativeArray(indexMap) and indexMap.DoesExist(key)
            sabr_seedMetadataFromSidx(playbackContext, contentType, sabr_formatToKey(currentFormat), indexMap.Lookup(key))
            metadataByRange = sabr_getSegmentMetadataByRange(playbackContext, contentType, currentFormat, false)
        end if
    end if
    if not IsAssociativeArray(metadataByRange) or metadataByRange.Count() = 0 then return result

    if isValid(m?.logs)
        sabr_log(m.logs, log_level_Type.DEBUG, `[YTSABR-PlayerTime] Metadata lookup ${sabr_buildPlayerTimeIndexKey(contentType, currentFormat)} entries=${metadataByRange.Count()}`)
    end if

    exactKey = `${targetStart}`
    meta = invalid
    if metadataByRange.DoesExist(exactKey)
        meta = metadataByRange.Lookup(exactKey)
    else
        smallerKey = invalid
        for each key in metadataByRange
            startVal = sabr_toInt(key)
            if startVal = invalid then startVal = sabr_toInt(metadataByRange.Lookup(key)?.rangeStart)
            if startVal <> invalid and startVal <= targetStart
                if smallerKey = invalid or startVal > sabr_toInt(smallerKey)
                    smallerKey = key
                end if
            end if
        end for
        if isValid(smallerKey)
            meta = metadataByRange.Lookup(smallerKey)
        end if
    end if

    if IsAssociativeArray(meta)
        predicted = sabr_predictPlayerTimeFromMetadata(meta, targetStart)
        durationMs = sabr_segmentDurationMs(meta)
        if predicted <> invalid
            if isValid(m?.logs)
                sabr_log(m.logs, log_level_Type.DEBUG, `[YTSABR-PlayerTime] Metadata exact start=${meta?.rangeStart ?? meta?.startRange} end=${meta?.rangeEnd ?? meta?.endRange} startMs=${meta?.startTimeMs ?? "?"} durationMs=${meta?.durationMs ?? "?"} predicted=${predicted}`)
            end if
            result["value"] = predicted
            result["source"] = "metadata:exact"
            if startMs <> invalid
                result["segmentStartMs"] = startMs
            end if
            if durationMs <> invalid and durationMs > 0
                result["durationMs"] = durationMs
                result["segmentDurationMs"] = durationMs
            end if
            return result
        end if
    end if

    bestCandidate = invalid
    bestLabel = "metadata:nearest"
    bestStart = -2147483647

    for each key in metadataByRange
        meta = metadataByRange.Lookup(key)
        startVal = sabr_toInt(meta?.rangeStart)
        if startVal = invalid then startVal = sabr_toInt(meta?.startRange)
        endVal = sabr_toInt(meta?.rangeEnd)
        if endVal = invalid then endVal = sabr_toInt(meta?.endRange)
        if startVal = invalid then continue for

        if endVal <> invalid and targetStart >= startVal and targetStart <= endVal
            predicted = sabr_predictPlayerTimeFromMetadata(meta, targetStart)
            durationMs = sabr_segmentDurationMs(meta)
            if predicted <> invalid
                if isValid(m?.logs)
                    sabr_log(m.logs, log_level_Type.DEBUG, `[YTSABR-PlayerTime] Metadata within start=${startVal} end=${endVal} startMs=${meta?.startTimeMs ?? "?"} durationMs=${meta?.durationMs ?? "?"} predicted=${predicted}`)
                end if
        result["value"] = predicted
        result["source"] = "metadata:within"
        startMs = sabr_segmentStartMs(meta)
        if startMs = invalid then startMs = sabr_toInt(meta?.startTimeMs)
        if startMs <> invalid
            result["segmentStartMs"] = startMs
        end if
        if durationMs <> invalid and durationMs > 0
            result["durationMs"] = durationMs
            result["segmentDurationMs"] = durationMs
        end if
        return result
    end if
        end if

        if targetStart >= startVal and startVal > bestStart
            bestStart = startVal
            bestCandidate = meta
        end if
    end for

    if not IsAssociativeArray(bestCandidate) then return result

    predicted = sabr_predictPlayerTimeFromMetadata(bestCandidate, targetStart)
    if predicted = invalid then return result
    durationMs = sabr_segmentDurationMs(bestCandidate)

    if isValid(m?.logs)
        sabr_log(m.logs, log_level_Type.DEBUG, `[YTSABR-PlayerTime] Metadata nearest start=${bestCandidate?.rangeStart ?? bestCandidate?.startRange} end=${bestCandidate?.rangeEnd ?? bestCandidate?.endRange} startMs=${bestCandidate?.startTimeMs ?? "?"} durationMs=${bestCandidate?.durationMs ?? "?"} predicted=${predicted}`)
    end if

    result["value"] = predicted
    result["source"] = bestLabel
    startMs = sabr_segmentStartMs(bestCandidate)
    if startMs = invalid then startMs = sabr_toInt(bestCandidate?.startTimeMs)
    if startMs <> invalid
        result["segmentStartMs"] = startMs
    end if
    if durationMs <> invalid and durationMs > 0
        result["durationMs"] = durationMs
        result["segmentDurationMs"] = durationMs
    end if
    return result
end function

function sabr_predictPlayerTimeFromMetadata(metadata as object, targetStart as integer) as dynamic
    sabr_traceCall("sabr_predictPlayerTimeFromMetadata")
    if not IsAssociativeArray(metadata) then return invalid

    startMs = sabr_segmentStartMs(metadata)
    if startMs = invalid then startMs = sabr_toInt(metadata?.startTimeMs)
    if startMs = invalid then return invalid

    durationMs = sabr_segmentDurationMs(metadata)
    rangeStart = sabr_toInt(metadata?.rangeStart)
    if rangeStart = invalid then rangeStart = sabr_toInt(metadata?.startRange)
    rangeEnd = sabr_toInt(metadata?.rangeEnd)
    if rangeEnd = invalid then rangeEnd = sabr_toInt(metadata?.endRange)

    if durationMs = invalid or rangeStart = invalid or rangeEnd = invalid then return startMs

    span = rangeEnd - rangeStart + 1
    if span <= 0 then return startMs

    offset = targetStart - rangeStart
    if offset <= 0 then return startMs

    predicted = startMs + int((offset * durationMs) / span)
    if predicted < startMs then predicted = startMs
    maxMs = startMs
    if durationMs <> invalid and durationMs >= 0
        maxMs = startMs + durationMs
    end if
    if predicted > maxMs then predicted = maxMs
    return predicted
end function

function sabr_applyRepeatPlayerTimeNudge(playbackContext as object, contentType as string, currentFormat as object, requestByteRange as object, baseValue as integer, durationMs = invalid as dynamic, sourceLabel = "" as string) as object
    sabr_traceCall("sabr_applyRepeatPlayerTimeNudge")
    result = {
        "value": baseValue
        "source": sourceLabel
    }
    if not IsAssociativeArray(playbackContext) then return result

    repeatKey = sabr_buildRepeatRequestKey(contentType, currentFormat, requestByteRange)
    if repeatKey = "" then return result

    repeatState = playbackContext?.repeatRequestState
    if not IsAssociativeArray(repeatState) then return result
    if `${repeatState?.lastKey ?? ""}` <> repeatKey then return result

    failureStreak = sabr_toInt(repeatState?.failureStreak)
    if failureStreak = invalid or failureStreak <= 0 then return result

    priorKey = `${playbackContext?.lastRepeatPlayerTimeKey ?? ""}`
    if priorKey = repeatKey
        priorCandidate = sabr_toInt(playbackContext?.lastRepeatPlayerTimeCandidate)
        if priorCandidate <> invalid and priorCandidate > baseValue
            baseValue = priorCandidate
        end if
    end if

    bump = sabr_toInt(durationMs)
    if bump = invalid or bump <= 0 then bump = 1000
    bump = int(bump / 2)
    if bump < 250 then bump = 250
    if bump > 2000 then bump = 2000

    adjustedValue = baseValue + bump
    if adjustedValue < 0 then adjustedValue = baseValue

    repeatSuffix = `+repeat${failureStreak}`
    newSource = sourceLabel
    if newSource = ""
        newSource = repeatSuffix
    else
        newSource = `${newSource}${repeatSuffix}`
    end if

    if isValid(m?.logs)
        sabr_log(m.logs, log_level_Type.DEBUG, `[YTSABR-PlayerTime] Repeat bump applied key=${repeatKey} failures=${failureStreak} base=${baseValue} bump=${bump} => ${adjustedValue}`)
    end if

    playbackContext["lastRepeatPlayerTimeBumpMs"] = bump
    playbackContext["lastRepeatPlayerTimeCandidate"] = adjustedValue
    playbackContext["lastRepeatPlayerTimeKey"] = repeatKey

    result["value"] = adjustedValue
    result["source"] = newSource
    result["bumpMs"] = bump
    return result
end function

sub sabr_storeSidxIndexUpdate(playbackContext as object, contentType as string, update as object)
    sabr_traceCall("sabr_storeSidxIndexUpdate")
    if not IsAssociativeArray(playbackContext) then return
    if not IsAssociativeArray(update) then return

    formatKey = `${update?.formatKey ?? ""}`
    if formatKey = "" and update.DoesExist("format_id")
        inferred = update.Lookup("format_id")
        if IsAssociativeArray(inferred)
            itagLabel = sabr_valueToLabel(inferred.Lookup("itag"))
            xtagLabel = sabr_valueToLabel(inferred.Lookup("xtags"))
            formatKey = `${itagLabel}:${xtagLabel}`
        end if
    end if
    if formatKey = "" then return

    typeLabel = `${update?.contentType ?? contentType ?? ""}`
    if typeLabel = "" then typeLabel = contentType
    indexKey = `${typeLabel ?? ""}`
    if indexKey = "" then indexKey = "UNKNOWN"
    indexKey = `${indexKey}|${formatKey}`

    sanitized = {
        "formatKey": formatKey
        "entries": []
        "timescale": sabr_toInt(update?.timescale)
        "earliestPresentationTime": update?.earliestPresentationTime
        "contentType": typeLabel
    }

    if update.DoesExist("unsupportedReason")
        sanitized["unsupportedReason"] = `${update.Lookup("unsupportedReason")}`
    end if

    entryList = update?.entries
    if IsArray(entryList)
        cleaned = []
        for each entry in entryList
            if not IsAssociativeArray(entry) then continue for
            startNumeric = sabr_toInt(entry?.rangeStart)
            if startNumeric = invalid and isValid(entry?.rangeStart)
                labelStart = `${entry.rangeStart}`
                if labelStart <> ""
                    startNumeric = Val(labelStart)
                end if
            end if
            endNumeric = sabr_toInt(entry?.rangeEnd)
            if endNumeric = invalid and isValid(entry?.rangeEnd)
                labelEndVal = `${entry.rangeEnd}`
                if labelEndVal <> ""
                    endNumeric = Val(labelEndVal)
                end if
            end if
            cleanedEntry = {
                "rangeStart": startNumeric
                "rangeEnd": endNumeric
                "startTimeMs": sabr_toInt(entry?.startTimeMs)
                "durationMs": sabr_toInt(entry?.durationMs)
                "referenceType": sabr_toInt(entry?.referenceType)
            }
            if isValid(entry?.rangeStart)
                cleanedEntry["rangeStartLabel"] = `${entry.rangeStart}`
            end if
            if isValid(entry?.rangeEnd)
                cleanedEntry["rangeEndLabel"] = `${entry.rangeEnd}`
            end if
            cleaned.push(cleanedEntry)
        end for
        sanitized["entries"] = cleaned
    end if

    map = playbackContext?.sidxIndexByFormat
    if not IsAssociativeArray(map)
        map = {}
    end if
    map[indexKey] = sanitized
    playbackContext["sidxIndexByFormat"] = map

    globalMap = sabr_globalSidxIndexMap()
    globalMap[indexKey] = sanitized
    m.sidxIndexCache = globalMap

    sabr_seedMetadataFromSidx(playbackContext, typeLabel, formatKey, sanitized)

    if isValid(m?.logs)
        entryCount = IsArray(sanitized.entries) ? sanitized.entries.count() : 0
        reason = sanitized?.unsupportedReason
        if isValid(reason) and reason <> ""
            sabr_log(m.logs, log_level_Type.DEBUG, `[YTSABR-PlayerTime] Stored SIDX index for ${indexKey} entries=${entryCount} unsupported=${reason}`)
        else
            sabr_log(m.logs, log_level_Type.DEBUG, `[YTSABR-PlayerTime] Stored SIDX index for ${indexKey} entries=${entryCount}`)
            if entryCount > 0
                preview = sanitized.entries[0]
                sabr_log(m.logs, log_level_Type.DEBUG, `[YTSABR-PlayerTime] SIDX preview start=${preview?.rangeStart} duration=${preview?.durationMs} bytes=${preview?.rangeStart}-${preview?.rangeEnd}`)
            end if
        end if
    end if
end sub

function sabr_isInit(contentType as string, format as object, requestByteRange as object, requestRef = invalid as dynamic) as boolean
    sabr_traceCall("sabr_isInit")
    logTag = sabr_utilLogTag(contentType, requestRef)
    if sabr_rangesMatch(format?.initRange, requestByteRange)
        sabr_log(m.logs, log_level_Type.INFO, `${logTag} SABR format itag ${format.itag} init range requested: ${FormatJson(requestByteRange)}`)
        return true
    end if

    if sabr_rangesMatch(format?.indexRange, requestByteRange)
        sabr_log(m.logs, log_level_Type.INFO, `${logTag} SABR format itag ${format.itag} index range requested: ${FormatJson(requestByteRange)}`)
        return true
    end if
    return false
end function

' Returns mediaIdHash (string) or invalid if not found
function sabr_extractMediaIdHash(url as string) as dynamic
    sabr_traceCall("sabr_extractMediaIdHash")
    ' /sabr/<anything-not-a-slash>(optional slash)
    re = CreateObject("roRegex", "/sabr/([^/]+)/?", "i")
    m = re.Match(url)
    if m.Count() >= 2 then return m[1]
    return invalid
end function

sub sabr_ensureInfrastructure()
    sabr_traceCall("sabr_ensureInfrastructure")
    if not isValid(m.sabrRequestMetadataManager)
        m.sabrRequestMetadataManager = sabr_createRequestMetadataManager()
    end if
    if not isValid(m.sabrActiveSessions)
        m.sabrActiveSessions = CreateObject("roAssociativeArray")
    end if
end sub

function sabr_buildPrefetchInfo(streamInfo as object, currentFormat as object, requestMetadataEntry as object) as object
    sabr_traceCall("sabr_buildPrefetchInfo")
    if not isValid(streamInfo) then return invalid
    mediaHeader = streamInfo.mediaHeader
    if not isValid(mediaHeader) then return invalid

    startTimeMs = sabr_safeToInt(mediaHeader.startTimeMs)
    durationMs = sabr_safeToInt(mediaHeader.durationMs)
    endTimeMs = startTimeMs + durationMs
    rangeLabel = sabr_formatRequestedRangeForPath(requestMetadataEntry?.byteRange)

    return {
        "formatKey": sabr_formatToKey(currentFormat)
        "endTimeMs": endTimeMs
        "durationMs": durationMs
        "byteRange": requestMetadataEntry?.byteRange
        "rangeLabel": rangeLabel
        "updatedAt": sabr_currentTimestampMs()
        "requestNumber": requestMetadataEntry?.requestNumber
    }
end function

sub sabr_maybeSchedulePrefetch(playbackContext as object, videoNode as object, prefetchInfo as object, contentType as string)
    sabr_traceCall("sabr_maybeSchedulePrefetch")
    if not isValid(playbackContext) then return
    if not isValid(prefetchInfo) then return
    if not isValid(videoNode) then return

    currentPositionMs = int((videoNode.position ?? 0) * 1000)
    remainingMs = prefetchInfo.endTimeMs - currentPositionMs

    playbackContext["prefetchState"] = prefetchInfo

    if remainingMs <= 5000 and remainingMs > -500
        if prefetchInfo.prefetchLogged <> true
            prefetchInfo.prefetchLogged = true
            prefetchInfo.loggedAt = sabr_currentTimestampMs()
            playbackContext["prefetchState"] = prefetchInfo
            logTag = sabr_utilLogTag(contentType, prefetchInfo?.requestNumber)
            rangeLabel = sabr_valueToLabel(prefetchInfo?.rangeLabel)
            if rangeLabel = ""
                rangeLabel = sabr_formatRequestedRangeForPath(prefetchInfo?.byteRange)
            end if
            sabr_log(m.logs, log_level_Type.INFO, `${logTag} Prefetch window reached for range ${rangeLabel}; remainingMs=${remainingMs}`)
        end if
    end if
end sub

function sabr_buildSegmentCacheKeyForRange(format as object, byteRange as object) as string
    sabr_traceCall("sabr_buildSegmentCacheKeyForRange")
    if not isValid(format) then return ""
    startLabel = sabr_valueToLabel(byteRange?.startRange)
    if startLabel = "" then startLabel = sabr_valueToLabel(byteRange?.start)
    if startLabel = "" then startLabel = "0"
    endLabel = sabr_valueToLabel(byteRange?.endRange)
    if endLabel = "" then endLabel = sabr_valueToLabel(byteRange?.end)
    if endLabel = "" then endLabel = "0"
    if startLabel = "" and endLabel = "" then return ""
    rangeLabel = startLabel
    if startLabel <> "" and endLabel <> ""
        rangeLabel = `${startLabel}-${endLabel}`
    end if

    itagPart = `${format?.itag ?? ""}`
    xtagsPart = `${format?.xtags ?? ""}`

    return `${rangeLabel}-${itagPart}-${xtagsPart}`
end function

function sabr_buildRepeatRequestKey(contentType as string, format as object, byteRange as object) as string
    sabr_traceCall("sabr_buildRepeatRequestKey")
    if not isValid(byteRange) then return ""
    segmentKey = sabr_buildSegmentCacheKeyForRange(format, byteRange)
    if segmentKey = "" then return ""
    typeLabel = contentType ?? ""
    if typeLabel = "" then typeLabel = "UNKNOWN"
    return `${typeLabel}|${segmentKey}`
end function

sub sabr_debugLogRepeatState(contentType as string, requestNumber as dynamic, playbackContext as object, label as string, extra = invalid as dynamic)
    sabr_traceCall("sabr_debugLogRepeatState")
    if not isValid(m?.logs) then return
    logTag = sabr_utilLogTag(contentType, `${requestNumber}`)
    state = playbackContext?.repeatRequestState

    extraParts = []
    if isValid(extra)
        if IsString(extra)
            extraParts.push(extra)
        else if IsAssociativeArray(extra)
            for each key in extra
                extraParts.push(`${key}=${extra[key]}`)
            end for
        end if
    end if

    if not IsAssociativeArray(state)
        message = `${logTag} RepeatState ${label}: none`
        if extraParts.count() > 0 then message = `${message} ${extraParts.Join(" ")}`
        sabr_log(m.logs, log_level_Type.DEBUG, message)
        return
    end if

    pieces = [
        `key=${state?.lastKey ?? ""}`
        `count=${state?.count ?? ""}`
        `success=${state?.successStreak ?? ""}`
        `failure=${state?.failureStreak ?? ""}`
        `lastStatus=${state?.lastStatus ?? ""}`
        `lastResult=${state?.lastResult ?? ""}`
    ]
    if state?.updatedAt <> invalid
        pieces.push(`updatedAt=${state.updatedAt}`)
    end if
    if extraParts.count() > 0
        for each part in extraParts
            pieces.push(part)
        end for
    end if
    sabr_log(m.logs, log_level_Type.DEBUG, `${logTag} RepeatState ${label}: ${pieces.Join(" ")}`)
end sub

function sabr_streamInfoKey(contentType as string, format as object) as string
    sabr_traceCall("sabr_streamInfoKey")
    keyPart = sabr_formatToKey(format)
    if keyPart = ""
        keyPart = "unknown"
    end if
    typePart = contentType ?? ""
    if typePart = "" then typePart = "UNKNOWN"
    return `${typePart}|${keyPart}`
end function

sub sabr_logBufferedRanges(logTag as string, requestJson as object)
    sabr_traceCall("sabr_logBufferedRanges")
    if not isValid(m?.logs) then return
    if not IsAssociativeArray(requestJson) then return
    ranges = invalid
    if requestJson.DoesExist("clientAbrState") and IsAssociativeArray(requestJson.clientAbrState)
        ranges = requestJson.clientAbrState.Lookup("bufferedRanges")
    else if requestJson.DoesExist("bufferedRanges")
        ranges = requestJson.Lookup("bufferedRanges")
    end if

    summary = []
    if IsArray(ranges)
        for each entry in ranges
            if not IsAssociativeArray(entry) then continue for
            startLabel = sabr_valueToLabel(entry?.rangeStart)
            if startLabel = "" then startLabel = sabr_valueToLabel(entry?.startRange)
            endLabel = sabr_valueToLabel(entry?.rangeEnd)
            if endLabel = "" then endLabel = sabr_valueToLabel(entry?.endRange)
            entryType = sabr_valueToLabel(entry?.type)
            formatKey = sabr_valueToLabel(entry?.formatKey)
            summary.push(`${startLabel}-${endLabel}@${entryType}:${formatKey}`)
        end for
    end if

    selected = []
    selectedIds = requestJson?.selectedFormatIds
    if IsArray(selectedIds)
        for each id in selectedIds
            if IsAssociativeArray(id)
                itagLabel = sabr_valueToLabel(id?.itag)
                xtagLabel = sabr_valueToLabel(id?.xtags)
                selected.push(`${itagLabel}:${xtagLabel}`)
            else
                selected.push(`${id}`)
            end if
        end for
    end if

    if summary.count() = 0 and isValid(ranges)
        rawSummary = ""
        try
            rawSummary = FormatJson(ranges)
        catch e
            rawSummary = "<unserializable>"
        end try
        sabr_log(m.logs, log_level_Type.DEBUG, `${logTag} bufferedRangesRaw=${rawSummary}`)
    end if

    sabr_log(m.logs, log_level_Type.DEBUG, `${logTag} bufferedRanges=${summary.Join(" ")} selected=${selected.Join(",")}`)
end sub

function sabr_sessionKey(mediaIdHash as string, contentType as string, requestNumber as dynamic) as string
    sabr_traceCall("sabr_sessionKey")
    parts = []
    mediaLabel = sabr_valueToLabel(mediaIdHash)
    if mediaLabel <> "" then parts.push(mediaLabel)
    typeLabel = sabr_valueToLabel(contentType)
    if typeLabel <> "" then parts.push(typeLabel)
    if requestNumber <> invalid then parts.push(`${requestNumber}`)
    return sabr_joinWithPipe(parts)
end function

function sabr_storeStreamInfoForFormat(playbackContext as object, contentType as string, format as object, streamInfo as object) as void
    sabr_traceCall("sabr_storeStreamInfoForFormat")
    if not isValid(playbackContext) then return
    if not isValid(streamInfo) then return
    key = sabr_streamInfoKey(contentType, format)
    if key = "" then return

    map = playbackContext?.streamInfoByFormat
    if not IsAssociativeArray(map)
        map = createObject("roAssociativeArray")
    end if
    map[key] = streamInfo
    playbackContext["streamInfoByFormat"] = map
end function

function sabr_fetchStreamInfoForFormat(playbackContext as object, contentType as string, format as object) as dynamic
    sabr_traceCall("sabr_fetchStreamInfoForFormat")
    if not isValid(playbackContext) then return invalid
    key = sabr_streamInfoKey(contentType, format)
    if key = "" then return invalid
    map = playbackContext?.streamInfoByFormat
    if not IsAssociativeArray(map) then return invalid
    info = map.Lookup(key)
    if isValid(info) then return info
    return invalid
end function

' Tracks repeated byte-range requests that may indicate playback stalls.
' Returns an error response when the repeat guard trips, otherwise invalid.
function sabr_guardRepeatedRequests(playbackContext as object, contentType as string, currentFormat as object, requestMetadataEntry as object, requestNumber as string, videoNode as object, mediaIdHash as string) as dynamic
    sabr_traceCall("sabr_guardRepeatedRequests")
    if not isValid(playbackContext) then return invalid
    if requestMetadataEntry?.isInit = true then return invalid

    repeatKey = sabr_buildRepeatRequestKey(contentType, currentFormat, requestMetadataEntry?.byteRange)
    if repeatKey = "" then return invalid
    requestMetadataEntry["repeatKey"] = repeatKey

    nowTs = sabr_currentTimestampMs()
    logTag = sabr_utilLogTag(contentType, requestNumber)
    repeatState = playbackContext?.repeatRequestState
    consecutiveCount = 1
    lastKey = ""
    lastCount = 0
    lastUpdated = invalid
    successStreak = 0
    failureStreak = 0

    if IsAssociativeArray(repeatState)
        lastKey = repeatState?.lastKey ?? ""
        lastCount = sabr_toInt(repeatState?.count)
        lastUpdated = sabr_toInt(repeatState?.updatedAt)
        successStreak = sabr_toInt(repeatState?.successStreak)
        failureStreak = sabr_toInt(repeatState?.failureStreak)
    end if

    if lastKey = repeatKey and lastCount <> invalid and lastCount > 0
        if lastUpdated = invalid or (nowTs - lastUpdated) <= SABR_REPEAT_SEGMENT_WINDOW_MS
            consecutiveCount = lastCount + 1
        end if
    else
        successStreak = 0
        failureStreak = 0
    end if

    rangeLabel = sabr_formatRequestedRangeForPath(requestMetadataEntry?.byteRange)
    newState = {
        "lastKey": repeatKey
        "count": consecutiveCount
        "updatedAt": nowTs
        "lastRequestNumber": requestNumber
        "range": rangeLabel
        "formatKey": sabr_formatToKey(currentFormat)
        "successStreak": successStreak
        "failureStreak": failureStreak
        "lastResult": repeatState?.lastResult ?? ""
        "lastStatus": repeatState?.lastStatus
    }
    playbackContext["repeatRequestState"] = newState

    deltaMs = -1
    if lastUpdated <> invalid then deltaMs = nowTs - lastUpdated
    extra = `key=${repeatKey} deltaMs=${deltaMs} range=${rangeLabel}`
    sabr_debugLogRepeatState(contentType, requestNumber, playbackContext, "before_guard", extra)

    if failureStreak < SABR_REPEAT_SEGMENT_THRESHOLD then return invalid

    fatalMessage = `Repeated SABR requests detected for segment ${repeatKey} (range ${rangeLabel}); aborting playback`
    playbackContext["sabrFatalError"] = {
        "reason": fatalMessage
        "requestNumber": requestNumber
        "timestamp": nowTs
    }
    newState["aborted"] = true
    playbackContext["repeatRequestState"] = newState

    sabr_debugLogRepeatState(contentType, requestNumber, playbackContext, "guard_abort", extra)

    sabr_log(m.logs, log_level_Type.WARN, `${logTag} ${fatalMessage}`, false)

    if isValid(videoNode)
        try
            videoNode.control = "stop"
        catch e
            sabr_log(m.logs, log_level_Type.DEBUG, `${logTag} Failed to stop video node after repeat guard: ${e?.message}`)
        end try
    end if

    serialized = FormatJson(playbackContext)
    if isValid(serialized) and serialized <> ""
        writeFile(`tmp:/${mediaIdHash}/playbackContext.json`, serialized)
    end if

    return sabr_buildErrorResponseForPlayer(502, fatalMessage)
end function

sub sabr_recordRepeatResult(playbackContext as object, requestMetadataEntry as object, response as object, contentType = "" as string, requestNumber = invalid as dynamic)
    sabr_traceCall("sabr_recordRepeatResult")
    if not isValid(playbackContext) then return
    repeatKey = `${requestMetadataEntry?.repeatKey ?? ""}`
    if repeatKey = "" then return

    repeatState = playbackContext?.repeatRequestState
    if not IsAssociativeArray(repeatState) then return
    if `${repeatState?.lastKey ?? ""}` <> repeatKey then return

    statusVal = sabr_toInt(response?.status)
    success = false
    if statusVal <> invalid
        if statusVal = 206 or ((statusVal >= 200 and statusVal < 300) and statusVal <> 204)
            success = true
        end if
    end if

    if success
        body = response?.body
        bodyPath = sabr_toSafeString(response?.bodyPath)
        if GetInterface(body, "ifByteArray") <> invalid and body.count() = 0 and bodyPath = ""
            success = false
        end if
    end if

    successCount = sabr_toInt(repeatState?.successStreak)
    if successCount = invalid then successCount = 0
    failureCount = sabr_toInt(repeatState?.failureStreak)
    if failureCount = invalid then failureCount = 0

    if success
        repeatState["successStreak"] = successCount + 1
        repeatState["failureStreak"] = 0
    else
        repeatState["failureStreak"] = failureCount + 1
        repeatState["successStreak"] = 0
    end if

    repeatState["lastResult"] = success ? "success" : "failure"
    repeatState["lastStatus"] = statusVal
    repeatState["updatedAt"] = sabr_currentTimestampMs()

    playbackContext["repeatRequestState"] = repeatState

    if contentType <> ""
        if requestNumber = invalid then requestNumber = requestMetadataEntry?.requestNumber
        extra = `key=${repeatKey} status=${statusVal} success=${success}`
        sabr_debugLogRepeatState(contentType, requestNumber, playbackContext, "after_result", extra)
    end if
end sub

function sabr_formatTypeFromFormat(format as dynamic) as string
    sabr_traceCall("sabr_formatTypeFromFormat")
    mimeType = format?.mimeType ?? ""
    if mimeType.inStr("audio") > -1 then return "AUDIO"
    if mimeType.inStr("video") > -1 then return "VIDEO"
    if isValid(format?.width) then return "VIDEO"
    return "AUDIO"
end function

function sabr_mediaHeaderToSegmentMetadata(mediaHeader as dynamic, coverage = invalid as dynamic) as dynamic
    sabr_traceCall("sabr_mediaHeaderToSegmentMetadata")
    if not isValid(mediaHeader) then return invalid
    formatId = mediaHeader?.formatId
    if not isValid(formatId) then return invalid

    startSequenceNumber = sabr_toInt(mediaHeader?.sequenceNumber)
    endSequenceNumber = startSequenceNumber
    sequenceNumber = startSequenceNumber
    if sequenceNumber = invalid then sequenceNumber = sabr_toInt(coverage?.sequenceNumber)
    if sequenceNumber = invalid or sequenceNumber <= 0 then sequenceNumber = 1
    if startSequenceNumber = invalid or startSequenceNumber <= 0 then startSequenceNumber = sequenceNumber
    if endSequenceNumber = invalid or endSequenceNumber <= 0 then endSequenceNumber = sequenceNumber

    durationMs = mediaHeader?.durationMs ?? ""
    if durationMs = "" then durationMs = mediaHeader?.timeRange?.durationTicks ?? ""
    timescale = sabr_toInt(mediaHeader?.timeRange?.timescale)
    if timescale = invalid then timescale = 1000

    metadata = {
        "formatId": mediaHeader.formatId
        "startSequenceNumber": startSequenceNumber
        "endSequenceNumber": endSequenceNumber
        "sequenceNumber": sequenceNumber
        "startTimeMs": mediaHeader.startMs ?? "0"
        "durationMs": durationMs ?? "0"
        "timescale": timescale
        "timeRange": mediaHeader.timeRange
    }
    defaultStartRange = mediaHeader.startRange ?? mediaHeader.start ?? ""

    if isValid(coverage)
        if isValid(coverage?.rangeStart)
            metadata["rangeStart"] = coverage.rangeStart
        else if defaultStartRange <> ""
            metadata["rangeStart"] = defaultStartRange
        end if
        if isValid(coverage?.rangeEnd)
            metadata["rangeEnd"] = coverage.rangeEnd
        end if
        covSeq = sabr_toInt(coverage?.sequenceNumber)
        if covSeq <> invalid and covSeq > 0
            metadata["sequenceNumber"] = covSeq
            metadata["startSequenceNumber"] = covSeq
            metadata["endSequenceNumber"] = covSeq
        end if
        if isValid(coverage?.headerId)
            metadata["headerId"] = coverage.headerId
        end if
    end if

    startRangeVal = sabr_toInt(metadata?.rangeStart)
    if startRangeVal = invalid
        if defaultStartRange <> ""
            metadata["rangeStart"] = defaultStartRange
            startRangeVal = sabr_toInt(defaultStartRange)
        end if
    end if
    if startRangeVal = invalid then startRangeVal = 0

    if not metadata.DoesExist("rangeEnd")
        contentLength = sabr_toInt(mediaHeader?.contentLength)
        if contentLength <> invalid and contentLength > 0
            metadata["rangeEnd"] = startRangeVal + contentLength - 1
        end if
    end if

    if not metadata.DoesExist("rangeStart")
        metadata["rangeStart"] = defaultStartRange
    end if
    if not metadata.DoesExist("rangeEnd")
        metadata["rangeEnd"] = startRangeVal
    end if

    startIdxVal = sabr_toInt(metadata?.startSequenceNumber)
    endIdxVal = sabr_toInt(metadata?.endSequenceNumber)
    startSeqProblem = startIdxVal = invalid or startIdxVal <= 0
    endSeqProblem = endIdxVal = invalid or endIdxVal <= 0
    if not endSeqProblem and startIdxVal <> invalid
        if endIdxVal < startIdxVal
            endSeqProblem = true
        end if
    end if
    if startSeqProblem or endSeqProblem
        headerLabel = mediaHeader?.headerId ?? ""
        sabr_log(m.logs, log_level_Type.DEBUG, `[YTSABR-Meta] Missing segment sequence metadata; headerId=${headerLabel} headerSeq=${mediaHeader?.sequenceNumber} coverageSeq=${coverage?.sequenceNumber} startSeq=${metadata?.startSequenceNumber} endSeq=${metadata?.endSequenceNumber} startType=${Type(metadata?.startSequenceNumber)} endType=${Type(metadata?.endSequenceNumber)} computedStart=${startIdxVal} computedEnd=${endIdxVal} range=${metadata?.rangeStart}-${metadata?.rangeEnd}`)
    end if

    return metadata
end function

function sabr_segmentStartMs(metadata as dynamic) as dynamic
    sabr_traceCall("sabr_segmentStartMs")
    if not isValid(metadata) then return invalid
    startMs = sabr_toInt(metadata?.startTimeMs)
    if startMs = invalid then startMs = sabr_toInt(metadata?.startMs)
    if startMs = invalid
        startTicks = sabr_toInt(metadata?.timeRange?.startTicks)
        timescale = sabr_toInt(metadata?.timeRange?.timescale)
        if startTicks <> invalid and timescale <> invalid and timescale <> 0
            startMs = int((startTicks * 1000) / timescale)
        end if
    end if
    return startMs
end function

function sabr_segmentDurationMs(metadata as dynamic) as dynamic
    sabr_traceCall("sabr_segmentDurationMs")
    if not isValid(metadata) then return invalid
    durationMs = sabr_toInt(metadata?.durationMs)
    if durationMs = invalid or durationMs <= 0
        durationTicks = sabr_toInt(metadata?.timeRange?.durationTicks)
        timescale = sabr_toInt(metadata?.timeRange?.timescale)
        if durationTicks <> invalid and timescale <> invalid and timescale <> 0
            durationMs = int((durationTicks * 1000) / timescale)
        end if
    end if
    return durationMs
end function

function sabr_lookupRecentMetadataBySequence(playbackContext as object, format as object, sequenceNumber as dynamic, contentType = "" as string) as dynamic
    sabr_traceCall("sabr_lookupRecentMetadataBySequence")
    seqVal = sabr_toInt(sequenceNumber)
    if seqVal = invalid then return invalid

    formatKey = sabr_formatToKey(format)
    initializedFormats = playbackContext?.initializedFormats
    if formatKey <> "" and IsAssociativeArray(initializedFormats) and initializedFormats.DoesExist(formatKey)
        formatState = initializedFormats.Lookup(formatKey)
        candidate = formatState?.lastSegmentMetadata
        if isValid(candidate) and sabr_toInt(candidate?.sequenceNumber) = seqVal
            return candidate
        end if
        recent = formatState?.recentSegmentMetadata
        if IsArray(recent)
            for i = recent.count() - 1 to 0
                meta = recent[i]
                if isValid(meta) and sabr_toInt(meta?.sequenceNumber) = seqVal
                    return meta
                end if
            end for
        end if
    end if

    if isValid(contentType)
        if contentType = "VIDEO"
            fallback = playbackContext?.lastVideoSegmentMetadata
        else if contentType = "AUDIO"
            fallback = playbackContext?.lastAudioSegmentMetadata
        else
            fallback = invalid
        end if
        if isValid(fallback) and sabr_toInt(fallback?.sequenceNumber) = seqVal
            return fallback
        end if
    end if

    return invalid
end function

function sabr_normalizeByteRange(rawRange as object, context = invalid as dynamic) as object
    sabr_traceCall("sabr_normalizeByteRange")
    normalized = {
        "startRange": ""
        "endRange": ""
    }

    if isValid(rawRange)
        startLabel = `${rawRange?.startRange ?? ""}`
        if startLabel = "" then startLabel = `${rawRange?.start ?? ""}`
        endLabel = `${rawRange?.endRange ?? ""}`
        if endLabel = "" then endLabel = `${rawRange?.end ?? ""}`
        if startLabel <> "" then normalized["startRange"] = startLabel
        if endLabel <> "" then normalized["endRange"] = endLabel
    end if

    if isValid(context?.segmentIndexInfo)
        normalized["segmentIndexInfo"] = context.segmentIndexInfo
    end if
    if isValid(context?.sequenceNumber)
        normalized["sequenceNumber"] = `${context.sequenceNumber}`
    end if

    return normalized
end function

function sabr_hasCompleteByteRange(byteRange as object) as boolean
    sabr_traceCall("sabr_hasCompleteByteRange")
    if not isValid(byteRange) then return false
    startLabel = `${byteRange?.startRange ?? ""}`
    if startLabel = "" then startLabel = `${byteRange?.start ?? ""}`
    endLabel = `${byteRange?.endRange ?? ""}`
    if endLabel = "" then endLabel = `${byteRange?.end ?? ""}`
    return startLabel <> "" and endLabel <> ""
end function

function sabr_byteRangeToCoverage(byteRange as object) as dynamic
    sabr_traceCall("sabr_byteRangeToCoverage")
    startVal = invalid
    endVal = invalid

    startLabel = `${byteRange?.startRange ?? ""}`
    if startLabel = "" then startLabel = `${byteRange?.start ?? ""}`
    if startLabel <> ""
        startVal = sabr_toInt(startLabel)
    end if

    endLabel = `${byteRange?.endRange ?? ""}`
    if endLabel = "" then endLabel = `${byteRange?.end ?? ""}`
    if endLabel <> ""
        endVal = sabr_toInt(endLabel)
    end if

    if not isValid(startVal) then return invalid
    if not isValid(endVal) then return invalid
    if endVal < startVal then return invalid

    return {
        "rangeStart": startVal
        "rangeEnd": endVal
    }
end function

function sabr_rangesMatch(rangeObj as dynamic, requestRange as object) as boolean
    sabr_traceCall("sabr_rangesMatch")
    if not isValid(rangeObj) then return false

    expectedStart = `${rangeObj?.start ?? "0"}`
    if expectedStart = "" then expectedStart = `${rangeObj?.startRange ?? "0"}`
    expectedEnd = `${rangeObj?.end ?? "0"}`
    if expectedEnd = "" then expectedEnd = `${rangeObj?.endRange ?? "0"}`

    requestStart = `${requestRange?.startRange ?? "0"}`
    if requestStart = "" then requestStart = `${requestRange?.start ?? "0"}`
    requestEnd = `${requestRange?.endRange ?? "0"}`
    if requestEnd = "" then requestEnd = `${requestRange?.end ?? "0"}`

    if expectedStart = "" or expectedEnd = "" then return false
    if requestStart = "" or requestEnd = "" then return false
    return (expectedStart = requestStart) and (expectedEnd = requestEnd)
end function


sub sabr_deleteFileIfExists(path as dynamic)
    sabr_traceCall("sabr_deleteFileIfExists")
    if not isValid(path) then return
    if not IsString(path) then return
    if path = "" then return

    fs = CreateObject("roFileSystem")
    if fs.Exists(path)
        fs.Delete(path)
    end if
end sub

function sabr_utilLogTag(contentType as string, requestRef = invalid as dynamic) as string
    sabr_traceCall("sabr_utilLogTag")
    rn = sabr_extractRequestNumber(requestRef)
    if rn = ""
        return `[YTSABR-Util-${contentType}]`
    end if
    return `[YTSABR-Util-${contentType}-${rn}]`
end function

' Determines the currently active video/audio formats to use for buffering and
' SABR requests, falling back to recently used formats in playbackContext.
function sabr_getActiveFormats(currentFormat as object, sabr as object, playbackContext as object) as object
    sabr_traceCall("sabr_getActiveFormats")
    formats = sabr.adaptiveFormats
    videoFormat = invalid
    audioFormat = invalid

    mimeType = currentFormat?.mimeType ?? ""
    if mimeType.inStr("video") > -1 or isValid(currentFormat?.width)
        videoFormat = currentFormat
    else if mimeType.inStr("audio") > -1 or not isValid(currentFormat?.width)
        audioFormat = currentFormat
    end if

    if not isValid(videoFormat)
        videoFormat = playbackContext?.lastVideoFormat
    end if
    if not isValid(audioFormat)
        audioFormat = playbackContext?.lastAudioFormat
    end if

    if not isValid(videoFormat)
        videoFormat = sabr_pickBestFormat(formats, "video")
    end if
    if not isValid(audioFormat)
        audioFormat = sabr_pickBestFormat(formats, "audio")
    end if

    if isValid(videoFormat)
        playbackContext["lastVideoFormat"] = videoFormat
    end if
    if isValid(audioFormat)
        playbackContext["lastAudioFormat"] = audioFormat
    end if

    return {
        "videoFormat": videoFormat,
        "audioFormat": audioFormat
    }
end function

function sabr_pickBestFormat(formats as dynamic, mediaType as string) as dynamic
    sabr_traceCall("sabr_pickBestFormat")
    if not isValid(formats) then return invalid
    bestFormat = invalid
    bestBitrate = 0
    targetKeyword = mediaType = "audio" ? "audio" : "video"

    for each format in formats
        mimeType = format?.mimeType ?? ""
        if mimeType.inStr(targetKeyword) > -1
            bitrate = sabr_toInt(format?.bitrate)
            if bitrate = invalid then bitrate = sabr_toInt(format?.averageBitrate)
            if bitrate <> invalid and bitrate > bestBitrate
                bestBitrate = bitrate
                bestFormat = format
            end if
        end if
    end for

    return bestFormat
end function

function sabr_pickMeasuredBitrate(info as dynamic) as dynamic
    sabr_traceCall("sabr_pickMeasuredBitrate")
    if not isValid(info) then return invalid
    if isValid(info.measuredBitrate) and info.measuredBitrate > 0 then return info.measuredBitrate
    if isValid(info.streamBitrate) and info.streamBitrate > 0 then return info.streamBitrate
    return invalid
end function

' Builds the VideoPlaybackAbrRequest protobuf payload for the current segment.
' Handles buffered ranges, player-time resolution, and metadata annotations.
function sabr_createVideoPlaybackAbrRequest(request as object, contentType as string, sabr as object, currentFormat as object, activeFormats as object, playbackContext as object, playerTimeOverride as dynamic, videoNode as object, requestRef = invalid as dynamic) as object
    sabr_traceCall("sabr_createVideoPlaybackAbrRequest")
    ' Create the ABR request object
    logTag = sabr_utilLogTag(contentType, requestRef)
    if not isValid(sabr.ustreamerConfig)
        sabr_log(m.logs, log_level_Type.WARN, `${logTag} No SABR ustreamerConfig available`, false)
        return {}
    end if

    streamerContext = {
        "poToken": sabr.poToken,
        "playbackCookie": invalid, ' the playbackContext.lastPlaybackCookie will be set on handling the response nextRequestPolicy.playbackCookie
        "clientInfo": sabr.clientInfo,
        "sabrContexts": [],
        "unsentSabrContexts": [],
    }

    if isValid(playbackContext.lastPlaybackCookie)
        streamerContext["playbackCookie"] = playbackContext.lastPlaybackCookie
    end if

    if isValid(playbackContext.sabrContexts)
        streamerContext["sabrContexts"] = []
        for each key in playbackContext.sabrContexts
            streamerContext.sabrContexts.push(playbackContext.sabrContexts[key])
        end for
    end if

    playbackContext["lastPlayerTimeSecs"] = videoNode.position

    sabr_log(m.logs, log_level_Type.INFO, `${logTag} streamingSegment : ${FormatJson(videoNode.streamingSegment)}`)

    bandwidthEstimate = sabr_pickMeasuredBitrate(videoNode.completedStreamInfo)
    if not isValid(bandwidthEstimate)
        bandwidthEstimate = sabr_pickMeasuredBitrate(videoNode.streamInfo)
    end if
    if not isValid(bandwidthEstimate) and isValid(videoNode.streamingSegment) and isValid(videoNode.streamingSegment.segBitrateBps)
        bandwidthEstimate = videoNode.streamingSegment.segBitrateBps
    end if
    ' if not isValid(bandwidthEstimate) and isValid(videoNode.segment) and isValid(videoNode.segment.bandwidth)
    '     bandwidthEstimate = videoNode.segment.bandwidth
    ' end if
    if not isValid(bandwidthEstimate) or bandwidthEstimate <= 0
        bandwidthEstimate = currentFormat?.bitrate ?? 0
    end if
    if bandwidthEstimate <= 0 then bandwidthEstimate = 2000000
    if SABR_BANDWIDTH_OVERRIDE_BPS > 0
        bandwidthEstimate = SABR_BANDWIDTH_OVERRIDE_BPS
    else if SABR_BANDWIDTH_MULTIPLIER <> 1.0 and SABR_BANDWIDTH_MULTIPLIER > 0
        bandwidthEstimate = Int(bandwidthEstimate * SABR_BANDWIDTH_MULTIPLIER)
    end if

    AUDIO_ONLY = 1
    VIDEO_ONLY = 2

    overrideMs = sabr_toInt(playerTimeOverride)
    overrideUsed = overrideMs <> invalid
    desiredPlayerTimeMs = overrideMs
    if desiredPlayerTimeMs = invalid or desiredPlayerTimeMs < 0
        desiredPlayerTimeMs = sabr_toInt(playbackContext?.lastRequestedPlayerTimeMs)
        if desiredPlayerTimeMs = invalid or desiredPlayerTimeMs < 0 then desiredPlayerTimeMs = 0
        overrideUsed = false
    end if

    playbackContext["lastRequestedPlayerTimeMs"] = desiredPlayerTimeMs
    playbackContext["lastPlayerTimeSecs"] = videoNode.position

    ' include the request byte range in the log
    overrideNote = overrideUsed ? " (derived from byte range)" : " (fallback)"
    sabr_log(m.logs, log_level_Type.INFO, `${logTag} Creating SABR ABR request with playerTimeMs=${desiredPlayerTimeMs}, byteRange=${FormatJson(request.search)}, bandwidthEstimate=${bandwidthEstimate}${overrideNote}`)

    req = {
        "clientAbrState": {
            "playbackRate": videoNode.playbackSpeed ?? 1.0,
            "playerTimeMs": desiredPlayerTimeMs.toStr(),
            "clientViewportIsFlexible": false,
            "bandwidthEstimate": bandwidthEstimate.toStr(),
            "drcEnabled": currentFormat.isDrc ?? false,
            "enabledTrackTypesBitfield": isValid(currentFormat.width) ? VIDEO_ONLY : AUDIO_ONLY,
            "audioTrackId": currentFormat.audioTrackId
        },
        "bufferedRanges": [],
        "selectedFormatIds": [],
        "preferredAudioFormatIds": [activeFormats.audioFormat ?? {}],
        "preferredVideoFormatIds": [activeFormats.videoFormat ?? {}],
        "preferredSubtitleFormatIds": [],
        "videoPlaybackUstreamerConfig": sabr.ustreamerConfig,
        "streamerContext": streamerContext,
        "field1000": []
    }

    return req

end function

'     playbackContext["initializedFormats"] = initializedFormats
'     return initializedFormats
' end function

' create a bogus full buffer range with max int32 values so we fake out the youtube server to think we already have all this data in the buffer
' as we don't want it (this is how we can still get either "just" video or "just" audio segments based on the player's dash requests)
function sabr_createFullBufferRange(format as object) as object
    sabr_traceCall("sabr_createFullBufferRange")
    MAX_INT32_VALUE = 2147483647
    return {
        "formatId": sabr_formatToFormatId(format),
        "durationMs": MAX_INT32_VALUE,
        "startTimeMs": "0",
        "startSegmentIndex": MAX_INT32_VALUE,
        "endSegmentIndex": MAX_INT32_VALUE,
        "timeRange": {
            "durationTicks": MAX_INT32_VALUE,
            "startTicks": "0",
            "timescale": 1000
        }
    }
end function

function sabr_buildBufferedRangeFromMetadata(originalMetadata as dynamic) as dynamic
    sabr_traceCall("sabr_buildBufferedRangeFromMetadata")
    if not isValid(originalMetadata) then return invalid
    metadata = sabr_cloneObject(originalMetadata)
    if not isValid(metadata) then metadata = originalMetadata
    if not IsAssociativeArray(metadata) then return invalid

    sabr_normalizeSegmentTiming(metadata)

    durationMsStr = `${metadata?.durationMs ?? 0}`
    if durationMsStr = "" then durationMsStr = "0"

    startSequenceNumber = sabr_toInt(metadata?.startSequenceNumber)
    if startSequenceNumber = invalid or startSequenceNumber < 0
        startSequenceNumber = sabr_toInt(metadata?.sequenceNumber)
    end if
    if startSequenceNumber = invalid or startSequenceNumber < 0 then startSequenceNumber = 0

    endSequenceNumber = sabr_toInt(metadata?.endSequenceNumber)
    if endSequenceNumber = invalid or endSequenceNumber < startSequenceNumber
        endSequenceNumber = startSequenceNumber
    end if

    startTimeMsStr = `${metadata?.startTimeMs ?? 0}`
    if startTimeMsStr = "" then startTimeMsStr = `${metadata?.startMs ?? 0}`
    if startTimeMsStr = "" then startTimeMsStr = "0"

    timeRangeInfo = metadata?.timeRange
    timeRangeScale = sabr_toInt(timeRangeInfo?.timescale)
    if timeRangeScale = invalid or timeRangeScale <= 0 then timeRangeScale = metadata?.timescale ?? 1000
    if timeRangeScale = invalid or timeRangeScale <= 0 then timeRangeScale = 1000

    durationTicksVal = sabr_toInt(timeRangeInfo?.durationTicks)
    if durationTicksVal = invalid
        durationTicksVal = sabr_toInt(durationMsStr)
        if durationTicksVal <> invalid and timeRangeScale <> 1000
            durationTicksVal = int(durationTicksVal * timeRangeScale / 1000)
        end if
    end if
    durationTicksStr = `${durationTicksVal ?? 0}`
    if durationTicksStr = "" then durationTicksStr = durationMsStr

    startTicksVal = sabr_toInt(timeRangeInfo?.startTicks)
    if startTicksVal = invalid
        startTimeVal = sabr_toInt(startTimeMsStr)
        if startTimeVal <> invalid and timeRangeScale <> 1000
            startTicksVal = int(startTimeVal * timeRangeScale / 1000)
        else
            startTicksVal = startTimeVal
        end if
    end if
    startTicksStr = `${startTicksVal ?? 0}`
    if startTicksStr = "" then startTicksStr = startTimeMsStr

    formatted = {
        "formatId": metadata.formatId,
        "startSegmentIndex": startSequenceNumber,
        "durationMs": durationMsStr,
        "startTimeMs": startTimeMsStr,
        "endSegmentIndex": endSequenceNumber,
        "timeRange": {
            "timescale": timeRangeScale,
            "startTicks": startTicksStr,
            "durationTicks": durationTicksStr
        }
    }

    ' SABR expects buffered coverage to be normalized relative to zero so that
    ' each entry simply advertises length. Matching the TS client keeps the
    ' server from inferring gaps that precede the requested segment.
    formatted["startTimeMs"] = "0"
    formatted.timeRange["startTicks"] = "0"

    rangeStartVal = sabr_toInt(metadata?.rangeStart)
    if rangeStartVal = invalid
        rangeStartVal = sabr_toInt(metadata?.startRange)
    end if
    if rangeStartVal <> invalid then formatted["rangeStart"] = `${rangeStartVal ?? ""}`
    rangeEndVal = sabr_toInt(metadata?.rangeEnd)
    if rangeEndVal = invalid
        rangeEndVal = sabr_toInt(metadata?.endRange)
    end if
    if rangeEndVal <> invalid then formatted["rangeEnd"] = `${rangeEndVal ?? ""}`

    return formatted
end function

sub sabr_normalizeSegmentTiming(metadata as object)
    sabr_traceCall("sabr_normalizeSegmentTiming")
    if not IsAssociativeArray(metadata) then return

    timeRange = metadata?.timeRange
    if not IsAssociativeArray(timeRange)
        timeRange = {}
    end if

    timescale = sabr_toInt(timeRange?.timescale)
    if timescale = invalid or timescale <= 0
        timescale = sabr_toInt(metadata?.timescale)
    end if
    if timescale = invalid or timescale <= 0 then timescale = 1000

    startMsVal = sabr_toInt(metadata?.startTimeMs)
    if startMsVal = invalid then startMsVal = sabr_toInt(metadata?.startMs)
    if startMsVal = invalid
        startTicks = sabr_toInt(timeRange?.startTicks)
        if startTicks <> invalid
            startMsVal = int((startTicks * 1000) / timescale)
        end if
    end if
    if startMsVal <> invalid
        metadata["startTimeMs"] = startMsVal.toStr()
        metadata["startMs"] = startMsVal.toStr()
        timeRange["startTicks"] = int((startMsVal * timescale) / 1000)
    end if

    durationMsVal = sabr_toInt(metadata?.durationMs)
    if durationMsVal = invalid or durationMsVal <= 0
        durationTicks = sabr_toInt(timeRange?.durationTicks)
        if durationTicks <> invalid and durationTicks > 0
            durationMsVal = int((durationTicks * 1000) / timescale)
        end if
    end if
    if durationMsVal = invalid or durationMsVal <= 0
        durationMsVal = sabr_segmentDurationMs(metadata)
    end if
    if durationMsVal <> invalid and durationMsVal >= 0
        metadata["durationMs"] = durationMsVal.toStr()
        timeRange["durationTicks"] = int((durationMsVal * timescale) / 1000)
    end if

    metadata["timeRange"] = timeRange
end sub


' Converts SABR UMP results into an HTTP response suitable for the Roku player.
' Streams from disk when possible to avoid large in-memory buffers.
function sabr_buildResponseForPlayer(requestMetadata as object, umpResult as dynamic, currentFormat as object, requestByteRange as object, contentType as string) as object
    sabr_traceCall("sabr_buildResponseForPlayer")

    headers = CreateObject("roAssociativeArray")
    itagLabelForHeader = sabr_valueToLabel(currentFormat?.itag)
    if itagLabelForHeader = "" then itagLabelForHeader = `${requestMetadata?.format?.itag ?? ""}`
    if itagLabelForHeader <> ""
        headers["X-Cache-Itag"] = itagLabelForHeader
    end if

    mimeType = currentFormat?.mimeType
    if not isValid(mimeType) or mimeType = ""
        upperType = UCase(contentType)
        if upperType = "AUDIO"
            mimeType = "audio/mp4"
        else if upperType = "VIDEO"
            mimeType = "video/mp4"
        else
            mimeType = "application/octet-stream"
        end if
    end if
    headers["Content-Type"] = mimeType
    headers["Accept-Ranges"] = "bytes"

    requestedCoverage = sabr_byteRangeToCoverage(requestByteRange)

    chunkPlan = invalid
    chunkPath = ""
    coverage = invalid
    if IsAssociativeArray(umpResult)
        chunkPlan = umpResult.Lookup("chunks")
        chunkPath = sabr_toSafeString(umpResult?.path)
        coverage = umpResult?.coverage
    end if

    if IsArray(chunkPlan) and chunkPlan.count() > 0 and chunkPath <> ""
        totalBytes = sabr_toInt(umpResult?.totalBytes)
        if totalBytes = invalid or totalBytes <= 0
            totalBytes = 0
            for each chunkEntry in chunkPlan
                lenVal = sabr_toInt(chunkEntry?.length)
                if lenVal <> invalid then totalBytes = totalBytes + lenVal
            end for
        end if
        if totalBytes < 0 then totalBytes = 0

        rangeInfo = coverage
        if not IsAssociativeArray(rangeInfo)
            rangeInfo = {}
        end if
        rangeStart = sabr_toInt(rangeInfo?.rangeStart)
        rangeEnd = sabr_toInt(rangeInfo?.rangeEnd)
        if rangeStart = invalid and IsAssociativeArray(requestedCoverage)
            rangeStart = sabr_toInt(requestedCoverage?.rangeStart)
        end if
        if rangeStart = invalid then rangeStart = 0
        if rangeEnd = invalid and totalBytes > 0
            rangeEnd = rangeStart + totalBytes - 1
        end if

        requestedStart = invalid
        requestedEnd = invalid
        if IsAssociativeArray(requestedCoverage)
            requestedStart = sabr_toInt(requestedCoverage?.rangeStart)
            requestedEnd = sabr_toInt(requestedCoverage?.rangeEnd)
        end if

        status = 200
        if requestedStart <> invalid
            status = 206
            if requestedEnd = invalid
                if rangeEnd <> invalid
                    requestedEnd = rangeEnd
                else
                    requestedEnd = requestedStart + totalBytes - 1
                end if
            end if
            totalLabel = "*"
            if rangeEnd <> invalid
                totalLabel = (rangeEnd + 1).toStr()
            end if
            headers["Content-Range"] = `bytes ${requestedStart}-${requestedEnd}/${totalLabel}`
        end if

        headers["Content-Length"] = totalBytes.toStr()

        coverageReturn = CreateObject("roAssociativeArray")
        if rangeStart <> invalid then coverageReturn["rangeStart"] = rangeStart
        if rangeEnd <> invalid then coverageReturn["rangeEnd"] = rangeEnd

        response = {
            "status": status
            "headers": headers
            "path": chunkPath
            "chunks": chunkPlan
            "totalBytes": totalBytes
        }
        if coverageReturn.Count() > 0
            response["coverage"] = coverageReturn
        end if
        if umpResult?.isInitSeg = true
            response["isInitSeg"] = true
        end if
        return response
    end if

    dataBytes = invalid
    if IsAssociativeArray(umpResult)
        dataCandidate = umpResult.Lookup("data")
        if GetInterface(dataCandidate, "ifByteArray") <> invalid
            dataBytes = dataCandidate
        end if
    end if

    if dataBytes <> invalid and dataBytes.count() > 0
        totalBytes = dataBytes.count()
        requestedStart = invalid
        requestedEnd = invalid
        if IsAssociativeArray(requestedCoverage)
            requestedStart = sabr_toInt(requestedCoverage?.rangeStart)
            requestedEnd = sabr_toInt(requestedCoverage?.rangeEnd)
        end if
        status = 200
        if requestedStart <> invalid
            status = 206
            if requestedEnd = invalid then requestedEnd = requestedStart + totalBytes - 1
            headers["Content-Range"] = `bytes ${requestedStart}-${requestedEnd}/*`
        end if
        headers["Content-Length"] = totalBytes.toStr()
        return {
            "status": status
            "headers": headers
            "body": dataBytes
        }
    end if

    pathCandidate = ""
    if IsAssociativeArray(umpResult)
        pathCandidate = sabr_toSafeString(umpResult?.path)
    end if
    if pathCandidate <> ""
        sizeVal = sabr_fsGetFileSize(pathCandidate)
        if sizeVal <> invalid and sizeVal > 0
            requestedStart = invalid
            requestedEnd = invalid
            if IsAssociativeArray(requestedCoverage)
                requestedStart = sabr_toInt(requestedCoverage?.rangeStart)
                requestedEnd = sabr_toInt(requestedCoverage?.rangeEnd)
            end if
            status = 200
            if requestedStart <> invalid
                status = 206
                if requestedEnd = invalid then requestedEnd = requestedStart + sizeVal - 1
                headers["Content-Range"] = `bytes ${requestedStart}-${requestedEnd}/${sizeVal}`
            end if
            headers["Content-Length"] = sizeVal.toStr()
            return {
                "status": status
                "headers": headers
                "bodyPath": pathCandidate
                "bodyOffset": 0
                "bodyLength": sizeVal
            }
        end if
    end if

    headers["Content-Length"] = "0"
    emptyBody = CreateObject("roByteArray")
    return {
        "status": 204
        "headers": headers
        "body": emptyBody
    }
end function

function sabr_buildEmptyResponseForPlayer(contentType as string, currentFormat as object) as object
    sabr_traceCall("sabr_buildEmptyResponseForPlayer")
    body = CreateObject("roByteArray")

    mimeType = currentFormat?.mimeType ?? ""
    if mimeType = ""
        if contentType = "VIDEO"
            mimeType = "video/mp4"
        else if contentType = "AUDIO"
            mimeType = "audio/mp4"
        else
            mimeType = "application/octet-stream"
        end if
    end if

    headers = {
        "Content-Length": "0"
        "Accept-Ranges": "bytes"
        "Cache-Control": "no-store"
        "Content-Type": mimeType
    }

    return {
        "status": 204
        "headers": headers
        "body": body
    }
end function

function sabr_fsGetFileSize(path as string) as dynamic
    sabr_traceCall("sabr_fsGetFileSize")
    if not IsString(path) or path = "" then return invalid
    fs = CreateObject("roFileSystem")
    stat = invalid
    try
        stat = fs.Stat(path)
    catch e
        stat = invalid
    end try
    if IsAssociativeArray(stat)
        sizeVal = stat.Lookup("size")
        if sizeVal = invalid then sizeVal = stat.Lookup("length")
        return sizeVal
    end if
    return invalid
end function

' Utility for generating an HTTP error response to propagate back to the player.
function sabr_buildErrorResponseForPlayer(status as integer, message as string) as object
    sabr_traceCall("sabr_buildErrorResponseForPlayer")
    body = CreateObject("roByteArray")
    if isValid(message) and message <> ""
        body.FromAsciiString(message)
    end if

    headers = {
        "Content-Type": "text/plain"
        "Content-Length": body.count().toStr()
        "Connection": "close"
    }

    return {
        "status": status
        "headers": headers
        "body": body
    }
end function

function sabr_isFileStreamingEnabled() as boolean
    sabr_traceCall("sabr_isFileStreamingEnabled")
    return SABR_ENABLE_FILE_STREAMING = true
end function

function sabr_readSegmentRange(path as string, offset as integer, length as integer) as dynamic
    sabr_traceCall("sabr_readSegmentRange")
    if not IsString(path) or path = "" then return invalid
    if length <= 0 then
        empty = CreateObject("roByteArray")
        return empty
    end if
    safeOffset = offset
    if safeOffset = invalid or safeOffset < 0 then safeOffset = 0
    bytes = CreateObject("roByteArray")
    if bytes.ReadFile(path, safeOffset, length) <> true then return invalid
    return bytes
end function

sub sabr_applyStreamInfoUpdates(playbackContext as object, streamInfo as object, contentType as string, deliveredSegment = true as boolean, requestMetadataEntry = invalid as dynamic)
    sabr_traceCall("sabr_applyStreamInfoUpdates")
    if not isValid(streamInfo) then return

    sidxUpdates = streamInfo?.sidxIndexUpdates
    if IsArray(sidxUpdates)
        for each sidxUpdate in sidxUpdates
            sabr_storeSidxIndexUpdate(playbackContext, contentType, sidxUpdate)
        end for
    else if IsAssociativeArray(streamInfo?.sidxIndexUpdate)
        sabr_storeSidxIndexUpdate(playbackContext, contentType, streamInfo.sidxIndexUpdate)
    end if

    if isValid(streamInfo.nextRequestPolicy)
        playbackContext["nextRequestPolicy"] = streamInfo.nextRequestPolicy
        if isValid(streamInfo.nextRequestPolicy.playbackCookie)
            playbackContext["lastPlaybackCookie"] = PlaybackCookieEncode(streamInfo.nextRequestPolicy.playbackCookie)
        end if
        playbackContext["backoffTimeMs"] = streamInfo.nextRequestPolicy.backoffTimeMs
    end if

    if isValid(streamInfo.sabrContextSendingPolicy)
        playbackContext["sabrContextSendingPolicy"] = streamInfo.sabrContextSendingPolicy
    end if

    if isValid(streamInfo.sabrContextUpdate)
        contexts = playbackContext["sabrContexts"]
        if not isValid(contexts)
            contexts = CreateObject("roAssociativeArray")
        end if
        contextType = streamInfo.sabrContextUpdate.type
        if isValid(contextType)
            contexts.AddReplace(contextType.toStr(), streamInfo.sabrContextUpdate)
        end if
        playbackContext["sabrContexts"] = contexts
    end if

    if isValid(streamInfo.mediaHeader)
        initializedFormats = playbackContext.initializedFormats
        formatId = streamInfo.mediaHeader.formatId
        formatKey = sabr_formatToKey({ "itag": formatId?.itag, "xtags": formatId?.xtags })
        initializedFormat = {}
        if initializedFormats.DoesExist(formatKey)
            initializedFormat = initializedFormats.Lookup(formatKey)
        end if

        coverageData = streamInfo?.deliveredCoverage
        if isValid(coverageData)
            streamInfo["segmentCoverage"] = coverageData
        end if
        metadataFromHeader = sabr_mediaHeaderToSegmentMetadata(streamInfo.mediaHeader, coverageData)
        if isValid(metadataFromHeader)
            if deliveredSegment = true
                initializedFormat["lastSegmentMetadata"] = metadataFromHeader
                recentSegments = initializedFormat?.recentSegmentMetadata
                if not IsArray(recentSegments)
                    recentSegments = []
                end if
                recentSegments.push(metadataFromHeader)
                if recentSegments.count() > 6
                    trimmed = []
                    total = recentSegments.count()
                    startIndex = total - 6
                    for idx = startIndex to total - 1
                        trimmed.push(recentSegments[idx])
                    end for
                    recentSegments = trimmed
                end if
                initializedFormat["recentSegmentMetadata"] = recentSegments
                initializedFormats.AddReplace(formatKey, initializedFormat)
                playbackContext["initializedFormats"] = initializedFormats

                if streamInfo.mediaHeader.isInitSeg <> true
                    if contentType = "VIDEO"
                        playbackContext["lastVideoSegmentMetadata"] = metadataFromHeader
                    else if contentType = "AUDIO"
                        playbackContext["lastAudioSegmentMetadata"] = metadataFromHeader
                    end if
                end if

            end if
            sabr_recordSegmentMetadata(playbackContext, contentType, formatKey, metadataFromHeader)
        end if
    end if

    if isValid(streamInfo.formatInitMetadata)
        playbackContext["formatInitializationMetadata"] = streamInfo.formatInitMetadata
    end if

    if isValid(streamInfo.streamProtectionStatus)
        playbackContext["streamProtectionStatus"] = streamInfo.streamProtectionStatus
    end if

    if IsAssociativeArray(streamInfo) and streamInfo.DoesExist("deliveredCoverage")
        streamInfo.Delete("deliveredCoverage")
    end if
end sub

function sabr_getSegmentMetadataByRange(playbackContext as object, contentType as string, format as object, createIfMissing = false as boolean) as dynamic
    sabr_traceCall("sabr_getSegmentMetadataByRange")
    formatKey = sabr_formatToKey(format)
    return sabr_getSegmentMetadataByRangeKey(playbackContext, contentType, formatKey, createIfMissing)
end function

function sabr_getSegmentMetadataByRangeKey(playbackContext as object, contentType as string, formatKey as string, createIfMissing = false as boolean) as dynamic
    sabr_traceCall("sabr_getSegmentMetadataByRangeKey")
    if not isValid(playbackContext) then return invalid
    if formatKey = "" then return invalid

    catalog = playbackContext?.segmentMetadataByRange
    if not IsAssociativeArray(catalog)
        if not createIfMissing then return invalid
        catalog = {}
    end if

    typeKey = contentType ?? ""
    if typeKey = "" then typeKey = "UNKNOWN"
    if not catalog.DoesExist(typeKey)
        if not createIfMissing then return invalid
        catalog[typeKey] = {}
    end if

    byFormat = catalog[typeKey]
    if not IsAssociativeArray(byFormat)
        if not createIfMissing then return invalid
        byFormat = {}
        catalog[typeKey] = byFormat
    end if

    if not byFormat.DoesExist(formatKey)
        if not createIfMissing then return invalid
        byFormat[formatKey] = {}
    end if

    playbackContext["segmentMetadataByRange"] = catalog
    return byFormat[formatKey]
end function

sub sabr_recordSegmentMetadata(playbackContext as object, contentType as string, formatKey as string, metadata as dynamic)
    sabr_traceCall("sabr_recordSegmentMetadata")
    if not isValid(metadata) then return
    startRangeVal = sabr_toInt(metadata?.startRange)
    if startRangeVal = invalid then return

    byRange = sabr_getSegmentMetadataByRangeKey(playbackContext, contentType, formatKey, true)
    if not IsAssociativeArray(byRange) then return

    byRange[startRangeVal.toStr()] = metadata
end sub
'         baseStart = sabr_segmentStartMs(nearestMetadata)
'         duration = sabr_segmentDurationMs(nearestMetadata)
'         if baseStart <> invalid and duration <> invalid
'             prediction = baseStart + duration
'             if prediction >= 0 then return prediction
'         end if
'     end if

'     return invalid
' end function
sub sabr_logSpoolSummary(logs as object, logTag as string, spoolMap as dynamic)
    sabr_traceCall("sabr_logSpoolSummary")
    if not IsAssociativeArray(spoolMap) then return

    parts = spoolMap?.parts
    partCount = 0
    if IsArray(parts)
        partCount = parts.count()
    end if

    durationMs = sabr_toInt(spoolMap?.durationMs)
    if durationMs = invalid then durationMs = 0
    totalBytes = sabr_toInt(spoolMap?.totalbytes)
    if totalBytes = invalid then totalBytes = 0
    readsVal = sabr_toInt(spoolMap?.reads)
    actualBytes = sabr_toInt(spoolMap?.actualBytesRead)

    summary = `${logTag} UMP spool scan duration=${durationMs}ms parts=${partCount} bytes=${totalBytes}`
    if readsVal <> invalid then summary = `${summary} reads=${readsVal}`
    if actualBytes <> invalid then summary = `${summary} actualBytesRead=${actualBytes}`
    if spoolMap?.containsInit = true then summary = `${summary} init=true`
    sabr_log(logs, log_level_Type.INFO, summary)

    if not IsArray(parts) then return
    previewCount = parts.count()
    if previewCount <= 0 then return
    if previewCount > 5 then previewCount = 5

    previews = []
    for idx = 0 to previewCount - 1
        part = parts[idx]
        typeLabel = sabr_toSafeString(part?.typeLabel)
        if typeLabel = "" then typeLabel = sabr_toSafeString(part?.type)
        offsetLabel = sabr_toSafeString(part?.offset)
        sizeLabel = sabr_toSafeString(part?.payloadSize)
        preview = `${typeLabel}@${offsetLabel}+${sizeLabel}`
        header = part?.mediaHeader
        if IsAssociativeArray(header)
            startVal = sabr_toInt(header?.startRange)
            if startVal = invalid then startVal = sabr_toInt(header?.start)
            lengthVal = sabr_toInt(header?.contentLength)
            if startVal <> invalid and lengthVal <> invalid and lengthVal > 0
                preview = `${preview}[${startVal}-${startVal + lengthVal - 1}]`
            end if
            if header.DoesExist("isInitSeg") and header.isInitSeg = true
                preview = `${preview}{init}`
            end if
        end if
        previews.push(preview)
    end for

    previewSummary = previews.Join(", ")
    if previewSummary <> ""
        sabr_log(logs, log_level_Type.DEBUG, `${logTag} UMP spool preview ${previewSummary}`)
    end if
end sub

function sabr_selectSpoolPart(spoolMap as object, requestedRange as object) as dynamic
    sabr_traceCall("sabr_selectSpoolPart")
    if not IsAssociativeArray(spoolMap) then return invalid
    parts = spoolMap?.parts
    if not IsArray(parts) or parts.count() = 0 then return invalid

    normalizedRange = sabr_normalizeByteRange(requestedRange, invalid)
    startVal = sabr_toInt(normalizedRange?.startRange)
    if startVal = invalid then startVal = sabr_toInt(normalizedRange?.start)
    endVal = sabr_toInt(normalizedRange?.endRange)
    if endVal = invalid then endVal = sabr_toInt(normalizedRange?.end)

    for each part in parts
        header = part?.mediaHeader
        if not IsAssociativeArray(header) then continue for

        partStart = sabr_toInt(header?.startRange)
        if partStart = invalid then partStart = sabr_toInt(header?.start)
        contentLength = sabr_toInt(header?.contentLength)
        if partStart = invalid or contentLength = invalid or contentLength <= 0 then continue for
        partEnd = partStart + contentLength - 1

        requestedEnd = endVal
        if requestedEnd = invalid then requestedEnd = partEnd
        if startVal <> invalid and startVal >= partStart and requestedEnd <= partEnd
            payloadOffset = sabr_toInt(part?.payloadOffset)
            if payloadOffset = invalid then payloadOffset = part?.payloadOffset
            if payloadOffset = invalid then payloadOffset = 0
            streamOffset = payloadOffset + (startVal - partStart)
            return {
                "streamOffset": streamOffset
                "rangeStart": partStart
                "rangeEnd": partEnd
                "payloadSize": part?.payloadSize
                "mediaHeader": header
            }
        end if
    end for

    return invalid
end function
