import "pkg:/source/ytproto/generated/messages/VideoPlaybackAbrRequest.brs"
import "pkg:/source/ytproto/generated/messages/ClientAbrState.brs"
import "pkg:/source/ytproto/generated/messages/FormatId.brs"
import "pkg:/source/ytproto/generated/messages/StreamerContext.brs"
import "pkg:/source/ytproto/generated/messages/ClientInfo.brs"
import "pkg:/source/ytproto/generated/messages/TimeRange.brs"
import "pkg:/source/ytproto/generated/messages/BufferedRange.brs"
import "pkg:/source/ytproto/generated/messages/SabrContext.brs"
import "pkg:/source/ytproto/generated/messages/GLDeviceInfo.brs"
import "pkg:/source/ytproto/generated/messages/MediaCapabilities.brs"
import "pkg:/source/ytproto/generated/messages/VideoFormatCapability.brs"
import "pkg:/source/ytproto/generated/messages/AudioFormatCapability.brs"
import "pkg:/source/ytproto/generated/messages/PlaybackAuthorization.brs"
import "pkg:/source/ytproto/generated/messages/AuthorizedFormat.brs"
import "pkg:/source/ytproto/generated/messages/Range.brs"
import "pkg:/source/ytproto/generated/messages/PlaybackCookie.brs"
import "pkg:/source/ytproto/generated/messages/UnknownInnerMessage.brs"
import "pkg:/source/ytproto/generated/messages/UnknownInnerMessage1.brs"
import "pkg:/source/ytproto/generated/messages/UnknownMessage3.brs"
import "pkg:/source/ytproto/generated/messages/VideoStreamingBufferedRangeUnknownMessage1.brs"
import "pkg:/source/ytproto/generated/messages/VideoStreamingBufferedRangeUnknownMessage2.brs"
import "pkg:/source/ytproto/generated/messages/VideoStreamingStreamerContextUnknownMessage1.brs"
import "pkg:/source/ytproto/generated/messages/VideoStreamingUnknownMessage1.brs"
import "pkg:/source/ytproto/generated/messages/VideoStreamingUnknownMessage2.brs"
import "pkg:/source/SabrUmpProcessor.bs"
import "pkg:/source/SabrRequestMetadataManager.bs"
import "pkg:/source/httpRequest.bs"
import "pkg:/source/SabrUtils.bs"
import "pkg:/source/SabrDebug.bs"
import "pkg:/source/SabrMp4Parser.bs"
import "pkg:/source/taskUtils.bs"

'------------------------------------------------------------------------------
' Entry: sabr_handleRequest
' Purpose: minimal SABR adapter that streams each request directly from the
'          SABR spool pipeline, caching only init segments on disk.
'------------------------------------------------------------------------------
function sabr_handleRequest(request as object, contentType as string, mediaIdHash as string, sabr as object, videoNode as object, queuedAtMs = invalid as dynamic, redirectDepth = 0 as integer) as object
    playbackContext = sabr_loadPlaybackContext(mediaIdHash)
    requestNumber = sabr_nextRequestId(playbackContext)
    logTag = `[YTSABR-${contentType}-${requestNumber}]`
    sabr_pruneOtherMediaDirs(mediaIdHash)
    sabr_ensureMediaDir(mediaIdHash)

    requestByteRange = sabr_getHeaderByteRange(request)
    requestByteRange = sabr_normalizeByteRange(requestByteRange, {
        "mediaIdHash": mediaIdHash
        "contentType": contentType
    })

    itagKey = request.search.key
    currentFormat = sabr_findFormatForKey(itagKey, sabr, contentType, logTag)
    if not isValid(currentFormat)
        return sabr_buildErrorResponseForPlayer(404, "missing format")
    end if

    activeFormats = sabr_getActiveFormats(currentFormat, sabr, playbackContext)

    isInitRequest = sabr_isInit(contentType, currentFormat, requestByteRange, logTag)

    streamResult = invalid
    servedFromCache = false
    if isInitRequest
        initResponse = sabr_tryServeCachedInitSegment(playbackContext, mediaIdHash, contentType, itagKey, requestByteRange, true, logTag)
        if IsAssociativeArray(initResponse)
            streamResult = initResponse
            streamResult["servedFromInitCache"] = true
            servedFromCache = true
        end if
    end if

    if not IsAssociativeArray(streamResult)
        sabrRequest = sabr_prepareProtoRequest(request, contentType, sabr, currentFormat, activeFormats, requestByteRange, playbackContext, videoNode, isInitRequest, logTag, requestNumber)
        if not isValid(sabrRequest)
            return sabr_buildErrorResponseForPlayer(500, "proto build failed")
        end if
        streamResult = sabr_streamViaUMP(sabrRequest, mediaIdHash, contentType, currentFormat, requestByteRange, itagKey, isInitRequest, playbackContext, sabr, logTag, requestNumber)
    end if
    redirectUrl = sabr_toSafeString(streamResult?.__redirectUrl)
    if redirectUrl <> ""
        streamResult.Delete("__redirectUrl")
        if redirectDepth >= 3
            sabr_log(m.logs, log_level_Type.WARN, `${logTag} Redirect limit reached for ${redirectUrl}`, false)
            return sabr_buildErrorResponseForPlayer(502, "redirect limit reached")
        end if
        sabr_log(m.logs, log_level_Type.INFO, `${logTag} Following SABR redirect to ${redirectUrl}`)
        sabr_savePlaybackContext(mediaIdHash, playbackContext)
        return sabr_handleRequest(request, contentType, mediaIdHash, sabr, videoNode, queuedAtMs, redirectDepth + 1)
    end if
    if not IsAssociativeArray(streamResult)
        return sabr_buildErrorResponseForPlayer(500, "SABR stream failed")
    end if

    response = sabr_buildResponseForPlayer({
        "byteRange": requestByteRange
    }, streamResult, currentFormat, requestByteRange, contentType)
    if servedFromCache = true
        response["servedFromInitCache"] = true
    end if
    sabr_debugDumpResponse(playbackContext, response, requestByteRange, contentType, currentFormat, logTag, requestNumber)

    sabr_savePlaybackContext(mediaIdHash, playbackContext)
    return response
end function

'------------------------------------------------------------------------------
' SABR request building
'------------------------------------------------------------------------------
function sabr_prepareProtoRequest(request as object, contentType as string, sabr as object, currentFormat as object, activeFormats as object, requestByteRange as object, playbackContext as object, videoNode as object, isInitRequest as boolean, logTag as string, requestNumber as string) as object
    payload = sabr_createVideoPlaybackAbrRequest(request, contentType, sabr, currentFormat, activeFormats, requestByteRange, playbackContext, 0, videoNode, 0, isInitRequest)
    if not IsAssociativeArray(payload) then return invalid

    sabr_debugDumpRequestPayload(playbackContext, payload, requestByteRange, contentType, currentFormat, logTag, requestNumber)

    encoded = VideoPlaybackAbrRequestEncode(payload)
    if not IsString(encoded) or encoded = "" then return invalid

    protoBytes = CreateObject("roByteArray")
    protoBytes.FromBase64String(encoded)
    protoPath = `${sabr_mediaDir(playbackContext.mediaIdHash)}/sabrRequest-${contentType}-${sabr_sanitizeForFilename(logTag)}.bin`
    protoBytes.WriteFile(protoPath)

    destPath = `${protoPath}-res`
    tap = sabr_createStreamTap({
        "destPath": destPath
        "keyParam": request.search.key
        "targetItag": sabr_toInt(currentFormat?.itag)
        "targetRangeStart": requestByteRange.startRange
        "targetRangeEnd": requestByteRange.endRange
        "isInitRequest": isInitRequest
        "contentType": contentType
        "mediaIdHash": playbackContext.mediaIdHash
    })

    optionsPayload = {
        "method": "POST_FILE_TO_FILE_WITH_DECODINGS"
        "body": protoPath
        "responseFilePath": destPath
    }
    if IsAssociativeArray(tap)
        optionsPayload["streamTap"] = tap
    end if

    return {
        "url": sabr.serverAbrStreamingUrl
        "requestType": "proxy"
        "timeout": 10000
        "options": optionsPayload
    }
end function

'------------------------------------------------------------------------------
' Stream SABR response and build player response object
'------------------------------------------------------------------------------
function sabr_streamViaUMP(sabrRequest as object, mediaIdHash as string, contentType as string, currentFormat as object, requestByteRange as object, keyParam as string, isInitRequest as boolean, playbackContext as object, sabr as object, logTag as string, requestNumber as string) as dynamic
    sabr_log(m.logs, log_level_Type.INFO, `${logTag} Performing proxied request`)
    protoCleanupPath = sabr_toSafeString(sabrRequest?.options?.body)
    res = makeRequest(sabrRequest)
    sabr_deleteFileIfExists(protoCleanupPath)
    if res?.status < 200 or res?.status > 206
        sabr_log(m.logs, log_level_Type.WARN, `${logTag} SABR request failed ${res?.status}`)
        return invalid
    end if

    spoolPath = sabr_toSafeString(res?.body)
    if spoolPath = "" and IsAssociativeArray(res?.streamTapResult)
        spoolPath = sabr_toSafeString(res.streamTapResult.path)
    end if
    if spoolPath = "" then return invalid

    streamTapResult = res?.streamTapResult
    controlEffects = invalid
    if IsAssociativeArray(streamTapResult)
        controlEffects = streamTapResult.Lookup("controlEffects")
    end if
    effectInfo = sabr_applyControlEffects(playbackContext, sabr, controlEffects, contentType, logTag)
    redirectUrl = sabr_toSafeString(effectInfo?.redirectUrl)

    tapEntry = sabr_extractSegmentEntryFromTap(streamTapResult, spoolPath)
    if not IsAssociativeArray(tapEntry)
        tapEntry = sabr_loadSegmentEntryFromSpool(playbackContext, spoolPath, requestByteRange, keyParam, logTag, contentType, currentFormat, requestNumber)
    end if
    if not IsAssociativeArray(tapEntry)
        sabr_log(m.logs, log_level_Type.WARN, `${logTag} No segment entry available for ${spoolPath}`)
        sabr_deleteFileIfExists(spoolPath)
        if redirectUrl <> ""
            return {
                "__redirectUrl": redirectUrl
            }
        end if
        return invalid
    end if

    response = sabr_buildStreamResponse(tapEntry, spoolPath, requestByteRange, isInitRequest)
    if not IsAssociativeArray(response)
        sabr_deleteFileIfExists(spoolPath)
        if redirectUrl <> ""
            return {
                "__redirectUrl": redirectUrl
            }
        end if
        return invalid
    end if

    if tapEntry?.isInitSeg = true
        sabr_materializeInitSegment(tapEntry, spoolPath, mediaIdHash, contentType, keyParam)
        sidxUpdate = tapEntry.Lookup("sidxIndex")
        if not IsAssociativeArray(sidxUpdate)
            sidxUpdate = sabr_ump_extractSidxFromSpool(spoolPath, tapEntry)
        end if
        if IsAssociativeArray(sidxUpdate)
            sabr_storeSidxIndexUpdate(playbackContext, contentType, currentFormat, sidxUpdate, tapEntry)
        end if
    end if

    if IsAssociativeArray(playbackContext)
        playbackContext["lastStartSegmentIndex"] = sabr_toInt(response.Lookup("sequenceIndex"))
    end if

    return response
end function

function sabr_createStreamTap(config as object) as dynamic
    if not IsAssociativeArray(config) then return invalid
    return sabr_ump_createStreamTap(config)
end function

function sabr_extractSegmentEntryFromTap(tapResult as dynamic, spoolPath as string) as dynamic
    if not IsAssociativeArray(tapResult) then return invalid
    entry = tapResult.Lookup("segmentEntry")
    if not IsAssociativeArray(entry) then return invalid
    entry["path"] = spoolPath
    return entry
end function

function sabr_loadSegmentEntryFromSpool(playbackContext as object, spoolPath as string, requestByteRange as object, keyParam as string, logTag as string, contentType as string, currentFormat as object, requestNumber as string) as dynamic
    spoolMap = sabr_ump_buildSpoolPartMap(spoolPath, 16, keyParam)
    if not IsAssociativeArray(spoolMap) then return invalid
    segment = sabr_selectSpoolSegmentFromMap(spoolMap, requestByteRange, keyParam)
    sabr_debugUploadSpool(playbackContext, requestNumber, contentType, currentFormat, requestByteRange, spoolMap)
    if not IsAssociativeArray(segment) then return invalid
    entry = segment.spooledSegment
    if not IsAssociativeArray(entry) then return invalid
    if IsAssociativeArray(playbackContext)
        playbackContext["lastStartSegmentIndex"] = sabr_toInt(entry?.mediaHeader?.sequenceNumber)
    end if
    entry["path"] = spoolPath
    return entry
end function

function sabr_buildStreamResponse(segmentEntry as object, spoolPath as string, requestByteRange as object, isInitRequest as boolean) as dynamic
    plan = sabr_planChunksForRequest(segmentEntry, requestByteRange, isInitRequest)
    if not IsAssociativeArray(plan) then return invalid

    coverage = sabr_byteRangeToCoverage(requestByteRange)
    if not IsAssociativeArray(coverage)
        coverage = {
            "rangeStart": sabr_toInt(segmentEntry?.startRange)
            "rangeEnd": sabr_toInt(segmentEntry?.endRange)
        }
    end if
    if plan.totalBytes > 0 and sabr_toInt(coverage?.rangeEnd) = invalid
        coverage["rangeEnd"] = sabr_toInt(coverage?.rangeStart) + plan.totalBytes - 1
    end if

    sequenceIndex = sabr_toInt(segmentEntry?.mediaHeader?.sequenceNumber)
    if sequenceIndex = invalid
        sequenceIndex = sabr_toInt(segmentEntry?.mediaHeader?.startSegmentIndex)
    end if

    response = {
        "path": spoolPath
        "chunks": plan.chunks
        "totalBytes": plan.totalBytes
        "coverage": coverage
        "sequenceIndex": sequenceIndex
        "cleanupPath": spoolPath
    }
    if segmentEntry?.isInitSeg = true
        response["isInitSeg"] = true
    end if
    return response
end function

function sabr_selectSpoolSegmentFromMap(spoolMap as object, requestByteRange as object, keyParam as string) as dynamic
    segmentIndex = spoolMap?.segmentIndex
    if not IsAssociativeArray(segmentIndex) then return invalid
    startTarget = sabr_toInt(requestByteRange?.startRange)
    endTarget = sabr_toInt(requestByteRange?.endRange)
    fallbackEntry = invalid
    fallbackKey = ""
    for each segKey in segmentIndex.Keys()
        entry = segmentIndex.Lookup(segKey)
        if not IsAssociativeArray(entry) then continue for
        entryStart = sabr_toInt(entry?.startRange)
        if entryStart = invalid and IsAssociativeArray(entry?.mediaHeader)
            entryStart = sabr_toInt(entry.mediaHeader?.startRange)
            if entryStart = invalid then entryStart = sabr_toInt(entry.mediaHeader?.start)
        end if
        entryEnd = sabr_toInt(entry?.endRange)
        if entryEnd = invalid and IsAssociativeArray(entry?.mediaHeader)
            contentLength = sabr_toInt(entry.mediaHeader?.contentLength)
            if entryStart <> invalid and contentLength <> invalid and contentLength > 0
                entryEnd = entryStart + contentLength - 1
            end if
        end if
        matchesRange = false
        if entryStart = startTarget and (endTarget = invalid or entryEnd = endTarget or (entryEnd <> invalid and endTarget <= entryEnd))
            matchesRange = true
        else if startTarget <> invalid and entryStart <> invalid and entryEnd <> invalid
            if startTarget >= entryStart and (endTarget = invalid or endTarget <= entryEnd)
                matchesRange = true
            end if
        end if
        if matchesRange
            return {
                "spooledSegment": entry
                "spoolKey": `${entryStart}:${sabr_toSafeString(keyParam)}`
            }
        end if
        if fallbackEntry = invalid
            fallbackEntry = entry
            fallbackKey = segKey
        end if
    end for
    if IsAssociativeArray(fallbackEntry)
        entryStart = sabr_toInt(fallbackEntry?.startRange)
        if entryStart = invalid
            entryStart = sabr_toInt(fallbackEntry?.mediaHeader?.startRange)
        end if
        spoolKey = fallbackKey <> "" ? fallbackKey : `${entryStart}:${sabr_toSafeString(keyParam)}`
        return {
            "spooledSegment": fallbackEntry
            "spoolKey": spoolKey
        }
    end if
    return invalid
end function

function sabr_planChunksForRequest(segmentEntry as object, requestByteRange as object, isInitRequest as boolean) as dynamic
    chunks = segmentEntry?.chunks
    if not IsArray(chunks) or chunks.count() = 0 then return invalid

    needsTrim = isInitRequest
    requestStartVal = sabr_toInt(requestByteRange?.startRange)
    requestEndVal = sabr_toInt(requestByteRange?.endRange)
    segmentStartVal = sabr_toInt(segmentEntry?.startRange)
    segmentEndVal = sabr_toInt(segmentEntry?.endRange)
    if needsTrim <> true
        if requestStartVal <> invalid and segmentStartVal <> invalid and requestStartVal > segmentStartVal
            needsTrim = true
        end if
        if requestEndVal <> invalid and segmentEndVal <> invalid and requestEndVal < segmentEndVal
            needsTrim = true
        end if
    end if

    if needsTrim and requestStartVal <> invalid and requestEndVal <> invalid
        trimmed = sabr_trimSegmentChunksForRange(chunks, segmentStartVal, requestByteRange)
        if IsAssociativeArray(trimmed) then return trimmed
    end if

    totalBytes = sabr_toInt(segmentEntry?.totalBytes)
    if totalBytes = invalid or totalBytes <= 0
        totalBytes = 0
        for each chunk in chunks
            lenVal = sabr_toInt(chunk?.length)
            if lenVal <> invalid then totalBytes = totalBytes + lenVal
        end for
    end if
    return {
        "chunks": chunks
        "totalBytes": totalBytes
    }
end function

function sabr_trimSegmentChunksForRange(chunks as object, segmentStart as dynamic, requestRange as object) as dynamic
    if not IsArray(chunks) then return invalid
    segmentStartVal = sabr_toInt(segmentStart)
    if segmentStartVal = invalid then return invalid
    requestStartVal = sabr_toInt(requestRange?.startRange)
    requestEndVal = sabr_toInt(requestRange?.endRange)
    if requestStartVal = invalid or requestEndVal = invalid then return invalid
    if requestEndVal < requestStartVal then return invalid

    offsetToSkip = requestStartVal - segmentStartVal
    if offsetToSkip < 0 then offsetToSkip = 0
    bytesNeeded = (requestEndVal - requestStartVal) + 1
    if bytesNeeded <= 0 then return invalid

    trimmedChunks = []
    remaining = bytesNeeded
    skip = offsetToSkip

    for each chunk in chunks
        chunkOffset = sabr_toInt(chunk?.offset)
        chunkLength = sabr_toInt(chunk?.length)
        if chunkOffset = invalid or chunkLength = invalid or chunkLength <= 0 then continue for

        if skip >= chunkLength
            skip = skip - chunkLength
            continue for
        end if

        effectiveOffset = chunkOffset + skip
        effectiveLength = chunkLength - skip
        if effectiveLength > remaining then effectiveLength = remaining

        if effectiveLength > 0
            trimmedChunks.push({
                "offset": effectiveOffset
                "length": effectiveLength
            })
            remaining = remaining - effectiveLength
        end if

        skip = 0
        if remaining <= 0 then exit for
    end for

    trimmedTotal = bytesNeeded - remaining
    if trimmedTotal <= 0 then return invalid

    return {
        "chunks": trimmedChunks
        "totalBytes": trimmedTotal
    }
end function

function sabr_byteRangeToCoverage(byteRange as object) as dynamic
    if not IsAssociativeArray(byteRange) then return invalid
    startLabel = `${byteRange?.startRange ?? byteRange?.start ?? ""}`
    endLabel = `${byteRange?.endRange ?? byteRange?.end ?? ""}`
    if startLabel = "" or endLabel = "" then return invalid
    startVal = sabr_toInt(startLabel)
    endVal = sabr_toInt(endLabel)
    if startVal = invalid or endVal = invalid or endVal < startVal then return invalid
    return {
        "rangeStart": startVal
        "rangeEnd": endVal
    }
end function

function sabr_getActiveFormats(currentFormat as object, sabr as object, playbackContext as object) as object
    formats = {
        "videoFormat": invalid
        "audioFormat": invalid
    }
    if IsAssociativeArray(currentFormat) and isValid(currentFormat?.width)
        formats.videoFormat = currentFormat
    else
        formats.audioFormat = currentFormat
    end if

    if not isValid(formats.videoFormat)
        formats.videoFormat = sabr_findFirstFormatOfType(sabr?.adaptiveFormats, true)
    end if
    if not isValid(formats.audioFormat)
        formats.audioFormat = sabr_findFirstFormatOfType(sabr?.adaptiveFormats, false)
    end if
    return formats
end function

function sabr_findFirstFormatOfType(formatList as object, wantsVideo as boolean) as dynamic
    if not IsArray(formatList) then return invalid
    for each fmt in formatList
        if wantsVideo and isValid(fmt?.width) then return fmt
        if not wantsVideo and not isValid(fmt?.width) then return fmt
    end for
    return invalid
end function

'------------------------------------------------------------------------------
' Playback context persistence
'------------------------------------------------------------------------------
function sabr_loadPlaybackContext(mediaIdHash as string) as object
    path = `${sabr_mediaDir(mediaIdHash)}/playbackContext.json`
    if not fileExists(path)
        ctx = {}
        ctx["mediaIdHash"] = mediaIdHash
        return ctx
    end if
    data = ParseJson(getFile(path))
    if not IsAssociativeArray(data)
        data = {}
        data["mediaIdHash"] = mediaIdHash
    else
        storedHash = sabr_toSafeString(data.Lookup("mediaIdHash"))
        if storedHash = ""
            data["mediaIdHash"] = mediaIdHash
        end if
        if data.DoesExist("sidxIndexByFormat")
            data.Delete("sidxIndexByFormat")
        end if
    end if
    return data
end function

sub sabr_savePlaybackContext(mediaIdHash as string, playbackContext as object)
    path = `${sabr_mediaDir(mediaIdHash)}/playbackContext.json`
    if IsAssociativeArray(playbackContext) and playbackContext.DoesExist("sidxIndexByFormat")
        playbackContext.Delete("sidxIndexByFormat")
    end if
    writeFile(path, FormatJson(playbackContext))
end sub

'------------------------------------------------------------------------------
' Request helpers
'------------------------------------------------------------------------------
function sabr_findFormatForKey(keyParam as string, sabr as object, contentType as string, logTag as string) as dynamic
    if not isValid(keyParam) or keyParam = "" return invalid
    parts = keyParam.Split(":")
    itag = sabr_toInt(parts[0])
    xTags = parts.count() > 1 ? parts[1] : ""
    candidates = sabr?.adaptiveFormats
    if not isValid(candidates) or candidates.count() = 0
        candidates = sabr?.hlsFormats
    end if
    if not IsArray(candidates) then return invalid
    for each format in candidates
        formatItag = sabr_toInt(format?.itag)
        formatXTags = sabr_toSafeString(format?.xTags)
        if formatItag = itag and formatXTags = xTags
            return format
        end if
    end for
    sabr_log(m.logs, log_level_Type.WARN, `${logTag} No matching format for ${keyParam}`, false)
    return invalid
end function

function sabr_getHeaderByteRange(request as object) as object
    startRange = "0"
    endRange = ""
    headerRange = ""
    if isValid(request?.headers?.Range)
        headerRange = request.headers.Range
    else if isValid(request?.headers?.range)
        headerRange = request.headers.range
    end if
    if headerRange <> ""
        pieces = headerRange.Split("=")
        if pieces.count() = 2
            setParts = pieces[1].Split("-")
            if setParts.count() = 2
                startRange = setParts[0]
                endRange = setParts[1]
            end if
        end if
    end if
    return {
        "startRange": startRange
        "endRange": endRange
    }
end function

function sabr_normalizeByteRange(byteRange as object, context = invalid as dynamic) as object
    startVal = sabr_toInt(byteRange?.startRange)
    endVal = sabr_toInt(byteRange?.endRange)
    if startVal = invalid then startVal = 0
    normalized = {
        "startRange": startVal
        "endRange": endVal
    }
    return normalized
end function

function sabr_isInit(contentType as string, format as object, requestByteRange as object, requestRef = invalid as dynamic) as boolean
    logTag = sabr_utilLogTag(contentType, requestRef)
    if sabr_rangesMatch(format?.initRange, requestByteRange)
        sabr_log(m.logs, log_level_Type.INFO, `${logTag} SABR format itag ${format.itag} init range requested: ${FormatJson(requestByteRange)}`)
        return true
    end if
    if sabr_rangesMatch(format?.indexRange, requestByteRange)
        sabr_log(m.logs, log_level_Type.INFO, `${logTag} SABR format itag ${format.itag} index range requested: ${FormatJson(requestByteRange)}`)
        return true
    end if
    return false
end function

function sabr_tryServeCachedInitSegment(playbackContext as object, mediaIdHash as string, contentType as string, keyParam as string, requestByteRange as object, isInitRequest as boolean, logTag = "" as string) as dynamic
    if not isInitRequest then return invalid
    path = sabr_computeInitSegmentPath(mediaIdHash, contentType, keyParam)
    fs = CreateObject("roFileSystem")
    if fs.Exists(path) <> true then return invalid
    rangeStart = sabr_toInt(requestByteRange?.startRange)
    if rangeStart = invalid or rangeStart < 0 then rangeStart = 0
    rangeEnd = sabr_toInt(requestByteRange?.endRange)
    fileStat = fs.Stat(path)
    totalSize = sabr_toInt(fileStat?.size)
    if rangeEnd = invalid or rangeEnd >= totalSize then rangeEnd = totalSize - 1
    if rangeEnd < rangeStart or totalSize <= 0 then return invalid
    length = (rangeEnd - rangeStart) + 1
    bytes = CreateObject("roByteArray")
    if bytes.ReadFile(path, rangeStart, length) <> true then return invalid
    if logTag <> ""
        rangeLabel = sabr_formatRequestedRangeForPath(requestByteRange)
        sabr_log(m.logs, log_level_Type.INFO, `${logTag} Serving init/index from cache path=${path} range=${rangeLabel}`)
    end if
    return {
        "data": bytes
        "totalBytes": length
        "coverage": {
            "rangeStart": rangeStart
            "rangeEnd": rangeEnd
        }
        "isInitSeg": true
        "path": path
    }
end function

function sabr_computeInitSegmentPath(mediaIdHash as string, contentType as string, keyParam as string) as string
    baseDir = sabr_mediaDir(mediaIdHash)
    typeLabel = sabr_sanitizeForFilename(LCase(sabr_toSafeString(contentType)))
    keyLabel = sabr_sanitizeForFilename(sabr_toSafeString(keyParam))
    if typeLabel = "" then typeLabel = "unknown"
    if keyLabel = "" then keyLabel = "nokey"
    return `${baseDir}/init-${typeLabel}-${keyLabel}.bin`
end function

sub sabr_materializeInitSegment(entry as object, spoolPath as string, mediaIdHash as string, contentType as string, keyParam as string)
    if not IsAssociativeArray(entry) then return
    targetPath = sabr_computeInitSegmentPath(mediaIdHash, contentType, keyParam)
    fs = CreateObject("roFileSystem")
    if fs.Exists(targetPath) then return
    chunkBytes = sabr_ump_readChunksFromSpool(spoolPath, entry?.chunks, sabr_toInt(entry?.totalBytes))
    if GetInterface(chunkBytes, "ifByteArray") = invalid or chunkBytes.count() = 0 then return
    chunkBytes.WriteFile(targetPath)
end sub

'------------------------------------------------------------------------------
' SABR proto + buffered ranges
'------------------------------------------------------------------------------
function sabr_createVideoPlaybackAbrRequest(request as object, contentType as string, sabr as object, currentFormat as object, activeFormats as object, requestByteRange as object, playbackContext as object, playerTimeOverride as dynamic, videoNode as object, requestRef = invalid as dynamic, isInitRequest = false as boolean) as object
    logTag = sabr_utilLogTag(contentType, requestRef)
    if not isValid(sabr?.ustreamerConfig) then return {}

    streamerContext = {
        "poToken": sabr.poToken
        "clientInfo": sabr.clientInfo
        "sabrContexts": []
        "unsentSabrContexts": []
    }
    if isValid(playbackContext?.lastPlaybackCookie)
        streamerContext["playbackCookie"] = playbackContext.lastPlaybackCookie
    end if

    bandwidthEstimate = sabr_pickMeasuredBitrate(videoNode?.completedStreamInfo)
    if bandwidthEstimate = invalid
        bandwidthEstimate = sabr_pickMeasuredBitrate(videoNode?.streamInfo)
    end if
    if bandwidthEstimate = invalid then bandwidthEstimate = sabr_toInt(currentFormat?.bitrate)
    if bandwidthEstimate = invalid or bandwidthEstimate <= 0 then bandwidthEstimate = 2000000

    rangePlayerInfo = sabr_resolvePlayerTimeFromRequest(playbackContext, contentType, currentFormat, requestByteRange)

    desiredPlayerTimeMs = sabr_toInt(rangePlayerInfo?.playerTimeMs)
    if desiredPlayerTimeMs = invalid or desiredPlayerTimeMs < 0
        desiredPlayerTimeMs = 0
    end if
    previousPlayerTimeMs = sabr_toInt(playbackContext.Lookup("lastRequestedPlayerTimeMs"))
    seekBackActive = sabr_detectSeekBack(previousPlayerTimeMs, desiredPlayerTimeMs)
    playbackContext["lastRequestedPlayerTimeMs"] = desiredPlayerTimeMs
    seqIdxDebug = sabr_toInt(rangePlayerInfo?.sequenceIndex)
    if seqIdxDebug <> invalid then playbackContext["lastStartSegmentIndex"] = seqIdxDebug
    playbackContext["lastPlayerTimeMs"] = desiredPlayerTimeMs

    AUDIO_ONLY = 1
    VIDEO_ONLY = 2

    req = {
        "clientAbrState": {
            "playbackRate": videoNode?.playbackSpeed ?? 1.0
            "playerTimeMs": desiredPlayerTimeMs.toStr()
            "clientViewportIsFlexible": false
            "bandwidthEstimate": bandwidthEstimate.toStr()
            "drcEnabled": currentFormat?.isDrc ?? false
            "enabledTrackTypesBitfield": isValid(currentFormat?.width) ? VIDEO_ONLY : AUDIO_ONLY
            "audioTrackId": currentFormat?.audioTrackId
        }
        "bufferedRanges": []
        "selectedFormatIds": []
        "preferredAudioFormatIds": []
        "preferredVideoFormatIds": []
        "preferredSubtitleFormatIds": []
        "videoPlaybackUstreamerConfig": sabr.ustreamerConfig
        "streamerContext": streamerContext
        "field1000": []
    }

    bufferedRanges = sabr_buildBufferedRanges(playbackContext, activeFormats, contentType, currentFormat, requestByteRange, desiredPlayerTimeMs, seekBackActive, isInitRequest, rangePlayerInfo)
    for each br in bufferedRanges
        req.bufferedRanges.push(br)
    end for

    if isInitRequest <> true
        sabr_pushFormatIfMissing(req.selectedFormatIds, currentFormat)
    end if
    if IsAssociativeArray(activeFormats?.audioFormat)
        req.preferredAudioFormatIds.push(activeFormats.audioFormat)
        if isInitRequest <> true or not sabr_formatsEqual(activeFormats.audioFormat, currentFormat)
            sabr_pushFormatIfMissing(req.selectedFormatIds, activeFormats.audioFormat)
        end if
    end if
    if IsAssociativeArray(activeFormats?.videoFormat)
        req.preferredVideoFormatIds.push(activeFormats.videoFormat)
        if isInitRequest <> true or not sabr_formatsEqual(activeFormats.videoFormat, currentFormat)
            sabr_pushFormatIfMissing(req.selectedFormatIds, activeFormats.videoFormat)
        end if
    end if
    return req
end function

function sabr_buildBufferedRanges(playbackContext as object, activeFormats as object, contentType as string, currentFormat as object, requestByteRange as object, playerTimeMs as dynamic, seekBackActive as boolean, isInitRequest as boolean, rangeInfo = invalid as dynamic) as object
    ranges = []
    if not IsAssociativeArray(playbackContext) then playbackContext = {}

    if seekBackActive <> true and isInitRequest <> true
        previousRange = sabr_buildBufferedRangeFromSidx(playbackContext, contentType, currentFormat, playerTimeMs, rangeInfo)
        if IsAssociativeArray(previousRange) then ranges.push(previousRange)
    end if

    sentinelFormat = sabr_pickSentinelFormat(activeFormats, playbackContext, contentType)
    if IsAssociativeArray(sentinelFormat)
        ranges.push(sabr_createFullBufferRange(sentinelFormat))
    end if
    return ranges
end function

function sabr_pickSentinelFormat(activeFormats as object, playbackContext as object, contentType as string) as dynamic
    sentinelType = UCase(contentType) = "AUDIO" ? "VIDEO" : "AUDIO"
    if sentinelType = "AUDIO"
        candidate = activeFormats?.audioFormat
    else
        candidate = activeFormats?.videoFormat
    end if
    if not isValid(candidate)
        candidate = sabr_pickBestFormat(playbackContext, sentinelType)
    end if
    if isValid(candidate) then return candidate
    return {
        "itag": sentinelType = "AUDIO" ? -100 : -200
        "xtags": "sentinel"
        "contentType": LCase(sentinelType)
    }
end function

function sabr_pickBestFormat(playbackContext as object, formatType as string) as dynamic
    if not IsAssociativeArray(playbackContext) then return invalid
    history = playbackContext.Lookup("recentSegments")
    if not IsAssociativeArray(history) then return invalid
    for each key in history
        parts = key.Split("|")
        if parts.count() = 2 and parts[0] = UCase(formatType)
            current = history[key]?.current
            if IsAssociativeArray(current) and IsAssociativeArray(current?.format)
                return current.format
            end if
        end if
    end for
    return invalid
end function

function sabr_resolvePlayerTimeFromRequest(playbackContext as object, contentType as string, currentFormat as object, requestByteRange as object) as dynamic
    entriesInfo = sabr_lookupSidxEntries(playbackContext, contentType, currentFormat)
    entries = entriesInfo?.entries
    if not IsArray(entries) or entries.count() = 0 then return invalid

    requestStart = sabr_toInt(requestByteRange?.startRange)
    if requestStart = invalid then return invalid

    matchedIndex = -1
    matchedEntry = invalid

    totalEntries = entries.count()
    for idx = 0 to totalEntries - 1
        entry = entries[idx]
        if not IsAssociativeArray(entry) then continue for
        rangeStart = sabr_toInt(entry?.rangeStart)
        rangeEnd = sabr_toInt(entry?.rangeEnd)
        if rangeStart = invalid or rangeEnd = invalid then continue for

        if requestStart >= rangeStart and requestStart <= rangeEnd
            matchedEntry = entry
            matchedIndex = idx
            exit for
        end if

        if requestStart > rangeEnd
            matchedEntry = entry
            matchedIndex = idx
        else if requestStart < rangeStart and matchedEntry = invalid
            matchedEntry = entry
            matchedIndex = idx
            exit for
        end if
    end for

    if not IsAssociativeArray(matchedEntry) then return invalid

    playerTimeMs = sabr_toInt(matchedEntry?.startTimeMs)
    if playerTimeMs = invalid then playerTimeMs = 0

    info = {
        "playerTimeMs": playerTimeMs
        "sequenceIndex": sabr_toInt(matchedEntry?.sequenceIndex)
    }
    return info
end function

function sabr_detectSeekBack(previousPlayerTimeMs as dynamic, currentPlayerTimeMs as dynamic) as boolean
    currentVal = sabr_toInt(currentPlayerTimeMs)
    previousVal = sabr_toInt(previousPlayerTimeMs)
    if currentVal = invalid or currentVal < 0 then return false
    if previousVal = invalid or previousVal < 0 then return false
    toleranceMs = 750
    return currentVal + toleranceMs < previousVal
end function

function sabr_formatKey(format as dynamic) as string
    if not IsAssociativeArray(format) then return ""
    itagLabel = sabr_toSafeString(format?.itag)
    xtagLabel = sabr_toSafeString(format?.xTags)
    if xtagLabel = "" then xtagLabel = sabr_toSafeString(format?.xtags)
    if itagLabel = "" and xtagLabel = "" then return ""
    if itagLabel = "" then return xtagLabel
    if xtagLabel = "" then return `${itagLabel}:`
    return `${itagLabel}:${xtagLabel}`
end function

function sabr_formatsEqual(left as dynamic, right as dynamic) as boolean
    return sabr_formatKey(left) = sabr_formatKey(right)
end function

sub sabr_pushFormatIfMissing(targetList as object, format as object)
    if not IsArray(targetList) then return
    if not IsAssociativeArray(format) then return
    newKey = sabr_formatKey(format)
    if newKey = "" then newKey = `${sabr_toSafeString(format?.itag)}:${sabr_toSafeString(format?.xTags)}`
    for each existing in targetList
        if sabr_formatKey(existing) = newKey
            return
        end if
    end for
    targetList.push(format)
end sub

function sabr_sidxIndexKey(contentType as string, format as object, overrideKey = "" as string) as string
    typeLabel = UCase(sabr_toSafeString(contentType))
    if typeLabel = "" then typeLabel = "UNKNOWN"
    formatKey = overrideKey
    if formatKey = "" then formatKey = sabr_formatKey(format)
    if formatKey = "" then formatKey = "default"
    return `${typeLabel}|${formatKey}`
end function

function sabr_sidxCacheKeyForType(contentType as string) as string
    label = UCase(sabr_toSafeString(contentType))
    if label = "" then label = "UNKNOWN"
    return label
end function

function sabr_sidxCacheRoot() as object
    globalAA = GetGlobalAA()
    cache = globalAA.Lookup("sabrSidxCache")
    if not IsAssociativeArray(cache)
        cache = {}
        globalAA["sabrSidxCache"] = cache
    end if
    return cache
end function

sub sabr_sidxCacheStore(contentType as string, indexKey as string, info as object)
    cache = sabr_sidxCacheRoot()
    typeKey = sabr_sidxCacheKeyForType(contentType)
    if not IsAssociativeArray(info)
        cache.Delete(typeKey)
        return
    end if
    cache[typeKey] = {
        "key": indexKey
        "info": info
    }
end sub

function sabr_sidxCacheLookup(contentType as string, indexKey as string) as dynamic
    cache = sabr_sidxCacheRoot()
    typeKey = sabr_sidxCacheKeyForType(contentType)
    entry = cache.Lookup(typeKey)
    if not IsAssociativeArray(entry) then return invalid
    cachedKey = sabr_toSafeString(entry.Lookup("key"))
    if cachedKey = "" or (indexKey <> "" and cachedKey <> indexKey) then return invalid
    info = entry.Lookup("info")
    if IsAssociativeArray(info) then return info
    return invalid
end function

function sabr_reloadSidxEntriesFromInit(playbackContext as object, contentType as string, format as object, indexKey as string) as dynamic
    if not IsAssociativeArray(playbackContext) then return invalid
    if not IsAssociativeArray(format) then return invalid
    mediaIdHash = sabr_toSafeString(playbackContext.Lookup("mediaIdHash"))
    if mediaIdHash = "" then return invalid
    formatKey = sabr_formatKey(format)
    if formatKey = "" then return invalid
    initPath = sabr_computeInitSegmentPath(mediaIdHash, contentType, formatKey)
    fs = CreateObject("roFileSystem")
    if fs.Exists(initPath) <> true then return invalid
    stat = fs.Stat(initPath)
    fileSize = sabr_toInt(stat?.size)
    if fileSize = invalid or fileSize <= 0 then return invalid

    bytes = CreateObject("roByteArray")
    if bytes.ReadFile(initPath, 0, fileSize) <> true then return invalid

    formatInfo = sabr_formatToFormatId(format)
    if IsAssociativeArray(formatInfo)
        formatInfo["contentType"] = LCase(sabr_toSafeString(contentType))
    end if
    itagValue = sabr_toInt(format?.itag)
    xtagValue = sabr_toSafeString(format?.xtags)
    if xtagValue = "" then xtagValue = sabr_toSafeString(format?.xTags)
    mediaHeader = {
        "contentType": LCase(sabr_toSafeString(contentType))
        "formatId": formatInfo
        "format": {
            "itag": itagValue
            "xtags": xtagValue
            "contentType": LCase(sabr_toSafeString(contentType))
        }
        "itag": itagValue
        "xtags": xtagValue
        "startSegmentIndex": 0
    }
    update = sabr_ump_buildSidxIndexUpdate(invalid, mediaHeader, bytes)
    if not IsAssociativeArray(update) then return invalid

    fakeSegmentEntry = {
        "mediaHeader": {
            "startSegmentIndex": 0
        }
    }
    sabr_storeSidxIndexUpdate(playbackContext, contentType, format, update, fakeSegmentEntry)
    return sabr_sidxCacheLookup(contentType, indexKey)
end function

sub sabr_storeSidxIndexUpdate(playbackContext as object, contentType as string, currentFormat as object, update as object, segmentEntry as object)
    if not IsAssociativeArray(playbackContext) then return
    if not IsAssociativeArray(update) then return
    entries = update?.entries
    if not IsArray(entries) or entries.count() = 0 then return

    formatKey = sabr_toSafeString(update?.formatKey)
    if formatKey = "" and IsAssociativeArray(segmentEntry?.mediaHeader?.formatId)
        formatKey = sabr_formatKey(segmentEntry.mediaHeader.formatId)
    end if
    if formatKey = "" and IsAssociativeArray(segmentEntry?.mediaHeader)
        formatKey = sabr_formatKey(segmentEntry.mediaHeader)
    end if
    key = sabr_sidxIndexKey(contentType, currentFormat, formatKey)

    sequenceBase = sabr_toInt(segmentEntry?.mediaHeader?.startSegmentIndex)
    if sequenceBase = invalid then sequenceBase = 0

    normalizedEntries = []
    idx = 0
    for each entry in entries
        if not IsAssociativeArray(entry) then
            idx = idx + 1
            continue for
        end if
        rangeStart = sabr_toInt(entry?.rangeStart)
        rangeEnd = sabr_toInt(entry?.rangeEnd)
        if rangeStart = invalid or rangeEnd = invalid
            idx = idx + 1
            continue for
        end if
        durationMs = sabr_toInt(entry?.durationMs)
        startTimeMs = sabr_toInt(entry?.startTimeMs)
        normalizedEntries.push({
            "rangeStart": rangeStart
            "rangeEnd": rangeEnd
            "durationMs": durationMs
            "startTimeMs": startTimeMs
            "sequenceIndex": sequenceBase + idx
        })
        idx = idx + 1
    end for
    if normalizedEntries.count() = 0 then return

    cacheInfo = {
        "entries": normalizedEntries
        "sequenceBase": sequenceBase
    }
    sabr_sidxCacheStore(contentType, key, cacheInfo)
end sub

function sabr_lookupSidxEntries(playbackContext as object, contentType as string, format as object) as dynamic
    key = sabr_sidxIndexKey(contentType, format)
    cached = sabr_sidxCacheLookup(contentType, key)
    if IsAssociativeArray(cached) then return cached
    return sabr_reloadSidxEntriesFromInit(playbackContext, contentType, format, key)
end function

function sabr_buildBufferedRangeFromSidx(playbackContext as object, contentType as string, format as object, playerTimeMs as dynamic, rangeInfo = invalid as dynamic) as dynamic
    entriesInfo = sabr_lookupSidxEntries(playbackContext, contentType, format)
    entries = entriesInfo?.entries
    if not IsArray(entries) or entries.count() = 0 then return invalid

    sequenceIndex = invalid
    if IsAssociativeArray(rangeInfo)
        sequenceIndex = sabr_toInt(rangeInfo.Lookup("sequenceIndex"))
    end if

    previousEntry = invalid
    if sequenceIndex = invalid then return invalid
    sequenceBase = sabr_toInt(entriesInfo?.sequenceBase)
    if sequenceBase = invalid then sequenceBase = 0
    priorSequence = sequenceIndex - 1
    if priorSequence < sequenceBase then return invalid

    candidateIndex = priorSequence - sequenceBase
    if candidateIndex < 0 or candidateIndex >= entries.count() then return invalid
    candidate = entries[candidateIndex]
    if not IsAssociativeArray(candidate) then return invalid
    previousEntry = candidate

    if not IsAssociativeArray(previousEntry) then return invalid

    rangeStart = sabr_toInt(previousEntry?.rangeStart)
    rangeEnd = sabr_toInt(previousEntry?.rangeEnd)
    if rangeStart = invalid or rangeEnd = invalid then return invalid
    seqIndex = sabr_toInt(previousEntry?.sequenceIndex)
    if seqIndex = invalid then seqIndex = 0
    seqIndex1 = seqIndex + 1
    if seqIndex1 < 1 then seqIndex1 = 1
    durationMs = sabr_toInt(previousEntry?.durationMs)
    if durationMs = invalid then durationMs = 0
    startMs = sabr_toInt(previousEntry?.startTimeMs)
    if startMs = invalid then startMs = 0

    return {
        "rangeStart": rangeStart
        "rangeEnd": rangeEnd
        "formatId": sabr_formatToFormatId(format)
        "startSegmentIndex": seqIndex1
        "endSegmentIndex": seqIndex1
        "durationMs": durationMs
        "timeRange": {
            "timescale": 1000
            "startTicks": `${startMs}`
            "durationTicks": durationMs
        }
    }
end function

function sabr_applyControlEffects(playbackContext as object, sabr as object, controlEffects as object, contentType as string, logTag as string) as dynamic
    info = {}
    if not IsAssociativeArray(controlEffects) then return info

    if IsAssociativeArray(playbackContext) <> true
        playbackContext = {}
    end if

    if IsAssociativeArray(controlEffects.nextRequestPolicy)
        playbackContext["nextRequestPolicy"] = controlEffects.nextRequestPolicy
        cookieProto = controlEffects.nextRequestPolicy?.playbackCookie
        if isValid(cookieProto)
            playbackContext["lastPlaybackCookie"] = cookieProto
        end if
    end if

    if IsAssociativeArray(controlEffects.sabrContextUpdate)
        playbackContext["lastSabrContextUpdate"] = controlEffects.sabrContextUpdate
    end if

    if IsAssociativeArray(controlEffects.redirect)
        redirectUrl = sabr_toSafeString(controlEffects.redirect?.url)
        if redirectUrl = "" then redirectUrl = sabr_toSafeString(controlEffects.redirect?.endpoint)
        if sabr_updateServerRedirect(playbackContext, sabr, redirectUrl, logTag)
            info["redirectUrl"] = redirectUrl
        end if
    end if

    if IsAssociativeArray(controlEffects.reloadPlaybackContext)
        playbackContext["lastReloadPlaybackContext"] = controlEffects.reloadPlaybackContext
        reloadInfo = sabr_handleReloadPlaybackContext(playbackContext, sabr, controlEffects.reloadPlaybackContext, logTag)
        if IsAssociativeArray(reloadInfo) and reloadInfo.Count() > 0
            info["reloadPlaybackContextResult"] = reloadInfo
        end if
    end if

    return info
end function

function sabr_pickMeasuredBitrate(info as object) as dynamic
    if not IsAssociativeArray(info) then return invalid
    bitrate = sabr_toInt(info?.bitrateMeasuredBps)
    if bitrate = invalid or bitrate <= 0
        bitrate = sabr_toInt(info?.bitrateTargetBps)
    end if
    return bitrate
end function

function sabr_createFullBufferRange(format as object) as object
    MAX_INT32_VALUE = 2147483647
    return {
        "formatId": sabr_formatToFormatId(format)
        "durationMs": MAX_INT32_VALUE
        "startTimeMs": "0"
        "startSegmentIndex": MAX_INT32_VALUE
        "endSegmentIndex": MAX_INT32_VALUE
        "timeRange": {
            "timescale": 1000
            "startTicks": "0"
            "durationTicks": MAX_INT32_VALUE
        }
    }
end function

function sabr_handleReloadPlaybackContext(playbackContext as object, sabr as object, reloadContext as object, logTag as string) as dynamic
    if not IsAssociativeArray(reloadContext) then return invalid
    updates = {}

    newConfig = reloadContext.Lookup("ustreamerConfig")
    if isValid(newConfig)
        updates["ustreamerConfig"] = newConfig
        if isValid(sabr) then sabr.ustreamerConfig = newConfig
        if IsAssociativeArray(playbackContext) then playbackContext["ustreamerConfig"] = newConfig
    end if

    serverUrl = sabr_toSafeString(reloadContext.Lookup("serverAbrStreamingUrl"))
    if serverUrl = "" and IsAssociativeArray(reloadContext?.serverAbrStreamingEndpoint)
        serverUrl = sabr_toSafeString(reloadContext.serverAbrStreamingEndpoint.Lookup("url"))
    end if
    if serverUrl <> ""
        updates["serverAbrStreamingUrl"] = serverUrl
        sabr_updateServerRedirect(playbackContext, sabr, serverUrl, logTag)
    end if

    if updates.Count() > 0 and isValid(m?.logs)
        sabr_log(m.logs, log_level_Type.INFO, `${logTag} Applied reload playback updates ${FormatJson(updates)}`)
    end if
    return updates
end function

function sabr_updateServerRedirect(playbackContext as object, sabr as object, redirectUrl as string, logTag as string) as boolean
    target = sabr_toSafeString(redirectUrl)
    if target = "" then return false
    if isValid(sabr)
        sabr.serverAbrStreamingUrl = target
    end if
    if IsAssociativeArray(playbackContext)
        playbackContext["serverAbrStreamingUrl"] = target
    end if
    sabr_log(m.logs, log_level_Type.INFO, `${logTag} Updated SABR server URL via redirect: ${target}`)
    return true
end function

'------------------------------------------------------------------------------
' Response helpers
'------------------------------------------------------------------------------
function sabr_buildResponseForPlayer(requestMetadata as object, umpResult as dynamic, currentFormat as object, requestByteRange as object, contentType as string) as object
    headers = CreateObject("roAssociativeArray")
    mimeType = currentFormat?.mimeType
    if not isValid(mimeType) or mimeType = ""
        mimeType = LCase(contentType) = "audio" ? "audio/mp4" : "video/mp4"
    end if
    headers["Content-Type"] = mimeType
    headers["Accept-Ranges"] = "bytes"

    chunkPlan = umpResult?.chunks
    chunkPath = sabr_toSafeString(umpResult?.path)
    if IsArray(chunkPlan) and chunkPath <> ""
        totalBytes = sabr_toInt(umpResult?.totalBytes)
        if totalBytes = invalid or totalBytes <= 0
            totalBytes = 0
            for each chunkEntry in chunkPlan
                lenVal = sabr_toInt(chunkEntry?.length)
                if lenVal <> invalid then totalBytes = totalBytes + lenVal
            end for
        end if

        coverage = umpResult?.coverage
        coverageStart = sabr_toInt(coverage?.rangeStart)
        coverageEnd = sabr_toInt(coverage?.rangeEnd)
        if coverageStart = invalid then coverageStart = sabr_toInt(requestByteRange?.startRange)
        if coverageEnd = invalid and totalBytes > 0
            coverageEnd = coverageStart + totalBytes - 1
        end if
        headers["Content-Length"] = totalBytes.toStr()
        headers["Content-Range"] = `bytes ${coverageStart}-${coverageEnd}/${coverageEnd + 1}`

        response = {
            "status": 206
            "headers": headers
            "path": chunkPath
            "chunks": chunkPlan
            "totalBytes": totalBytes
        }
        if IsAssociativeArray(umpResult?.coverage)
            response["coverage"] = umpResult.coverage
        end if
        if umpResult?.isInitSeg = true
            response["isInitSeg"] = true
        end if
        cleanupPath = sabr_toSafeString(umpResult?.cleanupPath)
        if cleanupPath <> ""
            response["cleanupPath"] = cleanupPath
        end if
        return response
    end if

    dataBlob = umpResult?.data
    if GetInterface(dataBlob, "ifByteArray") <> invalid and dataBlob.count() > 0
        coverage = umpResult?.coverage
        coverageStart = sabr_toInt(coverage?.rangeStart)
        coverageEnd = sabr_toInt(coverage?.rangeEnd)
        if coverageStart = invalid then coverageStart = sabr_toInt(requestByteRange?.startRange)
        if coverageEnd = invalid
            coverageEnd = coverageStart + dataBlob.count() - 1
        end if
        headers["Content-Length"] = dataBlob.count().toStr()
        headers["Content-Range"] = `bytes ${coverageStart}-${coverageEnd}/${coverageEnd + 1}`
        response = {
            "status": 206
            "headers": headers
            "data": dataBlob
            "coverage": {
                "rangeStart": coverageStart
                "rangeEnd": coverageEnd
            }
        }
        if umpResult?.isInitSeg = true
            response["isInitSeg"] = true
        end if
        return response
    end if

    return sabr_buildErrorResponseForPlayer(500, "empty body")
end function

function sabr_buildErrorResponseForPlayer(status as integer, message as string) as object
    return {
        "status": status
        "headers": {
            "Content-Type": "text/plain"
            "Content-Length": len(message).toStr()
        }
        "body": message
    }
end function

sub sabr_debugUploadSpool(playbackContext as object, requestNumber as string, contentType as string, currentFormat as object, requestByteRange as object, spoolMap as object)
    debugUploadUrl = m.top?.debugUploadUrl
    if debugUploadUrl = "" then return
    try
        label = sabr_debugBuildDumpLabel(playbackContext, "sabr-request", requestNumber, sabr_formatRequestedRangeForPath(requestByteRange), contentType, currentFormat, invalid)
        sabr_debugUploadText(debugUploadUrl, `${LCase(contentType)}/${label}-spool.json`, FormatJson(spoolMap), m.logs)
    catch e
        ' swallow debug upload failures
    end try
end sub

sub sabr_debugDumpRequestPayload(playbackContext as object, payload as object, requestByteRange as object, contentType as string, currentFormat as object, logTag as string, requestNumber as string)
    debugUploadUrl = m.top?.debugUploadUrl
    if debugUploadUrl = "" then return
    if not IsAssociativeArray(payload) then return
    rangeLabel = sabr_formatRequestedRangeForPath(requestByteRange)
    label = sabr_debugBuildDumpLabel(playbackContext, "abr-request", requestNumber, rangeLabel, contentType, currentFormat, invalid)
    try
        serialized = FormatJson(payload)
        if serialized <> ""
            sabr_debugUploadText(debugUploadUrl, `${LCase(contentType)}/${label}.json`, serialized, m.logs)
        end if
    catch e
        sabr_log(m.logs, log_level_Type.WARN, `${logTag} Failed to serialize SABR request payload`, false)
    end try
end sub

sub sabr_debugDumpResponse(playbackContext as object, response as object, requestByteRange as object, contentType as string, currentFormat as object, logTag as string, requestNumber as string)
    debugUploadUrl = m.top?.debugUploadUrl
    if debugUploadUrl = "" then return
    if not IsAssociativeArray(response) then return
    chunks = response.Lookup("chunks")
    bytes = invalid
    if IsArray(chunks) and chunks.count() > 0
        spoolPath = sabr_toSafeString(response?.path)
        if spoolPath = "" then return
        totalBytes = sabr_toInt(response?.totalBytes)
        bytes = sabr_ump_readChunksFromSpool(spoolPath, chunks, totalBytes)
    else
        bytes = response.Lookup("data")
    end if
    if GetInterface(bytes, "ifByteArray") = invalid or bytes.count() = 0 then return

    sabr_debugValidateMp4Bytes(bytes, logTag, contentType)

    rangeLabel = sabr_formatRequestedRangeForPath(requestByteRange)
    if rangeLabel = "" and IsAssociativeArray(response?.coverage)
        coverageRange = {
            "startRange": response.coverage.Lookup("rangeStart")
            "endRange": response.coverage.Lookup("rangeEnd")
        }
        rangeLabel = sabr_formatRequestedRangeForPath(coverageRange)
    end if

    label = sabr_debugBuildDumpLabel(playbackContext, "player-response", requestNumber, rangeLabel, contentType, currentFormat, invalid)
    relativePath = `${LCase(contentType)}/${label}.bin`
    sabr_debugUploadBytes(debugUploadUrl, relativePath, bytes, m.logs)
end sub

sub sabr_debugValidateMp4Bytes(bytes as object, logTag as string, contentType as string)
    boxes = sabr_mp4_parseBoxes(bytes, 8)
    if not IsArray(boxes) or boxes.count() = 0
        sabr_log(m.logs, log_level_Type.WARN, `${logTag} ${contentType} unable to parse MP4 boxes for debug dump`, false)
        return
    end if
    summary = []
    for each boxInfo in boxes
        boxType = sabr_toSafeString(boxInfo?.type)
        boxSize = sabr_toInt(boxInfo?.size)
        summary.push(`${boxType}:${boxSize}`)
    end for
    sabr_log(m.logs, log_level_Type.INFO, `${logTag} ${contentType} MP4 boxes ${summary.Join(" ")}`)
end sub

sub sabr_deleteFileIfExists(path as dynamic)
    if not IsString(path) or path = "" then return
    fs = CreateObject("roFileSystem")
    if fs.Exists(path)
        fs.Delete(path)
    end if
end sub

function fileExists(path as dynamic) as boolean
    if not IsString(path) or path = "" then return false
    fs = CreateObject("roFileSystem")
    return fs.Exists(path)
end function

function sabr_rangesMatch(rangeObj as dynamic, requestRange as object) as boolean
    if not isValid(rangeObj) then return false
    expectedStart = `${rangeObj?.start ?? rangeObj?.startRange ?? ""}`
    expectedEnd = `${rangeObj?.end ?? rangeObj?.endRange ?? ""}`
    requestStart = `${requestRange?.startRange ?? requestRange?.start ?? ""}`
    requestEnd = `${requestRange?.endRange ?? requestRange?.end ?? ""}`
    if expectedStart = "" or expectedEnd = "" or requestStart = "" or requestEnd = "" then return false
    return expectedStart = requestStart and expectedEnd = requestEnd
end function

function sabr_utilLogTag(contentType as string, requestRef = invalid as dynamic) as string
    typeLabel = sabr_toSafeString(contentType)
    if typeLabel = "" then typeLabel = "UNKNOWN"
    refLabel = ""
    if requestRef <> invalid
        refLabel = sabr_toSafeString(requestRef)
    end if
    if refLabel = ""
        return `[YTSABR-${typeLabel}]`
    end if
    return `[YTSABR-${typeLabel}-${refLabel}]`
end function

function sabr_nextRequestId(playbackContext as object) as string
    globalAA = GetGlobalAA()
    seq = sabr_toInt(globalAA.Lookup("sabrGlobalRequestSequence"))
    if seq = invalid or seq < 0 then seq = 0
    seq = seq + 1
    globalAA["sabrGlobalRequestSequence"] = seq
    if IsAssociativeArray(playbackContext)
        playbackContext["requestSequence"] = seq
    end if
    return seq.toStr()
end function
