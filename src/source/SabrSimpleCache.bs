' Simple filesystem-based cache helpers for SABR segments.

const SABR_CACHE_BASE_DIR = "tmp:/sabr-cache"
const SABR_CACHE_LOG_SAMPLE = 100
const MAX_SABR_CACHE_SEGMENT_AGE_MS = 60 * 1000
const SABR_CACHE_DELIVERED_SEQUENCE_GUARD = 3
const SABR_CACHE_DELIVERED_RANGE_GUARD = 200000
const SABR_CACHE_DELIVERED_MIN_AGE_MS = 1500
const SABR_CACHE_PENDING_SEQUENCE_DISTANCE = 4
const SABR_CACHE_PENDING_RANGE_DISTANCE = 400000
const SABR_CACHE_PENDING_PLAYER_TIME_MS = 15 * 1000

sub sabrCacheSetLogger(logs as dynamic)
    m.sabrCacheLogger = logs
end sub

function sabrCacheLogger() as dynamic
    return m?.sabrCacheLogger
end function

sub sabrCacheLog(level as integer, message as string)
    logs = sabrCacheLogger()
    if GetInterface(logs, "ifAssociativeArray") <> invalid
        logs.printl(level, message)
    end if
end sub

function sabrCacheCurrentTimestampMs() as integer
    dt = CreateObject("roDateTime")
    if GetInterface(dt, "ifDateTime") = invalid then return 0
    return (dt.AsSeconds() * 1000) + dt.GetMilliseconds()
end function

function sabrCacheNormalizeNumber(value as dynamic) as dynamic
    if IsInteger(value)
        return value
    else if IsFloat(value) or IsDouble(value)
        return Int(value)
    else if IsString(value)
        parsed = Val(value)
        if IsInteger(parsed) or IsFloat(parsed) or IsDouble(parsed)
            return Int(parsed)
        end if
        return parsed
    end if
    return invalid
end function

function sabrCacheEnsureBasePath() as string
    fs = CreateObject("roFileSystem")
    if not fs.Exists(SABR_CACHE_BASE_DIR)
        success = fs.CreateDirectory(SABR_CACHE_BASE_DIR)
        logObj = sabrCacheLogger()
        if success <> true and GetInterface(logObj, "ifAssociativeArray") <> invalid
            logObj.printl(log_level_Type.WARN, `[SabrCache] Failed to create cache directory ${SABR_CACHE_BASE_DIR}`)
        end if
    end if
    return SABR_CACHE_BASE_DIR
end function

function sabrCacheSanitize(value as dynamic) as string
    if not isValid(value) then return ""
    str = ""
    if IsString(value)
        str = value
    else
        str = Str(value)
    end if
    str = str.trim()
    if str = "" then return ""
    result = ""
    total = Len(str)
    for i = 1 to total
        ch = Mid(str, i, 1)
        ascii = Asc(ch)
        isAlphaNum = (ascii >= 48 and ascii <= 57) or (ascii >= 65 and ascii <= 90) or (ascii >= 97 and ascii <= 122)
        if isAlphaNum
            result = result + LCase(ch)
        else if ch = "-" or ch = "_"
            result = result + ch
        else
            result = result + "_"
        end if
    end for
    return result
end function

function sabrCacheMetadataTable() as object
    table = m?.sabrCacheMetadataTable
    if GetInterface(table, "ifAssociativeArray") = invalid
        table = {}
        m.sabrCacheMetadataTable = table
    end if
    return table
end function

sub sabrCacheRememberMetadata(fileName as string, metadata as object)
    if not IsString(fileName) then return
    if fileName = "" then return
    if GetInterface(metadata, "ifAssociativeArray") = invalid then return
    meaningful = false
    fields = [ "startSegmentIndex", "endSegmentIndex", "startTimeMs", "durationMs", "timescale", "startTicks", "durationTicks", "playerTimeMs", "storedAtMs", "delivered", "deliveredAtMs", "lastAccessMs" ]
    for each fieldName in fields
        value = invalid
        if metadata.DoesExist(fieldName)
            value = metadata.Lookup(fieldName)
        end if
        if isValid(value)
            meaningful = true
            exit for
        end if
    end for
    table = sabrCacheMetadataTable()
    if not meaningful
        if table.DoesExist(fileName)
            table.Delete(fileName)
        end if
        return
    end if
    table = sabrCacheMetadataTable()
    table[fileName] = metadata
end sub

function sabrCacheLookupMetadata(fileName as string) as dynamic
    if not IsString(fileName) then return invalid
    if fileName = "" then return invalid
    table = sabrCacheMetadataTable()
    if table.DoesExist(fileName)
        return table.Lookup(fileName)
    end if
    return invalid
end function

sub sabrCachePruneMetadata(activeNames as object)
    if GetInterface(activeNames, "ifArray") = invalid
        m.sabrCacheMetadataTable = {}
        return
    end if

    table = sabrCacheMetadataTable()
    cleaned = {}
    for each name in activeNames
        if IsString(name) and name <> ""
            if table.DoesExist(name)
                cleaned[name] = table.Lookup(name)
            end if
        end if
    end for
    m.sabrCacheMetadataTable = cleaned
end sub

function sabrCacheExtractFileName(path as string) as string
    if not IsString(path) then return ""
    if path = "" then return ""
    parts = path.Split("/")
    if GetInterface(parts, "ifArray") = invalid or parts.count() = 0 then return path
    return parts[parts.count() - 1]
end function

function sabrCacheBuildFilename(mediaIdHash as string, contentType as string, itag as dynamic, trackId = "" as string, isInitSegment = false as boolean, rangeStart = invalid as dynamic, rangeEnd = invalid as dynamic) as string
    parts = []
    parts.push(sabrCacheSanitize(mediaIdHash))
    parts.push(sabrCacheSanitize(contentType))
    parts.push(`itag${sabrCacheSanitize(itag)}`)
    trackClean = sabrCacheSanitize(trackId)
    if trackClean <> "" then parts.push(`track${trackClean}`)
    if isInitSegment
        parts.push("init")
    else
        parts.push("seg")
        parts.push(sabrCacheSanitize(rangeStart))
        parts.push(sabrCacheSanitize(rangeEnd))
    end if
    name = parts.Join("-") + ".bin"
    base = sabrCacheEnsureBasePath()
    return `${base}/${name}`
end function

function sabrCacheParseEntry(fileName as string) as object
    if Right(fileName, 4) <> ".bin" then return invalid
    core = Left(fileName, Len(fileName) - 4)
    parts = core.Split("-")
    if GetInterface(parts, "ifArray") = invalid then return invalid
    count = parts.count()
    if count < 4 then return invalid

    idx = 0
    entry = {}
    entry.mediaIdHash = parts[idx]
    idx = idx + 1
    entry.contentType = parts[idx]
    idx = idx + 1

    if count <= idx then return invalid
    itagPart = parts[idx]
    idx = idx + 1
    if itagPart.Left(4) <> "itag" then return invalid
    entry.itag = itagPart.Mid(4)

    entry.trackId = ""
    if count > idx and Left(parts[idx], 5) = "track"
        entry.trackId = parts[idx].Mid(5)
        idx = idx + 1
    end if

    if count <= idx then return invalid
    indicator = parts[idx]
    idx = idx + 1
    if indicator = "init"
        entry.isInit = true
        entry.rangeStart = invalid
        entry.rangeEnd = invalid
    else if indicator = "seg"
        entry.isInit = false
        if count <= idx then return invalid
        startToken = parts[idx]
        if startToken = ""
            entry.rangeStart = invalid
        else
            entry.rangeStart = Val(startToken)
        end if
        idx = idx + 1
        if count <= idx then return invalid
        endToken = parts[idx]
        if endToken = ""
            entry.rangeEnd = invalid
        else
            entry.rangeEnd = Val(endToken)
        end if
    else
        return invalid
    end if

    entry.fileName = fileName
    entry.path = `${sabrCacheEnsureBasePath()}/${fileName}`

    extra = sabrCacheLookupMetadata(fileName)
    if GetInterface(extra, "ifAssociativeArray") <> invalid
        if extra.DoesExist("startSegmentIndex") then entry.startSegmentIndex = extra.Lookup("startSegmentIndex")
        if extra.DoesExist("endSegmentIndex") then entry.endSegmentIndex = extra.Lookup("endSegmentIndex")
        if extra.DoesExist("startTimeMs") then entry.startTimeMs = extra.Lookup("startTimeMs")
        if extra.DoesExist("durationMs") then entry.durationMs = extra.Lookup("durationMs")
        if extra.DoesExist("timescale") then entry.timescale = extra.Lookup("timescale")
        if extra.DoesExist("startTicks") then entry.startTicks = extra.Lookup("startTicks")
        if extra.DoesExist("durationTicks") then entry.durationTicks = extra.Lookup("durationTicks")
        if extra.DoesExist("sequenceNumber") then entry.sequenceNumber = extra.Lookup("sequenceNumber")
        if extra.DoesExist("formatId") then entry.formatId = extra.Lookup("formatId")
        if extra.DoesExist("playerTimeMs") then entry.playerTimeMs = extra.Lookup("playerTimeMs")
    end if
    return entry
end function

function sabrCacheListEntries(mediaIdHash as string, contentType as string, itag as dynamic, trackId = "" as string) as object
    base = sabrCacheEnsureBasePath()
    fs = CreateObject("roFileSystem")
    names = fs.GetDirectoryListing(base)
    results = []
    if GetInterface(names, "ifArray") = invalid then return results

    sabrCachePruneMetadata(names)

    targetMedia = sabrCacheSanitize(mediaIdHash)
    targetType = sabrCacheSanitize(contentType)
    targetItag = sabrCacheSanitize(itag)
    targetTrack = sabrCacheSanitize(trackId)

    for each name in names
        entry = sabrCacheParseEntry(name)
        if GetInterface(entry, "ifAssociativeArray") = invalid then continue for
        entryMedia = sabrCacheSanitize(entry.mediaIdHash)
        entryType = sabrCacheSanitize(entry.contentType)
        entryItag = sabrCacheSanitize(entry.itag)
        entryTrack = sabrCacheSanitize(entry.trackId)
        if entryMedia <> targetMedia then continue for
        if entryType <> targetType then continue for
        if entryItag <> targetItag then continue for
        if targetTrack <> "" and entryTrack <> targetTrack then continue for
        if targetTrack = "" and entryTrack <> "" then continue for
        results.push(entry)
    end for
    return results
end function

function sabrCacheStoreSegment(options as object) as object
    if GetInterface(options, "ifAssociativeArray") = invalid then return invalid
    bytes = options?.bytes
    if GetInterface(bytes, "ifByteArray") = invalid then return invalid

    path = sabrCacheBuildFilename(
        options?.mediaIdHash,
        options?.contentType,
        options?.itag,
        options?.trackId ?? "",
        options?.isInit = true,
        options?.rangeStart,
        options?.rangeEnd
    )

    base = sabrCacheEnsureBasePath()
    fs = CreateObject("roFileSystem")
    if not fs.Exists(base)
        fs.CreateDirectory(base)
    end if

    success = bytes.writeFile(path)
    if success <> true then return invalid

    fileName = sabrCacheExtractFileName(path)
    extra = {}
    if isValid(options?.contentType) then extra.contentType = options.contentType
    if isValid(options?.itag) then extra.itag = options.itag
    if isValid(options?.trackId) then extra.trackId = options.trackId
    nowMs = sabrCacheCurrentTimestampMs()
    if isValid(options?.startSegmentIndex)
        extra.startSegmentIndex = options.startSegmentIndex
    end if
    if isValid(options?.endSegmentIndex)
        extra.endSegmentIndex = options.endSegmentIndex
    end if
    if isValid(options?.startTimeMs)
        extra.startTimeMs = options.startTimeMs
    end if
    if isValid(options?.durationMs)
        extra.durationMs = options.durationMs
    end if
    if isValid(options?.timescale)
        extra.timescale = options.timescale
    end if
    if isValid(options?.startTicks)
        extra.startTicks = options.startTicks
    end if
    if isValid(options?.durationTicks)
        extra.durationTicks = options.durationTicks
    end if
    if isValid(options?.sequenceNumber)
        extra.sequenceNumber = options.sequenceNumber
    else if isValid(extra?.startSegmentIndex)
        extra.sequenceNumber = extra.startSegmentIndex
    end if
    formatIdOpt = options?.formatId
    if GetInterface(formatIdOpt, "ifAssociativeArray") <> invalid
        extra.formatId = formatIdOpt
    end if
    if isValid(options?.playerTimeMs)
        extra["playerTimeMs"] = options.playerTimeMs
    end if
    extra.storedAtMs = nowMs
    extra.lastAccessMs = nowMs
    extra.delivered = false
    sabrCacheRememberMetadata(fileName, extra)
    sabrCacheLog(log_level_Type.DEBUG, `[SabrCache] stored file=${fileName} size=${bytes.count()} storedAt=${nowMs}`)

    sabrCacheRunMaintenance(path)

    sabrCacheLogSnapshot("store", path)
    return {
        "path": path
        "rangeStart": options?.rangeStart
        "rangeEnd": options?.rangeEnd
    }
end function

function sabrCacheLoadSegment(params as object) as object
    if GetInterface(params, "ifAssociativeArray") = invalid then return invalid
    entries = sabrCacheListEntries(params?.mediaIdHash, params?.contentType, params?.itag, params?.trackId ?? "")
    if entries.count() = 0 then return invalid

    requestedStart = Val(params?.requestedStart)
    requestedEnd = Val(params?.requestedEnd)
    hasStart = requestedStart <> invalid
    hasEnd = requestedEnd <> invalid

    best = invalid
    for each entry in entries
        if entry.isInit = true
            if params?.isInit = true
                best = entry
                exit for
            else
                continue for
            end if
        end if

        if params?.isInit = true then continue for

        coverageStart = entry?.rangeStart
        coverageEnd = entry?.rangeEnd
        if coverageStart = invalid or coverageEnd = invalid then continue for

        matches = true
        if hasStart and requestedStart < coverageStart then matches = false
        if matches and hasEnd and requestedEnd > coverageEnd then matches = false

        if matches = false then
            ' allow exact end match when end unknown
            if hasStart and coverageStart = requestedStart and hasEnd = false
                matches = true
            end if
        end if

        if matches
            if best = invalid
                best = entry
            else
                ' prefer tighter coverage
                bestSpan = (best.rangeEnd - best.rangeStart)
                entrySpan = (coverageEnd - coverageStart)
                if entrySpan < bestSpan
                    best = entry
                end if
            end if
        end if
    end for

    if params?.isInit = true and best = invalid
        ' fallback: use first init if available
        for each entry in entries
            if entry.isInit = true
                best = entry
                exit for
            end if
        end for
    end if

    if best = invalid then return invalid

    bytes = CreateObject("roByteArray")
    if not bytes.readFile(best.path) then return invalid

    sabrCacheRecordAccess(best)

    coverageStart = best?.rangeStart
    coverageEnd = best?.rangeEnd
    if best.isInit = true
        coverageStart = 0
        coverageEnd = bytes.count() - 1
    end if

    sabrCacheLogSnapshot("load", best.path)

    result = invalid

    if params?.isInit = true
        result = {
            "data": bytes
            "rangeStart": coverageStart
            "rangeEnd": coverageEnd
            "path": best.path
        }
    else
        if hasStart and coverageStart <> invalid and requestedStart > coverageStart
            offset = requestedStart - coverageStart
        else
            offset = 0
        end if

        if hasEnd and coverageEnd <> invalid
            desiredLength = (requestedEnd - (coverageStart + offset)) + 1
            if desiredLength < 0 then desiredLength = 0
        else
            desiredLength = bytes.count() - offset
        end if

        if offset <= 0 and desiredLength >= bytes.count()
            sliced = bytes
        else
            sliced = CreateObject("roByteArray")
            if desiredLength < 0 then desiredLength = 0
            if desiredLength > bytes.count() - offset then desiredLength = bytes.count() - offset
            if desiredLength < 0 then desiredLength = 0
            if desiredLength = 0
                ' return empty array
            else
                for i = 0 to desiredLength - 1
                    sliced[i] = bytes[offset + i]
                end for
            end if
        end if

        effectiveStart = coverageStart
        if hasStart and requestedStart <> invalid
            effectiveStart = requestedStart
        end if
        effectiveEnd = effectiveStart + sliced.count() - 1

        result = {
            "data": sliced
            "rangeStart": effectiveStart
            "rangeEnd": effectiveEnd
            "path": best.path
        }
    end if

    if GetInterface(result, "ifAssociativeArray") = invalid then return invalid

    sabrCacheMarkDelivered(best)
    sabrCacheRunMaintenance(best.path)
    return result
end function

sub sabrCacheRecordAccess(entry as object)
    if GetInterface(entry, "ifAssociativeArray") = invalid then return
    fileName = entry?.fileName
    if not IsString(fileName) or fileName = "" then return

    table = sabrCacheMetadataTable()
    metadata = table.Lookup(fileName)
    if GetInterface(metadata, "ifAssociativeArray") = invalid
        metadata = {}
    end if

    timestamp = sabrCacheCurrentTimestampMs()
    metadata.lastAccessMs = timestamp
    if not metadata.DoesExist("storedAtMs") or not isValid(metadata.storedAtMs)
        fs = CreateObject("roFileSystem")
        metadata.storedAtMs = Int(sabrCacheExtractModifiedTicks(fs, entry?.path))
    end if
    table[fileName] = metadata
    sabrCacheLog(log_level_Type.DEBUG, `[SabrCache] access file=${fileName} lastAccessMs=${metadata.lastAccessMs}`)
end sub

sub sabrCacheMarkDelivered(entry as object)
    if GetInterface(entry, "ifAssociativeArray") = invalid then return
    fileName = entry?.fileName
    if not IsString(fileName) or fileName = "" then return

    table = sabrCacheMetadataTable()
    metadata = table.Lookup(fileName)
    if GetInterface(metadata, "ifAssociativeArray") = invalid
        metadata = {}
    end if

    timestamp = sabrCacheCurrentTimestampMs()
    metadata.delivered = true
    metadata.deliveredAtMs = timestamp
    metadata.lastAccessMs = timestamp
    if not metadata.DoesExist("storedAtMs") or not isValid(metadata.storedAtMs)
        fs = CreateObject("roFileSystem")
        metadata.storedAtMs = Int(sabrCacheExtractModifiedTicks(fs, entry?.path))
    end if
    table[fileName] = metadata
    sabrCacheUpdateDeliveryProgress(entry, metadata)
    sabrCacheLog(log_level_Type.DEBUG, `[SabrCache] delivered file=${fileName} deliveredAt=${metadata.deliveredAtMs}`)
end sub

sub sabrCacheMarkDeliveredByPath(path as string, reason as string, extra = invalid as dynamic)
    if not IsString(path) or path = "" then return
    fileName = sabrCacheExtractFileName(path)
    entry = sabrCacheParseEntry(fileName)
    if GetInterface(entry, "ifAssociativeArray") = invalid
        entry = {
            fileName: fileName
            path: path
        }
    else
        entry.path = path
    end if
    if GetInterface(extra, "ifAssociativeArray") <> invalid
        for each key in extra
            entry[key] = extra[key]
        end for
    end if
    sabrCacheLog(log_level_Type.DEBUG, `[SabrCache] mark-delivered path=${fileName} reason=${reason}`)
    sabrCacheMarkDelivered(entry)
    sabrCacheRunMaintenance(path)
end sub

function sabrCacheDeliveryProgress() as object
    progress = m?.sabrCacheDeliveryProgress
    if GetInterface(progress, "ifAssociativeArray") = invalid
        progress = {}
        m.sabrCacheDeliveryProgress = progress
    end if
    return progress
end function

function sabrCacheEnsureDeliveryProgressKey(contentType as dynamic, itag as dynamic, trackId as dynamic) as object
    key = `${sabrCacheSanitize(contentType)}|${sabrCacheSanitize(itag)}|${sabrCacheSanitize(trackId)}`
    if key = "||" then key = "unknown|none|main"
    progress = sabrCacheDeliveryProgress()
    info = progress.Lookup(key)
    if GetInterface(info, "ifAssociativeArray") = invalid
        info = {}
        progress[key] = info
        m.sabrCacheDeliveryProgress = progress
    end if
    return info
end function

function sabrCacheBuildDeliveryKey(entry as object) as string
    if GetInterface(entry, "ifAssociativeArray") = invalid then return ""
    typeKey = sabrCacheSanitize(entry?.contentType)
    if typeKey = "" then typeKey = "unknown"
    itagKey = sabrCacheSanitize(entry?.itag)
    if itagKey = "" then itagKey = "none"
    trackKey = sabrCacheSanitize(entry?.trackId)
    if trackKey = "" then trackKey = "main"
    return `${typeKey}|${itagKey}|${trackKey}`
end function

function sabrCacheExtractSequence(entry as object, metadata as object) as dynamic
    seqVal = sabrCacheNormalizeNumber(metadata?.sequenceNumber)
    if seqVal = invalid then seqVal = sabrCacheNormalizeNumber(metadata?.startSegmentIndex)
    if seqVal = invalid and GetInterface(entry, "ifAssociativeArray") <> invalid
        seqVal = sabrCacheNormalizeNumber(entry?.sequenceNumber)
        if seqVal = invalid then seqVal = sabrCacheNormalizeNumber(entry?.startSegmentIndex)
    end if
    return seqVal
end function

sub sabrCacheUpdateDeliveryProgress(entry as object, metadata as object)
    progress = sabrCacheDeliveryProgress()
    key = sabrCacheBuildDeliveryKey(entry)
    if key = "" then return
    info = sabrCacheEnsureDeliveryProgressKey(entry?.contentType, entry?.itag, entry?.trackId)

    seqVal = sabrCacheExtractSequence(entry, metadata)
    if seqVal <> invalid
        lastSeq = sabrCacheNormalizeNumber(info?.lastSequence)
        if lastSeq = invalid or seqVal > lastSeq
            info.lastSequence = seqVal
        end if
    end if

    rangeStart = sabrCacheNormalizeNumber(metadata?.rangeStart)
    if rangeStart = invalid and GetInterface(entry, "ifAssociativeArray") <> invalid
        rangeStart = sabrCacheNormalizeNumber(entry?.rangeStart)
    end if
    if rangeStart <> invalid
        lastRange = sabrCacheNormalizeNumber(info?.lastRangeStart)
        if lastRange = invalid or rangeStart > lastRange
            info.lastRangeStart = rangeStart
        end if
    end if

    deliveredAt = sabrCacheNormalizeNumber(metadata?.deliveredAtMs)
    if deliveredAt = invalid
        deliveredAt = sabrCacheCurrentTimestampMs()
    end if
    info.lastDeliveredAtMs = deliveredAt
    info.updatedAtMs = sabrCacheCurrentTimestampMs()

    startTimeMs = sabrCacheNormalizeNumber(metadata?.startTimeMs)
    if startTimeMs = invalid and GetInterface(metadata?.timeRange, "ifAssociativeArray") <> invalid
        ticks = sabrCacheNormalizeNumber(metadata.timeRange?.startTicks)
        timescale = sabrCacheNormalizeNumber(metadata.timeRange?.timescale)
        if ticks <> invalid and timescale <> invalid and timescale > 0
            startTimeMs = Int((ticks * 1000) / timescale)
        end if
    end if
    if startTimeMs = invalid and GetInterface(entry, "ifAssociativeArray") <> invalid
        startTimeMs = sabrCacheNormalizeNumber(entry?.startTimeMs)
    end if
    if startTimeMs <> invalid
        info.lastPlayerTimeMs = startTimeMs
    end if

    progress[key] = info
    m.sabrCacheDeliveryProgress = progress
end sub

function sabrCacheShouldDeferDeliveredRemoval(entry as object, metadata as object, nowMs as integer) as boolean
    if GetInterface(metadata, "ifAssociativeArray") = invalid then return false
    if metadata?.delivered <> true then return false

    deliveredAt = sabrCacheNormalizeNumber(metadata?.deliveredAtMs)
    if deliveredAt <> invalid and nowMs - deliveredAt < SABR_CACHE_DELIVERED_MIN_AGE_MS
        return true
    end if

    key = sabrCacheBuildDeliveryKey(entry)
    if key = "" then return false
    progress = sabrCacheDeliveryProgress()
    info = progress.Lookup(key)
    if GetInterface(info, "ifAssociativeArray") = invalid then return false

    seqVal = sabrCacheExtractSequence(entry, metadata)
    lastSeq = sabrCacheNormalizeNumber(info?.lastSequence)
    if seqVal <> invalid and lastSeq <> invalid
        diffSeq = lastSeq - seqVal
        if diffSeq < SABR_CACHE_DELIVERED_SEQUENCE_GUARD
            return true
        end if
    end if

    rangeStart = sabrCacheNormalizeNumber(metadata?.rangeStart)
    lastRange = sabrCacheNormalizeNumber(info?.lastRangeStart)
    if rangeStart <> invalid and lastRange <> invalid
        diffRange = lastRange - rangeStart
        if diffRange >= 0 and diffRange < SABR_CACHE_DELIVERED_RANGE_GUARD
            return true
        end if
    end if

    return false
end function

function sabrCacheShouldCullPending(entry as object, metadata as object) as boolean
    if GetInterface(metadata, "ifAssociativeArray") = invalid then return false
    key = sabrCacheBuildDeliveryKey(entry)
    if key = "" then return false
    progress = sabrCacheDeliveryProgress()
    info = progress.Lookup(key)
    if GetInterface(info, "ifAssociativeArray") = invalid then return false

    seqVal = sabrCacheExtractSequence(entry, metadata)
    lastSeq = sabrCacheNormalizeNumber(info?.lastSequence)
    if seqVal <> invalid and lastSeq <> invalid
        diffSeq = lastSeq - seqVal
        if diffSeq > SABR_CACHE_PENDING_SEQUENCE_DISTANCE
            return true
        end if
    end if

    rangeStart = sabrCacheNormalizeNumber(metadata?.rangeStart)
    if rangeStart = invalid and GetInterface(entry, "ifAssociativeArray") <> invalid
        rangeStart = sabrCacheNormalizeNumber(entry?.rangeStart)
    end if
    lastRange = sabrCacheNormalizeNumber(info?.lastRangeStart)
    if rangeStart <> invalid and lastRange <> invalid
        diffRange = lastRange - rangeStart
        if diffRange > SABR_CACHE_PENDING_RANGE_DISTANCE
            return true
        end if
    end if

    playerTimeMs = sabrCacheNormalizeNumber(metadata?.playerTimeMs)
    if playerTimeMs = invalid and GetInterface(metadata?.startTimeMs, "ifAssociativeArray") = invalid
        playerTimeMs = sabrCacheNormalizeNumber(metadata?.startTimeMs)
    end if
    if playerTimeMs = invalid and GetInterface(entry, "ifAssociativeArray") <> invalid
        playerTimeMs = sabrCacheNormalizeNumber(entry?.startTimeMs)
    end if
    lastPlayerMs = sabrCacheNormalizeNumber(info?.lastPlayerTimeMs)
    if playerTimeMs <> invalid and lastPlayerMs <> invalid
        diffMs = lastPlayerMs - playerTimeMs
        if diffMs > SABR_CACHE_PENDING_PLAYER_TIME_MS
            return true
        end if
    end if

    return false
end function

sub sabrCacheRunMaintenance(activePath as string)
    base = sabrCacheEnsureBasePath()
    fs = CreateObject("roFileSystem")
    names = fs.GetDirectoryListing(base)
    if GetInterface(names, "ifArray") = invalid then return

    nowMs = sabrCacheCurrentTimestampMs()
    table = sabrCacheMetadataTable()
    removedAny = false
    removedCount = 0
    focusPath = ""

    sabrCacheLog(log_level_Type.DEBUG, `[SabrCache] maintenance start total=${names.count()} activePath=${activePath}`)
    sabrCacheLogPendingEntries(table, base, "start")

    for each name in names
        path = `${base}/${name}`
        entryInfo = sabrCacheParseEntry(name)
        if GetInterface(entryInfo, "ifAssociativeArray") = invalid
            entryInfo = {
                fileName: name
            }
        end if
        entryInfo.path = path
        metadata = table.Lookup(name)
        delivered = false
        storedAtMs = invalid
        deliveredAtMs = invalid
        lastTouchMs = invalid

        if GetInterface(metadata, "ifAssociativeArray") <> invalid
            delivered = metadata?.delivered = true
            storedAtMs = sabrCacheNormalizeNumber(metadata?.storedAtMs)
            deliveredAtMs = sabrCacheNormalizeNumber(metadata?.deliveredAtMs)
            lastTouchMs = sabrCacheNormalizeNumber(metadata?.lastAccessMs)
            if not metadata.DoesExist("contentType") and entryInfo?.contentType <> invalid
                metadata.contentType = entryInfo.contentType
            end if
            if not metadata.DoesExist("itag") and entryInfo?.itag <> invalid
                metadata.itag = entryInfo.itag
            end if
            if not metadata.DoesExist("trackId") and entryInfo?.trackId <> invalid
                metadata.trackId = entryInfo.trackId
            end if
            table[name] = metadata
        end if

        if storedAtMs = invalid or storedAtMs <= 0
            storedAtMs = Int(sabrCacheExtractModifiedTicks(fs, path))
        end if
        if lastTouchMs = invalid or lastTouchMs <= 0
            if deliveredAtMs <> invalid and deliveredAtMs > 0
                lastTouchMs = deliveredAtMs
            else
                lastTouchMs = storedAtMs
            end if
        end if

        shouldRemove = false
        removalReason = ""
        if delivered
            if sabrCacheShouldDeferDeliveredRemoval(entryInfo, metadata, nowMs)
                sabrCacheLog(log_level_Type.DEBUG, `[SabrCache] skip removal file=${name} reason=recent-delivery`)
            else
                shouldRemove = true
                removalReason = "delivered"
            end if
        else
            if sabrCacheShouldCullPending(entryInfo, metadata)
                shouldRemove = true
                removalReason = "orphan-early"
            else
            if storedAtMs <> invalid and storedAtMs > 0
                ageMs = nowMs - storedAtMs
                if ageMs >= MAX_SABR_CACHE_SEGMENT_AGE_MS
                    shouldRemove = true
                    removalReason = `stale-age stored=${storedAtMs} age=${ageMs}`
                end if
            else if lastTouchMs <> invalid and lastTouchMs > 0
                ageFallback = nowMs - lastTouchMs
                if ageFallback >= MAX_SABR_CACHE_SEGMENT_AGE_MS
                    shouldRemove = true
                    removalReason = `stale-lastTouch last=${lastTouchMs} age=${ageFallback}`
                end if
            end if
            end if
        end if

        if shouldRemove and activePath <> "" and path = activePath and delivered = false
            shouldRemove = false
            sabrCacheLog(log_level_Type.DEBUG, `[SabrCache] skip removal file=${name} reason=active-request`)
        end if

        if shouldRemove
            if removalReason = "" then removalReason = "unspecified"
            sabrCacheLog(log_level_Type.DEBUG, `[SabrCache] removing file=${name} reason=${removalReason}`)
            success = true
            if fs.Exists(path)
                success = fs.Delete(path)
            end if
            if table.DoesExist(name)
                table.Delete(name)
            end if
            removedAny = true
            removedCount = removedCount + 1
            focusPath = path
            if success
                ' confirm removal
                confirmExists = fs.Exists(path)
                dirAfter = fs.GetDirectoryListing(base)
                listingLabel = ""
                if GetInterface(dirAfter, "ifArray") <> invalid
                    idxCount = 0
                    for each entryName in dirAfter
                        if entryName = name then confirmExists = true
                        if idxCount >= 10 then exit for
                        if listingLabel = ""
                            listingLabel = entryName
                        else
                            listingLabel = `${listingLabel},${entryName}`
                        end if
                        idxCount = idxCount + 1
                    end for
                end if
                sabrCacheLog(log_level_Type.DEBUG, `[SabrCache] post-delete verification file=${name} exists=${confirmExists} sampleEntries=${listingLabel}`)
                sabrCacheLogPendingEntries(table, base, "post-delete")
            else
                sabrCacheLog(log_level_Type.WARN, `[SabrCache] failed to delete file=${name}`)
            end if
        end if
    end for

    ' Remove metadata entries whose files were deleted elsewhere
    keys = table.keys()
    for each key in keys
        lookupPath = `${base}/${key}`
        if not fs.Exists(lookupPath)
            table.Delete(key)
            removedAny = true
            focusPath = lookupPath
        end if
    end for

    if removedAny
        updated = fs.GetDirectoryListing(base)
        sabrCachePruneMetadata(updated)
        sabrCacheLogSnapshot("cleanup", focusPath)
        sabrCacheLog(log_level_Type.INFO, `[SabrCache] maintenance removed=${removedCount} remaining=${updated.count()}`)
    else
        sabrCacheLog(log_level_Type.DEBUG, "[SabrCache] maintenance removed=0")
    end if
    sabrCacheLogPendingEntries(table, base, "end")
end sub

sub sabrCacheLogPendingEntries(table as object, base as string, phase as string)
    if GetInterface(table, "ifAssociativeArray") = invalid then return

    nowMs = sabrCacheCurrentTimestampMs()
    pendingLabels = []
    deliveredLabels = []

    keys = table.keys()
    total = 0
    deliveredCount = 0
    pendingCount = 0

    for each key in keys
        metadata = table.Lookup(key)
        total = total + 1
        deliveredFlag = false
        if GetInterface(metadata, "ifAssociativeArray") <> invalid
            deliveredValue = metadata?.delivered
            if isValid(deliveredValue)
                deliveredFlag = (deliveredValue = true)
            end if
        end if

        storedMs = invalid
        lastMs = invalid
        deliveredMs = invalid
        if GetInterface(metadata, "ifAssociativeArray") <> invalid
            storedMs = sabrCacheNormalizeNumber(metadata?.storedAtMs)
            lastMs = sabrCacheNormalizeNumber(metadata?.lastAccessMs)
            deliveredMs = sabrCacheNormalizeNumber(metadata?.deliveredAtMs)
        end if

        ageStored = invalid
        ageLast = invalid
        if storedMs <> invalid and storedMs > 0
            ageStored = nowMs - storedMs
        end if
        if lastMs <> invalid and lastMs > 0
            ageLast = nowMs - lastMs
        end if

        statusLabel = "pending"
        if deliveredFlag then statusLabel = "delivered"

        infoLabel = `${key} status=${statusLabel}`
        if ageStored <> invalid
            infoLabel = `${infoLabel} ageStored=${ageStored}`
        end if
        if ageLast <> invalid
            infoLabel = `${infoLabel} ageLast=${ageLast}`
        end if
        if deliveredMs <> invalid
            infoLabel = `${infoLabel} deliveredAtAge=${nowMs - deliveredMs}`
        end if

        if deliveredFlag
            deliveredCount = deliveredCount + 1
            deliveredLabels.push(infoLabel)
        else
            pendingCount = pendingCount + 1
            pendingLabels.push(infoLabel)
        end if
    end for

    labelPending = sabrCacheBuildSample(pendingLabels)
    labelDelivered = sabrCacheBuildSample(deliveredLabels)
    sabrCacheLog(log_level_Type.DEBUG, `[SabrCache] state phase=${phase} total=${total} pending=${pendingCount} delivered=${deliveredCount}`)
    if pendingCount > 0
        sabrCacheLog(log_level_Type.DEBUG, `[SabrCache] pending sample (${pendingLabels.count()} total) -> ${labelPending}`)
    end if
    if deliveredCount > 0
        sabrCacheLog(log_level_Type.DEBUG, `[SabrCache] delivered sample (${deliveredLabels.count()} total) -> ${labelDelivered}`)
    end if
end sub

function sabrCacheBuildSample(items as object) as string
    if GetInterface(items, "ifArray") = invalid then return ""
    maxItems = 10
    summary = ""
    total = items.count()
    if total = 0 then return summary
    limit = maxItems
    if total < limit then limit = total
    for idx = 0 to limit - 1
        entry = items[idx]
        if summary = ""
            summary = entry
        else
            summary = `${summary} | ${entry}`
        end if
    end for
    if total > limit
        summary = `${summary} | ...(${total - limit} more)`
    end if
    return summary
end function

function sabrCacheExtractModifiedTicks(fs as object, path as string) as double
    if fs = invalid then return 0.0
    info = fs.Stat(path)
    if GetInterface(info, "ifAssociativeArray") = invalid then return 0.0

    keys = [ "modified", "modificationTime", "creationTime", "ctime", "mtime" ]
    stamp = invalid
    for each key in keys
        if info.DoesExist(key)
            stamp = info.Lookup(key)
            exit for
        end if
    end for

    if stamp = invalid then return 0.0

    if GetInterface(stamp, "ifDateTime") <> invalid
        return (stamp.AsSeconds() * 1000.0) + stamp.GetMilliseconds()
    end if

    if IsInteger(stamp) or IsFloat(stamp) or IsDouble(stamp)
        return stamp + 0.0
    end if

    return 0.0
end function

sub sabrCacheLogSnapshot(reason as string, focusPath as string)
    logs = sabrCacheLogger()
    if GetInterface(logs, "ifAssociativeArray") = invalid then return

    base = sabrCacheEnsureBasePath()
    fs = CreateObject("roFileSystem")
    entries = fs.GetDirectoryListing(base)
    if GetInterface(entries, "ifArray") = invalid then return

    limit = SABR_CACHE_LOG_SAMPLE
    summary = ""
    total = entries.count()
    if total = 0 then return

    ' simple lexicographic sort descending
    for i = 0 to total - 2
        for j = i + 1 to total - 1
            if entries[j] > entries[i]
                temp = entries[i]
                entries[i] = entries[j]
                entries[j] = temp
            end if
        end for
    end for

    for idx = 0 to total - 1
        if idx >= limit then exit for
        file = entries[idx]
        path = `${base}/${file}`
        bytes = CreateObject("roByteArray")
        sizeLabel = "?"
        if bytes.readFile(path)
            sizeLabel = sabrCache_formatSize(bytes.count())
        end if
        label = `${file}(${sizeLabel})`
        if summary = ""
            summary = label
        else
            summary = `${summary}, ${label}`
        end if
    end for

    focusLabel = focusPath
    if focusLabel <> "" and focusLabel.InStr("/") >= 0
        parts = focusLabel.Split("/")
        focusLabel = parts[parts.count() - 1]
    end if

    logs.printl(log_level_Type.DEBUG, `[SabrCache] snapshot reason=${reason} focus=${focusLabel} -> ${summary}`)
end sub

function sabrCache_formatSize(sizeValue as dynamic) as string
    sizeNum = 0
    if IsInteger(sizeValue) or IsFloat(sizeValue) or IsDouble(sizeValue)
        sizeNum = sizeValue
    else if IsString(sizeValue)
        sizeNum = Val(sizeValue)
    else
        sizeNum = 0
    end if
    if sizeNum = invalid or sizeNum < 0 then return "?"
    if sizeNum < 1024 then return `${Int(sizeNum)}B`
    kb = sizeNum / 1024.0
    if kb < 1024 then return `${Int(kb + 0.5)}KB`
    mb = kb / 1024.0
    return `${Int(mb + 0.5)}MB`
end function
