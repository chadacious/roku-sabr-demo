' Simple filesystem-based cache helpers for SABR segments.

import "pkg:/source/isItem.bs"
import "pkg:/source/SabrDebug.bs"

' Root directory under tmp:/ where SABR segments are cached
const SABR_CACHE_BASE_DIR = "tmp:/sabr-cache"
' Number of entries to sample when logging cache snapshots
const SABR_CACHE_LOG_SAMPLE = 100
' Max age (ms) before segments are considered stale and eligible for removal
const MAX_SABR_CACHE_SEGMENT_AGE_MS = 60 * 1000
' Guard: keep delivered segments within N sequence numbers of the newest
const SABR_CACHE_DELIVERED_SEQUENCE_GUARD = 3
' Guard: keep delivered segments whose byte range is within this many bytes
const SABR_CACHE_DELIVERED_RANGE_GUARD = 200000
' Minimum time (ms) before a delivered segment can be removed
const SABR_CACHE_DELIVERED_MIN_AGE_MS = 1500
' Pending segments older than this many sequence numbers are culled
const SABR_CACHE_PENDING_SEQUENCE_DISTANCE = 4
' Pending segments whose range starts beyond this many bytes are culled
const SABR_CACHE_PENDING_RANGE_DISTANCE = 400000
' Pending segments older than this many ms (relative to player time) are culled
const SABR_CACHE_PENDING_PLAYER_TIME_MS = 15 * 1000
' Seek guard duration (ms) to keep segments around after a seek/back operation
const SABR_CACHE_SEEK_GUARD_MS = 30 * 1000
' Hard cap on total cache size (bytes); oldest entries are removed when exceeded
const SABR_CACHE_TOTAL_SIZE_LIMIT = 10 * 1024 * 1024 ' 10 * 1024 * 1024 ` 10MB
' Lifetime (ms) for temporary streamed segment chunks under tmp:/sabr-cache/segments
const SABR_CACHE_SEGMENT_TEMP_MAX_AGE_MS = 30 * 1000
' Chunk size (bytes) used when copying cached segment files without loading them fully
const SABR_CACHE_COPY_CHUNK_SIZE_BYTES = 128 * 1024

sub sabr_cacheSetLogger(logs as dynamic)
    m.sabr_cacheLogger = logs
end sub

function sabr_cacheLogger() as dynamic
    return m?.sabr_cacheLogger
end function

sub sabr_cacheLog(level as integer, message as string)
    logs = sabr_cacheLogger()
    debugOnly = (level = log_level_Type.DEBUG) or (level = log_level_Type.VERBOSE)
    sabr_log(logs, level, message, debugOnly)
end sub

function sabr_cacheCurrentTimestampMs() as integer
    dt = CreateObject("roDateTime")
    if not IsDateTime(dt) then return 0
    return (dt.AsSeconds() * 1000) + dt.GetMilliseconds()
end function

function sabr_cacheNormalizeNumber(value as dynamic) as dynamic
    if IsInteger(value)
        return value
    else if IsFloat(value) or IsDouble(value)
        return Int(value)
    else if IsString(value)
        trimmed = value.Trim()
        if trimmed = "" then return invalid

        parsedInt = sabr_cacheParseIntLiteral(trimmed)
        if parsedInt <> invalid then return parsedInt

        parsed = Val(trimmed)
        if IsInteger(parsed) or IsFloat(parsed) or IsDouble(parsed)
            return Int(parsed)
        end if
        return parsed
    end if
    return invalid
end function

function sabr_cacheParseIntLiteral(text as string) as dynamic
    if text = "" then return invalid

    idx = 1
    sign = 1
    total = Len(text)
    firstChar = Mid(text, idx, 1)
    if firstChar = "+"
        idx = idx + 1
    else if firstChar = "-"
        sign = -1
        idx = idx + 1
    end if

    if idx > total then return invalid

    result = 0
    for i = idx to total
        ch = Mid(text, i, 1)
        ascii = Asc(ch)
        if ascii < 48 or ascii > 57
            return invalid
        end if

        digit = ascii - 48
        nextVal = result * 10 + digit
        if nextVal < result
            return invalid
        end if
        result = nextVal
    end for

    if sign < 0
        result = 0 - result
    end if

    if result > 2147483647 or result < -2147483648
        return invalid
    end if

    return result
end function

function sabr_cacheEnsureBasePath() as string
    fs = CreateObject("roFileSystem")
    if not fs.Exists(SABR_CACHE_BASE_DIR)
        success = fs.CreateDirectory(SABR_CACHE_BASE_DIR)
        logObj = sabr_cacheLogger()
        if success <> true and IsAssociativeArray(logObj)
            sabr_log(logObj, log_level_Type.WARN, `[SabrCache] Failed to create cache directory ${SABR_CACHE_BASE_DIR}`, false)
        end if
    end if
    return SABR_CACHE_BASE_DIR
end function

function sabr_cacheSanitize(value as dynamic) as string
    if not isValid(value) then return ""
    str = ""
    if IsString(value)
        str = value
    else
        str = Str(value)
    end if
    str = str.trim()
    if str = "" then return ""
    result = ""
    total = Len(str)
    for i = 1 to total
        ch = Mid(str, i, 1)
        ascii = Asc(ch)
        isAlphaNum = (ascii >= 48 and ascii <= 57) or (ascii >= 65 and ascii <= 90) or (ascii >= 97 and ascii <= 122)
        if isAlphaNum
            result = result + LCase(ch)
        else if ch = "-" or ch = "_"
            result = result + ch
        else
            result = result + "_"
        end if
    end for
    return result
end function

function sabr_cacheNumberToLabel(value as dynamic) as string
    num = sabr_cacheNormalizeNumber(value)
    if num <> invalid
        label = ""
        try
            label = FormatJson(num)
        catch err
            label = ""
        end try
        if IsString(label)
            trimmedJson = label.trim()
            if trimmedJson <> ""
                return trimmedJson
            end if
        end if

        if num = 0 then return "0"

        working = num
        prefix = ""
        if working < 0
            prefix = "-"
            working = 0 - working
        end if

        digits = ""
        while working > 0
            digit = working mod 10
            digits = Chr(48 + digit) + digits
            working = int(working / 10)
        end while

        if digits = "" then digits = "0"
        return prefix + digits
    end if

    if IsString(value)
        trimmed = value.trim()
        if trimmed <> ""
            return trimmed
        end if
    end if
    return ""
end function

function sabr_cacheMetadataTable() as object
    table = m?.sabr_cacheMetadataTable
    if not IsAssociativeArray(table)
        table = {}
        m.sabr_cacheMetadataTable = table
    end if
    return table
end function

sub sabr_cacheRememberMetadata(fileName as string, metadata as object)
    if not IsString(fileName) then return
    if fileName = "" then return
    if not IsAssociativeArray(metadata) then return
    meaningful = false
    fields = ["startSegmentIndex", "endSegmentIndex", "startTimeMs", "durationMs", "timescale", "startTicks", "durationTicks", "playerTimeMs", "storedAtMs", "delivered", "deliveredAtMs", "lastAccessMs", "mediaIdHash", "rangeStart", "rangeEnd", "totalBytes"]
    for each fieldName in fields
        value = invalid
        if metadata.DoesExist(fieldName)
            value = metadata.Lookup(fieldName)
        end if
        if isValid(value)
            meaningful = true
            exit for
        end if
    end for
    table = sabr_cacheMetadataTable()
    if not meaningful
        if table.DoesExist(fileName)
            table.Delete(fileName)
        end if
        return
    end if
    table = sabr_cacheMetadataTable()
    table[fileName] = metadata
end sub

function sabr_cacheLookupMetadata(fileName as string) as dynamic
    if not IsString(fileName) then return invalid
    if fileName = "" then return invalid
    table = sabr_cacheMetadataTable()
    if table.DoesExist(fileName)
        return table.Lookup(fileName)
    end if
    return invalid
end function

sub sabr_cachePruneMetadata(activeNames as object)
    if not IsArray(activeNames)
        m.sabr_cacheMetadataTable = {}
        return
    end if

    table = sabr_cacheMetadataTable()
    cleaned = {}
    for each name in activeNames
        if IsString(name) and name <> ""
            if table.DoesExist(name)
                cleaned[name] = table.Lookup(name)
            end if
        end if
    end for
    m.sabr_cacheMetadataTable = cleaned
end sub

function sabr_cacheExtractFileName(path as string) as string
    if not IsString(path) then return ""
    if path = "" then return ""
    parts = path.Split("/")
    if not IsArray(parts) or parts.count() = 0 then return path
    return parts[parts.count() - 1]
end function

function sabr_cacheBuildFilename(mediaIdHash as string, contentType as string, itag as dynamic, trackId = "" as string, isInitSegment = false as boolean, rangeStart = invalid as dynamic, rangeEnd = invalid as dynamic) as string
    parts = []
    parts.push(sabr_cacheSanitize(mediaIdHash))
    parts.push(sabr_cacheSanitize(contentType))
    parts.push(`itag${sabr_cacheSanitize(itag)}`)
    trackClean = sabr_cacheSanitize(trackId)
    if trackClean <> "" then parts.push(`track${trackClean}`)
    if isInitSegment
        parts.push("init")
    else
        parts.push("seg")
        parts.push(sabr_cacheSanitize(sabr_cacheNumberToLabel(rangeStart)))
        parts.push(sabr_cacheSanitize(sabr_cacheNumberToLabel(rangeEnd)))
    end if
    name = parts.Join("-") + ".bin"
    base = sabr_cacheEnsureBasePath()
    return `${base}/${name}`
end function

function sabr_cacheParseNumberToken(token as string) as dynamic
    if token = invalid or token = "" then return invalid
    cleaned = token
    posE = InStr(1, cleaned, "e")
    if posE = 0 then posE = InStr(1, cleaned, "E")
    if posE > 0
        mantissa = Left(cleaned, posE - 1)
        exponent = Mid(cleaned, posE + 1)
        posUnd = InStr(1, mantissa, "_")
        if posUnd > 0
            mantissa = Left(mantissa, posUnd - 1) + "." + Mid(mantissa, posUnd + 1)
        end if
        if Len(exponent) > 0 and Mid(exponent, 1, 1) = "_"
            exponent = "+" + Mid(exponent, 2)
        end if
        while InStr(1, exponent, "_") > 0
            underscorePos = InStr(1, exponent, "_")
            exponent = Left(exponent, underscorePos - 1) + Mid(exponent, underscorePos + 1)
        end while
        cleaned = `${mantissa}e${exponent}`
    else
        while InStr(1, cleaned, "_") > 0
            underscorePos = InStr(1, cleaned, "_")
            cleaned = Left(cleaned, underscorePos - 1) + Mid(cleaned, underscorePos + 1)
        end while
    end if
    numeric = Val(cleaned)
    if numeric = invalid
        numeric = sabr_cacheNormalizeNumber(cleaned)
    end if
    if numeric = invalid then return invalid
    return sabr_cacheNormalizeNumber(numeric)
end function

function sabr_cacheParseEntry(fileName as string) as object
    if Right(fileName, 4) <> ".bin" then return invalid
    core = Left(fileName, Len(fileName) - 4)
    parts = core.Split("-")
    if not IsArray(parts) then return invalid
    count = parts.count()
    if count < 4 then return invalid

    idx = 0
    entry = {}
    entry["mediaIdHash"] = parts[idx]
    idx = idx + 1
    entry["contentType"] = parts[idx]
    idx = idx + 1

    if count <= idx then return invalid
    itagPart = parts[idx]
    idx = idx + 1
    if itagPart.Left(4) <> "itag" then return invalid
    entry["itag"] = itagPart.Mid(4)

    entry["trackId"] = ""
    if count > idx and Left(parts[idx], 5) = "track"
        entry["trackId"] = parts[idx].Mid(5)
        idx = idx + 1
    end if

    if count <= idx then return invalid
    indicator = parts[idx]
    idx = idx + 1
    if indicator = "init"
        entry["isInit"] = true
        entry["rangeStart"] = invalid
        entry["rangeEnd"] = invalid
    else if indicator = "seg"
        entry["isInit"] = false
        if count <= idx then return invalid
        startToken = parts[idx]
        if startToken = ""
            entry["rangeStart"] = invalid
        else
            entry["rangeStart"] = sabr_cacheParseNumberToken(startToken)
        end if
        idx = idx + 1
        if count <= idx then return invalid
        endToken = parts[idx]
        if endToken = ""
            entry["rangeEnd"] = invalid
        else
            entry["rangeEnd"] = sabr_cacheParseNumberToken(endToken)
        end if
    else
        return invalid
    end if

    entry["fileName"] = fileName
    entry["path"] = `${sabr_cacheEnsureBasePath()}/${fileName}`

    extra = sabr_cacheLookupMetadata(fileName)
    if IsAssociativeArray(extra)
        if extra.DoesExist("startSegmentIndex") then entry["startSegmentIndex"] = extra.Lookup("startSegmentIndex")
        if extra.DoesExist("endSegmentIndex") then entry["endSegmentIndex"] = extra.Lookup("endSegmentIndex")
        if extra.DoesExist("startTimeMs") then entry["startTimeMs"] = extra.Lookup("startTimeMs")
        if extra.DoesExist("durationMs") then entry["durationMs"] = extra.Lookup("durationMs")
        if extra.DoesExist("timescale") then entry["timescale"] = extra.Lookup("timescale")
        if extra.DoesExist("startTicks") then entry["startTicks"] = extra.Lookup("startTicks")
        if extra.DoesExist("durationTicks") then entry["durationTicks"] = extra.Lookup("durationTicks")
        if extra.DoesExist("sequenceNumber") then entry["sequenceNumber"] = extra.Lookup("sequenceNumber")
        if extra.DoesExist("formatId") then entry["formatId"] = extra.Lookup("formatId")
        if extra.DoesExist("playerTimeMs") then entry["playerTimeMs"] = extra.Lookup("playerTimeMs")
        if extra.DoesExist("rangeStart")
            metaStart = sabr_cacheNormalizeNumber(extra.Lookup("rangeStart"))
            if metaStart <> invalid then entry["rangeStart"] = metaStart
        end if
        if extra.DoesExist("rangeEnd")
            metaEnd = sabr_cacheNormalizeNumber(extra.Lookup("rangeEnd"))
            if metaEnd <> invalid then entry["rangeEnd"] = metaEnd
        end if
    end if
    return entry
end function

function sabr_cacheListEntries(mediaIdHash as string, contentType as string, itag as dynamic, trackId = "" as string) as object
    base = sabr_cacheEnsureBasePath()
    fs = CreateObject("roFileSystem")
    names = fs.GetDirectoryListing(base)
    results = []
    if not IsArray(names) then return results

    sabr_cachePruneMetadata(names)

    targetMedia = sabr_cacheSanitize(mediaIdHash)
    targetType = sabr_cacheSanitize(contentType)
    targetItag = sabr_cacheSanitize(itag)
    targetTrack = sabr_cacheSanitize(trackId)

    for each name in names
        entry = sabr_cacheParseEntry(name)
        if not IsAssociativeArray(entry) then continue for
        entryMedia = sabr_cacheSanitize(entry.mediaIdHash)
        entryType = sabr_cacheSanitize(entry.contentType)
        entryItag = sabr_cacheSanitize(entry.itag)
        entryTrack = sabr_cacheSanitize(entry.trackId)
        if entryMedia <> targetMedia then continue for
        if entryType <> targetType then continue for
        if entryItag <> targetItag then continue for
        if targetTrack <> "" and entryTrack <> targetTrack then continue for
        if targetTrack = "" and entryTrack <> "" then continue for
        results.push(entry)
    end for
    return results
end function

' Writes a fully materialized segment to disk and records metadata used for
' future SABR lookups. Returns an object describing the cache entry.
function sabr_cacheStoreSegment(options as object) as object
    if not IsAssociativeArray(options) then return invalid

    bytes = options?.bytes
    chunkFiles = options?.chunkFiles
    dataPath = options?.dataPath
    chunkCountOpt = sabr_cacheNormalizeNumber(options?.chunkCount)
    totalBytesOpt = sabr_cacheNormalizeNumber(options?.totalBytes)

    path = sabr_cacheBuildFilename(
    options?.mediaIdHash,
    options?.contentType,
    options?.itag,
    options?.trackId ?? "",
    options?.isInit = true,
    options?.rangeStart,
    options?.rangeEnd
    )

    base = sabr_cacheEnsureBasePath()
    fs = CreateObject("roFileSystem")
    if not fs.Exists(base)
        fs.CreateDirectory(base)
    end if

    success = false
    if GetInterface(bytes, "ifByteArray") <> invalid and bytes.count() > 0
        success = bytes.writeFile(path)
        if totalBytesOpt = invalid then totalBytesOpt = bytes.count()
    else if IsArray(chunkFiles) and chunkFiles.count() > 0
        success = sabr_cacheWriteChunksToFile(path, chunkFiles)
    else if IsString(dataPath) and dataPath <> ""
        success = sabr_cacheCopyFile(dataPath, path)
    end if

    if success <> true then return invalid

    fileName = sabr_cacheExtractFileName(path)
    extra = {}
    if isValid(options?.contentType) then extra.contentType = options.contentType
    if isValid(options?.itag) then extra.itag = options.itag
    if isValid(options?.trackId) then extra.trackId = options.trackId
    if isValid(options?.mediaIdHash) then extra.mediaIdHash = options.mediaIdHash
    nowMs = sabr_cacheCurrentTimestampMs()
    if isValid(options?.startSegmentIndex)
        extra.startSegmentIndex = options.startSegmentIndex
    end if
    if isValid(options?.endSegmentIndex)
        extra.endSegmentIndex = options.endSegmentIndex
    end if
    if isValid(options?.startTimeMs)
        extra.startTimeMs = options.startTimeMs
    end if
    if isValid(options?.durationMs)
        extra.durationMs = options.durationMs
    end if
    if isValid(options?.timescale)
        extra.timescale = options.timescale
    end if
    if isValid(options?.startTicks)
        extra.startTicks = options.startTicks
    end if
    if isValid(options?.durationTicks)
        extra.durationTicks = options.durationTicks
    end if
    if isValid(options?.sequenceNumber)
        extra.sequenceNumber = options.sequenceNumber
    else if isValid(extra?.startSegmentIndex)
        extra.sequenceNumber = extra.startSegmentIndex
    end if
    formatIdOpt = options?.formatId
    if IsAssociativeArray(formatIdOpt)
        extra.formatId = formatIdOpt
    end if
    if isValid(options?.playerTimeMs)
        extra["playerTimeMs"] = options.playerTimeMs
    end if
    if isValid(options?.rangeStart)
        extra["rangeStart"] = sabr_cacheNormalizeNumber(options.rangeStart)
    end if
    if isValid(options?.rangeEnd)
        extra["rangeEnd"] = sabr_cacheNormalizeNumber(options.rangeEnd)
    end if
    if chunkCountOpt <> invalid then extra.chunkCount = chunkCountOpt
    if totalBytesOpt <> invalid then extra.totalBytes = totalBytesOpt
    extra.storedAtMs = nowMs
    extra.lastAccessMs = nowMs
    extra.delivered = false
    extra.seekProtectedUntil = nowMs + SABR_CACHE_SEEK_GUARD_MS
    sabr_cacheRememberMetadata(fileName, extra)
    sizeLabel = totalBytesOpt
    if sizeLabel = invalid and GetInterface(bytes, "ifByteArray") <> invalid
        sizeLabel = bytes.count()
    end if
    sabr_cacheLog(log_level_Type.DEBUG, `[SabrCache] stored file=${fileName} size=${sabr_cacheNormalizeNumber(sizeLabel)} storedAt=${nowMs}`)

    if IsString(options?.mediaIdHash) and options.mediaIdHash <> ""
        m.sabrCacheActiveMediaId = options.mediaIdHash
    end if

    ' Trigger maintenance after storing a new segment to enforce quotas
    sabr_cacheRunMaintenance(path)

    sabr_cacheLogSnapshot("store", path)
    return {
        "path": path
        "rangeStart": options?.rangeStart
        "rangeEnd": options?.rangeEnd
    }
end function

' Loads a cached segment (or stream) from disk to satisfy a player request,
' wiring up metadata and ByteArray content as needed.
function sabr_cacheLoadSegment(params as object) as object
    if not IsAssociativeArray(params) then return invalid
    entries = sabr_cacheListEntries(params?.mediaIdHash, params?.contentType, params?.itag, params?.trackId ?? "")
    requestedStart = sabr_cacheNormalizeNumber(params?.requestedStart)
    requestedEnd = sabr_cacheNormalizeNumber(params?.requestedEnd)
    sabr_cacheLog(log_level_Type.DEBUG, `[SabrCache] load request media=${params?.mediaIdHash} type=${params?.contentType} itag=${params?.itag} track=${params?.trackId ?? ""} start=${requestedStart} end=${requestedEnd} entries=${entries.count()}`)
    if entries.count() = 0 then return invalid

    hasStart = requestedStart <> invalid
    hasEnd = requestedEnd <> invalid

    best = invalid
    for each entry in entries
        sabr_cacheLog(log_level_Type.DEBUG, `[SabrCache] candidate file=${entry?.fileName} init=${entry?.isInit} rangeStart=${entry?.rangeStart} rangeEnd=${entry?.rangeEnd}`)
        if entry["isInit"] = true
            if params?.isInit = true
                best = entry
                exit for
            else
                continue for
            end if
        end if

        if params?.isInit = true then continue for

        coverageStart = entry?.rangeStart
        coverageEnd = entry?.rangeEnd
        if coverageStart = invalid or coverageEnd = invalid then continue for

        matches = true
        if hasStart and requestedStart < coverageStart then matches = false
        if matches and hasEnd and requestedEnd > coverageEnd then matches = false

        if matches = false then
            ' allow exact end match when end unknown
            if hasStart and coverageStart = requestedStart and hasEnd = false
                matches = true
            end if
            if matches = false
                sabr_cacheLog(log_level_Type.DEBUG, `[SabrCache] rejected file=${entry?.fileName} coverage=${coverageStart}-${coverageEnd} requested=${requestedStart}-${requestedEnd}`)
            end if
        end if

        if matches
            if best = invalid
                best = entry
            else
                ' prefer tighter coverage
                bestSpan = (best.rangeEnd - best.rangeStart)
                entrySpan = (coverageEnd - coverageStart)
                if entrySpan < bestSpan
                    best = entry
                end if
            end if
        end if
    end for

    if params?.isInit = true and best = invalid
        ' fallback: use first init if available
        for each entry in entries
            if entry["isInit"] = true
                best = entry
                exit for
            end if
        end for
    end if

    if best = invalid then return invalid

    filePath = best?.path
    if not IsString(filePath) or filePath = "" then return invalid

    fileSize = sabr_cacheGetFileSize(filePath)

    sabr_cacheRecordAccess(best)

    coverageStart = sabr_cacheNormalizeNumber(best?.rangeStart)
    coverageEnd = sabr_cacheNormalizeNumber(best?.rangeEnd)
    if best.isInit = true
        coverageStart = 0
        if fileSize <> invalid
            coverageEnd = coverageStart + fileSize - 1
        end if
    end if

    requestedStartVal = requestedStart
    requestedEndVal = requestedEnd

    sabr_cacheLogSnapshot("load", best.path)

    result = invalid

    if params?.isInit = true or best.isInit = true
        initBytes = CreateObject("roByteArray")
        if initBytes.readFile(filePath) <> true then return invalid
        if fileSize = invalid then fileSize = initBytes.count()
        coverageStart = 0
        if fileSize <> invalid
            coverageEnd = coverageStart + fileSize - 1
        else
            coverageEnd = initBytes.count() - 1
        end if
        result = {
            "data": initBytes
            "rangeStart": coverageStart
            "rangeEnd": coverageEnd
            "path": filePath
            "coverage": {
                "rangeStart": coverageStart
                "rangeEnd": coverageEnd
            }
        }
        result["coverageStart"] = coverageStart
        result["coverageEnd"] = coverageEnd
    else
        emptyBytes = CreateObject("roByteArray")
        inferredCoverageStart = coverageStart
        if inferredCoverageStart = invalid and requestedStartVal <> invalid
            inferredCoverageStart = requestedStartVal
        end if
        if inferredCoverageStart = invalid then inferredCoverageStart = 0

        inferredCoverageEnd = coverageEnd
        if inferredCoverageEnd = invalid and requestedEndVal <> invalid
            inferredCoverageEnd = requestedEndVal
        end if
        if inferredCoverageEnd = invalid and fileSize <> invalid
            inferredCoverageEnd = inferredCoverageStart + fileSize - 1
        end if

        effectiveStart = inferredCoverageStart
        if requestedStartVal <> invalid then effectiveStart = requestedStartVal

        effectiveEnd = inferredCoverageEnd
        if requestedEndVal <> invalid then effectiveEnd = requestedEndVal
        if effectiveEnd <> invalid and effectiveStart <> invalid and effectiveEnd < effectiveStart
            effectiveEnd = effectiveStart - 1
        end if

        result = {
            "data": emptyBytes
            "rangeStart": effectiveStart
            "rangeEnd": effectiveEnd
            "path": filePath
            "coverage": {
                "rangeStart": inferredCoverageStart
                "rangeEnd": inferredCoverageEnd
            }
        }
        result["coverageStart"] = inferredCoverageStart
        result["coverageEnd"] = inferredCoverageEnd
        if fileSize <> invalid then result["dataLength"] = fileSize
    end if

    if not IsAssociativeArray(result) then return invalid

    sabr_cacheMarkDelivered(best)
    sabr_cacheRunMaintenance(best.path)
    return result
end function

function sabr_cacheGetFileSize(path as string) as dynamic
    if not IsString(path) or path = "" then return invalid
    fs = CreateObject("roFileSystem")
    stat = invalid
    try
        stat = fs.Stat(path)
    catch e
        stat = invalid
    end try
    if IsAssociativeArray(stat)
        sizeVal = stat.Lookup("size")
        if sizeVal = invalid then sizeVal = stat.Lookup("length")
        return sizeVal
    end if
    return invalid
end function

sub sabr_cacheRecordAccess(entry as object)
    if not IsAssociativeArray(entry) then return
    fileName = entry?.fileName
    if not IsString(fileName) or fileName = "" then return

    table = sabr_cacheMetadataTable()
    metadata = table.Lookup(fileName)
    if not IsAssociativeArray(metadata)
        metadata = {}
    end if

    timestamp = sabr_cacheCurrentTimestampMs()
    metadata["lastAccessMs"] = timestamp
    if not metadata.DoesExist("storedAtMs") or not isValid(metadata.storedAtMs)
        fs = CreateObject("roFileSystem")
        metadata["storedAtMs"] = Int(sabr_cacheExtractModifiedTicks(fs, entry?.path))
    end if
    table[fileName] = metadata
    sabr_cacheLog(log_level_Type.DEBUG, `[SabrCache] access file=${fileName} lastAccessMs=${metadata.lastAccessMs}`)
end sub

' Marks a cache entry as delivered, recording timestamps and delivery progress
' so maintenance can safely evict it once guard thresholds expire.
sub sabr_cacheMarkDelivered(entry as object)
    if not IsAssociativeArray(entry) then return
    fileName = entry?.fileName
    if not IsString(fileName) or fileName = "" then return

    table = sabr_cacheMetadataTable()
    metadata = table.Lookup(fileName)
    if not IsAssociativeArray(metadata)
        metadata = {}
    end if

    timestamp = sabr_cacheCurrentTimestampMs()
    metadata["delivered"] = true
    metadata["deliveredAtMs"] = timestamp
    metadata["lastAccessMs"] = timestamp
    if not metadata.DoesExist("storedAtMs") or not isValid(metadata.storedAtMs)
        fs = CreateObject("roFileSystem")
        metadata["storedAtMs"] = Int(sabr_cacheExtractModifiedTicks(fs, entry?.path))
    end if
    table[fileName] = metadata
    sabr_cacheUpdateDeliveryProgress(entry, metadata)
    mediaId = entry?.mediaIdHash
    if mediaId = invalid or mediaId = ""
        mediaId = metadata?.mediaIdHash
    end if
    if IsString(mediaId) and mediaId <> ""
        m.sabrCacheActiveMediaId = mediaId
    end if
    sabr_cacheLog(log_level_Type.DEBUG, `[SabrCache] delivered file=${fileName} deliveredAt=${metadata.deliveredAtMs}`)
end sub

sub sabr_cacheMarkDeliveredByPath(path as string, reason as string, extra = invalid as dynamic)
    if not IsString(path) or path = "" then return
    fileName = sabr_cacheExtractFileName(path)
    entry = sabr_cacheParseEntry(fileName)
    if not IsAssociativeArray(entry)
        entry = {
            "fileName": fileName
            "path": path
        }
    else
        entry["path"] = path
    end if
    if IsAssociativeArray(extra)
        for each key in extra
            entry[key] = extra[key]
        end for
        mediaHint = sabr_cacheSanitize(extra?.mediaIdHash)
        if mediaHint <> ""
            entry["mediaIdHash"] = mediaHint
            m.sabrCacheActiveMediaId = mediaHint
        end if
    end if
    sabr_cacheLog(log_level_Type.DEBUG, `[SabrCache] mark-delivered path=${fileName} reason=${reason}`)
    sabr_cacheMarkDelivered(entry)
    sabr_cacheRunMaintenance(path)
end sub

function sabr_cacheDeliveryProgress() as object
    progress = m?.sabr_cacheDeliveryProgress
    if not IsAssociativeArray(progress)
        progress = {}
        m.sabr_cacheDeliveryProgress = progress
    end if
    return progress
end function

function sabr_cacheEnsureDeliveryProgressKey(contentType as dynamic, itag as dynamic, trackId as dynamic) as object
    key = `${sabr_cacheSanitize(contentType)}|${sabr_cacheSanitize(itag)}|${sabr_cacheSanitize(trackId)}`
    if key = "||" then key = "unknown|none|main"
    progress = sabr_cacheDeliveryProgress()
    info = progress.Lookup(key)
    if not IsAssociativeArray(info)
        info = {}
        progress[key] = info
        m.sabr_cacheDeliveryProgress = progress
    end if
    return info
end function

sub sabr_cacheUpdateProgressForSeek(contentType as dynamic, format as dynamic, sequenceNumber as dynamic, rangeStart as dynamic, playerTimeMs as dynamic)
    itag = invalid
    trackId = invalid
    if IsAssociativeArray(format)
        itag = format?.itag
        trackId = format?.audioTrackId
    end if

    info = sabr_cacheEnsureDeliveryProgressKey(contentType, itag, trackId)
    if not IsAssociativeArray(info) then return

    seqVal = sabr_cacheNormalizeNumber(sequenceNumber)
    if seqVal <> invalid then info.lastSequence = seqVal

    rangeVal = sabr_cacheNormalizeNumber(rangeStart)
    if rangeVal <> invalid then info.lastRangeStart = rangeVal

    playerVal = sabr_cacheNormalizeNumber(playerTimeMs)
    if playerVal <> invalid then info.lastPlayerTimeMs = playerVal

    info.updatedAtMs = sabr_cacheCurrentTimestampMs()
    if rangeVal <> invalid
        currentGuard = sabr_cacheNormalizeNumber(info?.seekGuardRange)
        if currentGuard = invalid or rangeVal <= currentGuard
            info.seekGuardRange = rangeVal
            info.seekGuardExpiresAt = info.updatedAtMs + SABR_CACHE_SEEK_GUARD_MS
        end if
    end if

    progress = sabr_cacheDeliveryProgress()
    itagKey = sabr_cacheSanitize(itag)
    trackKey = sabr_cacheSanitize(trackId)
    typeKey = sabr_cacheSanitize(contentType)
    if typeKey = "" then typeKey = "unknown"
    if itagKey = "" then itagKey = "none"
    if trackKey = "" then trackKey = "main"
    progress[`${typeKey}|${itagKey}|${trackKey}`] = info
    m.sabr_cacheDeliveryProgress = progress
end sub

function sabr_cacheBuildDeliveryKey(entry as object) as string
    if not IsAssociativeArray(entry) then return ""
    typeKey = sabr_cacheSanitize(entry?.contentType)
    if typeKey = "" then typeKey = "unknown"
    itagKey = sabr_cacheSanitize(entry?.itag)
    if itagKey = "" then itagKey = "none"
    trackKey = sabr_cacheSanitize(entry?.trackId)
    if trackKey = "" then trackKey = "main"
    return `${typeKey}|${itagKey}|${trackKey}`
end function

function sabr_cacheExtractSequence(entry as object, metadata as object) as dynamic
    seqVal = sabr_cacheNormalizeNumber(metadata?.sequenceNumber)
    if seqVal = invalid then seqVal = sabr_cacheNormalizeNumber(metadata?.startSegmentIndex)
    if seqVal = invalid and IsAssociativeArray(entry)
        seqVal = sabr_cacheNormalizeNumber(entry?.sequenceNumber)
        if seqVal = invalid then seqVal = sabr_cacheNormalizeNumber(entry?.startSegmentIndex)
    end if
    return seqVal
end function

sub sabr_cacheUpdateDeliveryProgress(entry as object, metadata as object)
    progress = sabr_cacheDeliveryProgress()
    key = sabr_cacheBuildDeliveryKey(entry)
    if key = "" then return
    info = sabr_cacheEnsureDeliveryProgressKey(entry?.contentType, entry?.itag, entry?.trackId)

    seqVal = sabr_cacheExtractSequence(entry, metadata)
    if seqVal <> invalid
        lastSeq = sabr_cacheNormalizeNumber(info?.lastSequence)
        if lastSeq = invalid or seqVal > lastSeq
            info.lastSequence = seqVal
        end if
    end if

    rangeStart = sabr_cacheNormalizeNumber(metadata?.rangeStart)
    if rangeStart = invalid and IsAssociativeArray(entry)
        rangeStart = sabr_cacheNormalizeNumber(entry?.rangeStart)
    end if
    if rangeStart <> invalid
        lastRange = sabr_cacheNormalizeNumber(info?.lastRangeStart)
        if lastRange = invalid or rangeStart > lastRange
            info.lastRangeStart = rangeStart
        end if
    end if

    deliveredAt = sabr_cacheNormalizeNumber(metadata?.deliveredAtMs)
    if deliveredAt = invalid
        deliveredAt = sabr_cacheCurrentTimestampMs()
    end if
    info.lastDeliveredAtMs = deliveredAt
    info.updatedAtMs = sabr_cacheCurrentTimestampMs()

    startTimeMs = sabr_cacheNormalizeNumber(metadata?.startTimeMs)
    if startTimeMs = invalid and IsAssociativeArray(metadata?.timeRange)
        ticks = sabr_cacheNormalizeNumber(metadata.timeRange?.startTicks)
        timescale = sabr_cacheNormalizeNumber(metadata.timeRange?.timescale)
        if ticks <> invalid and timescale <> invalid and timescale > 0
            startTimeMs = Int((ticks * 1000) / timescale)
        end if
    end if
    if startTimeMs = invalid and IsAssociativeArray(entry)
        startTimeMs = sabr_cacheNormalizeNumber(entry?.startTimeMs)
    end if
    if startTimeMs <> invalid
        info.lastPlayerTimeMs = startTimeMs
    end if

    progress[key] = info
    m.sabr_cacheDeliveryProgress = progress
end sub

' Determines whether a delivered segment should be temporarily preserved
' (recent delivery, seek guard, or proximity to current playback).
function sabr_cacheShouldDeferDeliveredRemoval(entry as object, metadata as object, nowMs as integer) as boolean
    if not IsAssociativeArray(metadata) then return false
    if metadata?.delivered <> true then return false

    deliveredAt = sabr_cacheNormalizeNumber(metadata?.deliveredAtMs)
    if deliveredAt <> invalid and nowMs - deliveredAt < SABR_CACHE_DELIVERED_MIN_AGE_MS
        return true
    end if

    key = sabr_cacheBuildDeliveryKey(entry)
    if key = "" then return false
    progress = sabr_cacheDeliveryProgress()
    info = progress.Lookup(key)
    if not IsAssociativeArray(info) then return false

    guardRange = sabr_cacheNormalizeNumber(info?.seekGuardRange)
    guardExpiry = sabr_cacheNormalizeNumber(info?.seekGuardExpiresAt)
    rangeStartValue = sabr_cacheNormalizeNumber(metadata?.rangeStart)
    if rangeStartValue = invalid and IsAssociativeArray(entry)
        rangeStartValue = sabr_cacheNormalizeNumber(entry?.rangeStart)
    end if
    if guardRange <> invalid and guardExpiry <> invalid and nowMs <= guardExpiry
        if rangeStartValue <> invalid and rangeStartValue <= guardRange
            return true
        end if
    end if

    seqVal = sabr_cacheExtractSequence(entry, metadata)
    lastSeq = sabr_cacheNormalizeNumber(info?.lastSequence)
    if seqVal <> invalid and lastSeq <> invalid
        diffSeq = lastSeq - seqVal
        if diffSeq < SABR_CACHE_DELIVERED_SEQUENCE_GUARD
            return true
        end if
    end if

    rangeStart = sabr_cacheNormalizeNumber(metadata?.rangeStart)
    lastRange = sabr_cacheNormalizeNumber(info?.lastRangeStart)
    if rangeStart <> invalid and lastRange <> invalid
        diffRange = lastRange - rangeStart
        if diffRange >= 0 and diffRange < SABR_CACHE_DELIVERED_RANGE_GUARD
            return true
        end if
    end if

    return false
end function

' Evaluates whether a pending (not-yet-delivered) segment is too old or far
' from the current playback position and should be removed.
function sabr_cacheShouldCullPending(entry as object, metadata as object) as boolean
    if not IsAssociativeArray(metadata) then return false
    key = sabr_cacheBuildDeliveryKey(entry)
    if key = "" then return false
    progress = sabr_cacheDeliveryProgress()
    info = progress.Lookup(key)
    if not IsAssociativeArray(info) then return false

    nowMs = sabr_cacheCurrentTimestampMs()

    seqVal = sabr_cacheExtractSequence(entry, metadata)
    lastSeq = sabr_cacheNormalizeNumber(info?.lastSequence)
    if seqVal <> invalid and lastSeq <> invalid
        diffSeq = lastSeq - seqVal
        if diffSeq > SABR_CACHE_PENDING_SEQUENCE_DISTANCE
            return true
        end if
    end if

    rangeStart = sabr_cacheNormalizeNumber(metadata?.rangeStart)
    if rangeStart = invalid and IsAssociativeArray(entry)
        rangeStart = sabr_cacheNormalizeNumber(entry?.rangeStart)
    end if
    lastRange = sabr_cacheNormalizeNumber(info?.lastRangeStart)
    guardRange = sabr_cacheNormalizeNumber(info?.seekGuardRange)
    guardExpiry = sabr_cacheNormalizeNumber(info?.seekGuardExpiresAt)
    if guardRange <> invalid and guardExpiry <> invalid and nowMs <= guardExpiry
        if rangeStart <> invalid and rangeStart <= guardRange
            return false
        end if
    end if
    if rangeStart <> invalid and lastRange <> invalid
        diffRange = lastRange - rangeStart
        if diffRange > SABR_CACHE_PENDING_RANGE_DISTANCE
            return true
        end if
    end if

    playerTimeMs = sabr_cacheNormalizeNumber(metadata?.playerTimeMs)
    if playerTimeMs = invalid and not IsAssociativeArray(metadata?.startTimeMs)
        playerTimeMs = sabr_cacheNormalizeNumber(metadata?.startTimeMs)
    end if
    if playerTimeMs = invalid and IsAssociativeArray(entry)
        playerTimeMs = sabr_cacheNormalizeNumber(entry?.startTimeMs)
    end if
    lastPlayerMs = sabr_cacheNormalizeNumber(info?.lastPlayerTimeMs)
    if playerTimeMs <> invalid and lastPlayerMs <> invalid
        diffMs = lastPlayerMs - playerTimeMs
        if diffMs > SABR_CACHE_PENDING_PLAYER_TIME_MS
            return true
        end if
    end if

    return false
end function

' Main maintenance routine that refreshes metadata, removes stale/delivered
' segments, and enforces overall cache quotas. activePath marks a segment
' currently being written so we avoid removing it mid-flight.
sub sabr_cacheRunMaintenance(activePath as string)
    base = sabr_cacheEnsureBasePath()
    fs = CreateObject("roFileSystem")
    names = fs.GetDirectoryListing(base)
    if not IsArray(names) then return

    loggerRef = sabr_cacheLogger()
    maintenanceTimer = invalid
    if isValid(loggerRef)
        maintenanceTimer = loggerRef.mark()
    end if

    nowMs = sabr_cacheCurrentTimestampMs()
    table = sabr_cacheMetadataTable()
    removedAny = false
    removedCount = 0
    focusPath = ""
    remaining = []
    totalBytes = 0
    activeMedia = sabr_cacheSanitize(m?.sabrCacheActiveMediaId)

    sabr_cacheLog(log_level_Type.DEBUG, `[SabrCache] maintenance start total=${names.count()} activePath=${activePath}`)
    sabr_cacheLogPendingEntries(table, base, "start")

    for each name in names
        path = `${base}/${name}`
        if Right(name, 4) <> ".bin"
            if name = "segments"
                ' handled separately in sabr_cacheCleanupSegmentTemps
            else
                statDir = fs.Stat(path)
                isDir = false
                if IsAssociativeArray(statDir)
                    entryType = statDir.Lookup("type")
                    if IsString(entryType) and LCase(entryType) = "directory"
                        isDir = true
                    end if
                end if
                if isDir
                    childEntries = fs.GetDirectoryListing(path)
                    ' Prune empty directories that linger between runs
                    if IsArray(childEntries) and childEntries.count() = 0
                        sabr_cacheDeleteDirectory(fs, path)
                    end if
                end if
            end if
            continue for
        end if
        entryInfo = sabr_cacheParseEntry(name)
        if not IsAssociativeArray(entryInfo)
            entryInfo = {
                "fileName": name
            }
        end if
        entryInfo["path"] = path

        metadata = table.Lookup(name)
        if not IsAssociativeArray(metadata)
            metadata = {}
        end if

        if not metadata.DoesExist("contentType") and entryInfo?.contentType <> invalid
            metadata["contentType"] = entryInfo.contentType
        end if
        if not metadata.DoesExist("itag") and entryInfo?.itag <> invalid
            metadata["itag"] = entryInfo.itag
        end if
        if not metadata.DoesExist("trackId") and entryInfo?.trackId <> invalid
            metadata["trackId"] = entryInfo.trackId
        end if
        if not metadata.DoesExist("mediaIdHash") and entryInfo?.mediaIdHash <> invalid
            metadata["mediaIdHash"] = entryInfo.mediaIdHash
        end if
        table[name] = metadata

        delivered = metadata?.delivered = true
        storedAtMs = sabr_cacheNormalizeNumber(metadata?.storedAtMs)
        deliveredAtMs = sabr_cacheNormalizeNumber(metadata?.deliveredAtMs)
        lastTouchMs = sabr_cacheNormalizeNumber(metadata?.lastAccessMs)

        if storedAtMs = invalid or storedAtMs <= 0
            storedAtMs = Int(sabr_cacheExtractModifiedTicks(fs, path))
            metadata["storedAtMs"] = storedAtMs
            table[name] = metadata
        end if
        if lastTouchMs = invalid or lastTouchMs <= 0
            if deliveredAtMs <> invalid and deliveredAtMs > 0
                lastTouchMs = deliveredAtMs
            else
                lastTouchMs = storedAtMs
            end if
            metadata["lastAccessMs"] = lastTouchMs
            table[name] = metadata
        end if

        protectUntil = sabr_cacheNormalizeNumber(metadata?.seekProtectedUntil)
        if protectUntil <> invalid and nowMs < protectUntil
            sabr_cacheLog(log_level_Type.DEBUG, `[SabrCache] skip removal file=${name} reason=seek-guard`)
            sizeVal = sabr_cacheExtractSize(fs, path)
            info = {
                "entry": entryInfo,
                "metadata": metadata,
                "size": sizeVal,
                "storedAt": storedAtMs
            }
            remaining.push(info)
            totalBytes = totalBytes + sizeVal
            continue for
        end if

        shouldRemove = false
        removalReason = ""
        isInitEntry = entryInfo?.isInit = true
        entryMediaId = sabr_cacheSanitize(entryInfo?.mediaIdHash)

        if delivered
            if sabr_cacheShouldDeferDeliveredRemoval(entryInfo, metadata, nowMs)
                sabr_cacheLog(log_level_Type.DEBUG, `[SabrCache] skip removal file=${name} reason=recent-delivery`)
            else
                shouldRemove = true
                removalReason = "delivered"
            end if
        else
            if sabr_cacheShouldCullPending(entryInfo, metadata)
                shouldRemove = true
                removalReason = "orphan-early"
            else
                if storedAtMs <> invalid and storedAtMs > 0
                    ageMs = nowMs - storedAtMs
                    if ageMs >= MAX_SABR_CACHE_SEGMENT_AGE_MS
                        shouldRemove = true
                        removalReason = `stale-age stored=${storedAtMs} age=${ageMs}`
                    end if
                else if lastTouchMs <> invalid and lastTouchMs > 0
                    ageFallback = nowMs - lastTouchMs
                    if ageFallback >= MAX_SABR_CACHE_SEGMENT_AGE_MS
                        shouldRemove = true
                        removalReason = `stale-lastTouch last=${lastTouchMs} age=${ageFallback}`
                    end if
                end if
            end if
        end if

        if shouldRemove and isInitEntry
            if activeMedia <> "" and entryMediaId = activeMedia
                shouldRemove = false
                removalReason = ""
            end if
        end if

        if shouldRemove and activePath <> "" and path = activePath and delivered = false
            shouldRemove = false
            sabr_cacheLog(log_level_Type.DEBUG, `[SabrCache] skip removal file=${name} reason=active-request`)
        end if

        if shouldRemove
            focus = sabr_cacheFinalizeRemoval(fs, base, table, entryInfo, metadata, removalReason)
            if focus <> ""
                removedAny = true
                removedCount = removedCount + 1
                focusPath = focus
            end if
        else
            sizeVal = sabr_cacheExtractSize(fs, path)
            info = {
                "entry": entryInfo,
                "metadata": metadata,
                "size": sizeVal,
                "storedAt": storedAtMs
            }
            remaining.push(info)
            totalBytes = totalBytes + sizeVal
        end if
    end for

    keys = table.keys()
    for each key in keys
        lookupPath = `${base}/${key}`
        if not fs.Exists(lookupPath)
            table.Delete(key)
            removedAny = true
            focusPath = lookupPath
        end if
    end for

    if activeMedia <> ""
        for idx = remaining.count() - 1 to 0 step -1
            info = remaining[idx]
            entryMedia = sabr_cacheSanitize(info.entry?.mediaIdHash)
            if entryMedia <> "" and entryMedia <> activeMedia
                ' Drop segments belonging to previous mediaId
                focus = sabr_cacheFinalizeRemoval(fs, base, table, info.entry, info.metadata, "foreign-media")
                if focus <> ""
                    removedAny = true
                    removedCount = removedCount + 1
                    focusPath = focus
                    totalBytes = totalBytes - info.size
                end if
                remaining.Delete(idx)
            end if
        end for
    end if

    if SABR_CACHE_TOTAL_SIZE_LIMIT > 0 and totalBytes > SABR_CACHE_TOTAL_SIZE_LIMIT
        while totalBytes > SABR_CACHE_TOTAL_SIZE_LIMIT and remaining.count() > 0
            oldestIdx = 0
            oldestVal = remaining[0]?.storedAt
            for idx = 1 to remaining.count() - 1
                info = remaining[idx]
                value = info?.storedAt
                if oldestVal = invalid or (value <> invalid and value < oldestVal)
                    oldestIdx = idx
                    oldestVal = value
                end if
            end for
            info = remaining[oldestIdx]
            focus = sabr_cacheFinalizeRemoval(fs, base, table, info.entry, info.metadata, "quota")
            if focus <> ""
                removedAny = true
                removedCount = removedCount + 1
                focusPath = focus
            end if
            totalBytes = totalBytes - info.size
            remaining.Delete(oldestIdx)
        end while
    end if

    sabr_cacheCleanupSegmentTemps(nowMs)

    if maintenanceTimer <> invalid
        summaryLabel = `[SabrCache] maintenance duration removed=${removedCount} remaining=${remaining.count()} bytes=${totalBytes}`
        loggerRef.printTime(log_level_Type.INFO, summaryLabel, maintenanceTimer, -1)
    end if

    if removedAny
        updated = fs.GetDirectoryListing(base)
        sabr_cachePruneMetadata(updated)
        sabr_cacheLogSnapshot("cleanup", focusPath)
        entriesCount = 0
        if IsArray(updated)
            entriesCount = updated.count()
        end if
        sabr_cacheLog(log_level_Type.INFO, `[SabrCache] maintenance removed=${removedCount} remaining=${entriesCount}`)
    else
        sabr_cacheLog(log_level_Type.DEBUG, "[SabrCache] maintenance removed=0")
    end if
    sabr_cacheLogPendingEntries(table, base, "end")
end sub

sub sabr_cacheLogPendingEntries(table as object, base as string, phase as string)
    if not IsAssociativeArray(table) then return

    nowMs = sabr_cacheCurrentTimestampMs()
    pendingLabels = []
    deliveredLabels = []

    keys = table.keys()
    total = 0
    deliveredCount = 0
    pendingCount = 0

    for each key in keys
        metadata = table.Lookup(key)
        total = total + 1
        deliveredFlag = false
        if IsAssociativeArray(metadata)
            deliveredValue = metadata?.delivered
            if isValid(deliveredValue)
                deliveredFlag = (deliveredValue = true)
            end if
        end if

        storedMs = invalid
        lastMs = invalid
        deliveredMs = invalid
        if IsAssociativeArray(metadata)
            storedMs = sabr_cacheNormalizeNumber(metadata?.storedAtMs)
            lastMs = sabr_cacheNormalizeNumber(metadata?.lastAccessMs)
            deliveredMs = sabr_cacheNormalizeNumber(metadata?.deliveredAtMs)
        end if

        ageStored = invalid
        ageLast = invalid
        if storedMs <> invalid and storedMs > 0
            ageStored = nowMs - storedMs
        end if
        if lastMs <> invalid and lastMs > 0
            ageLast = nowMs - lastMs
        end if

        statusLabel = "pending"
        if deliveredFlag then statusLabel = "delivered"

        infoLabel = `${key} status=${statusLabel}`
        if ageStored <> invalid
            infoLabel = `${infoLabel} ageStored=${ageStored}`
        end if
        if ageLast <> invalid
            infoLabel = `${infoLabel} ageLast=${ageLast}`
        end if
        if deliveredMs <> invalid
            infoLabel = `${infoLabel} deliveredAtAge=${nowMs - deliveredMs}`
        end if

        if deliveredFlag
            deliveredCount = deliveredCount + 1
            deliveredLabels.push(infoLabel)
        else
            pendingCount = pendingCount + 1
            pendingLabels.push(infoLabel)
        end if
    end for

    labelPending = sabr_cacheBuildSample(pendingLabels)
    labelDelivered = sabr_cacheBuildSample(deliveredLabels)
    sabr_cacheLog(log_level_Type.DEBUG, `[SabrCache] state phase=${phase} total=${total} pending=${pendingCount} delivered=${deliveredCount}`)
    if pendingCount > 0
        sabr_cacheLog(log_level_Type.DEBUG, `[SabrCache] pending sample (${pendingLabels.count()} total) -> ${labelPending}`)
    end if
    if deliveredCount > 0
        sabr_cacheLog(log_level_Type.DEBUG, `[SabrCache] delivered sample (${deliveredLabels.count()} total) -> ${labelDelivered}`)
    end if
end sub

function sabr_cacheBuildSample(items as object) as string
    if not IsArray(items) then return ""
    maxItems = 10
    summary = ""
    total = items.count()
    if total = 0 then return summary
    limit = maxItems
    if total < limit then limit = total
    for idx = 0 to limit - 1
        entry = items[idx]
        if summary = ""
            summary = entry
        else
            summary = `${summary} | ${entry}`
        end if
    end for
    if total > limit
        summary = `${summary} | ...(${total - limit} more)`
    end if
    return summary
end function

' Removes the on-disk file and metadata entry for a cached segment, emitting
' detailed logs about why the entry was culled.
function sabr_cacheFinalizeRemoval(fs as object, base as string, table as object, entry as object, metadata as object, reason as string) as string
    if not IsAssociativeArray(entry) then return ""
    fileName = entry?.fileName
    path = entry?.path
    if not IsString(fileName) or fileName = "" then return ""
    if not IsString(reason) or reason = "" then reason = "unspecified"

    sabr_cacheLog(log_level_Type.DEBUG, `[SabrCache] removing file=${fileName} reason=${reason}`)

    success = true
    if GetInterface(fs, "ifFileSystem") <> invalid and IsString(path) and path <> ""
        if fs.Exists(path)
            success = fs.Delete(path)
        end if
    end if

    if IsAssociativeArray(table) and table.DoesExist(fileName)
        table.Delete(fileName)
    end if

    focus = path
    if success and GetInterface(fs, "ifFileSystem") <> invalid
        confirmExists = fs.Exists(path)
        dirAfter = fs.GetDirectoryListing(base)
        listingLabel = ""
        if IsArray(dirAfter)
            idxCount = 0
            for each entryName in dirAfter
                if entryName = fileName then confirmExists = true
                if idxCount >= 10 then exit for
                if listingLabel = ""
                    listingLabel = entryName
                else
                    listingLabel = `${listingLabel},${entryName}`
                end if
                idxCount = idxCount + 1
            end for
        end if
        sabr_cacheLog(log_level_Type.DEBUG, `[SabrCache] post-delete verification file=${fileName} exists=${confirmExists} sampleEntries=${listingLabel}`)
        sabr_cacheLogPendingEntries(table, base, "post-delete")
    else if success = false
        sabr_cacheLog(log_level_Type.WARN, `[SabrCache] failed to delete file=${fileName}`)
    end if

    return focus
end function

function sabr_cacheExtractSize(fs as object, path as string) as integer
    if GetInterface(fs, "ifFileSystem") = invalid then return 0
    info = fs.Stat(path)
    if not IsAssociativeArray(info) then return 0
    keys = ["size", "filesize", "length"]
    for each key in keys
        if info.DoesExist(key)
            raw = info.Lookup(key)
            if IsInteger(raw) or IsFloat(raw) or IsDouble(raw)
                return Int(raw)
            else if IsString(raw)
                return Int(Val(raw))
            end if
        end if
    end for
    return 0
end function

function sabr_cacheExtractModifiedTicks(fs as object, path as string) as double
    if fs = invalid then return 0.0
    info = fs.Stat(path)
    if not IsAssociativeArray(info) then return 0.0

    keys = ["modified", "modificationTime", "creationTime", "ctime", "mtime"]
    stamp = invalid
    for each key in keys
        if info.DoesExist(key)
            stamp = info.Lookup(key)
            exit for
        end if
    end for

    if stamp = invalid then return 0.0

    if IsDateTime(stamp)
        return (stamp.AsSeconds() * 1000.0) + stamp.GetMilliseconds()
    end if

    if IsInteger(stamp) or IsFloat(stamp) or IsDouble(stamp)
        return stamp + 0.0
    end if

    return 0.0
end function

function sabr_cacheSegmentTempRoot() as string
    return `${SABR_CACHE_BASE_DIR}/segments`
end function

sub sabr_cacheDeleteDirectory(fs as object, path as string)
    if GetInterface(fs, "ifFileSystem") = invalid then return
    if not IsString(path) or path = "" then return
    try
        fs.Delete(path)
    catch e
    end try
end sub

sub sabr_cacheCleanupSegmentTemps(nowMs as integer)
    root = sabr_cacheSegmentTempRoot()
    fs = CreateObject("roFileSystem")
    if fs = invalid then return

    exists = false
    try
        exists = fs.Exists(root)
    catch e
        exists = false
    end try
    if not exists then return

    mediaDirs = fs.GetDirectoryListing(root)
    if not IsArray(mediaDirs) then return

    for each mediaName in mediaDirs
        mediaPath = `${root}/${mediaName}`
        requestDirs = fs.GetDirectoryListing(mediaPath)
        if not IsArray(requestDirs) then requestDirs = []

        for each reqName in requestDirs
            reqPath = `${mediaPath}/${reqName}`
            entries = fs.GetDirectoryListing(reqPath)
            if not IsArray(entries) or entries.count() = 0
                sabr_cacheDeleteDirectory(fs, reqPath)
            else
                latestTick = 0.0
                for each entryName in entries
                    entryPath = `${reqPath}/${entryName}`
                    stamp = sabr_cacheExtractModifiedTicks(fs, entryPath)
                    if stamp > latestTick then latestTick = stamp
                end for
                if latestTick <= 0
                    latestTick = sabr_cacheExtractModifiedTicks(fs, reqPath)
                end if
                ageMs = nowMs - Int(latestTick)
                if ageMs < 0 then ageMs = 0

                if ageMs >= SABR_CACHE_SEGMENT_TEMP_MAX_AGE_MS
                    sabr_cacheLog(log_level_Type.DEBUG, `[SabrCache] temp-cleanup dir=${reqPath} ageMs=${ageMs}`)
                    for each entryName in entries
                        entryPath = `${reqPath}/${entryName}`
                        try
                            if fs.Exists(entryPath)
                                fs.Delete(entryPath)
                            end if
                        catch e
                        end try
                    end for
                    sabr_cacheDeleteDirectory(fs, reqPath)
                end if
            end if
        end for

        remaining = fs.GetDirectoryListing(mediaPath)
        if IsArray(remaining) and remaining.count() = 0
            sabr_cacheDeleteDirectory(fs, mediaPath)
        end if
    end for

    rootEntries = fs.GetDirectoryListing(root)
    if IsArray(rootEntries) and rootEntries.count() = 0
        sabr_cacheDeleteDirectory(fs, root)
    end if
end sub

function sabr_cacheCopyFile(sourcePath as string, destPath as string) as boolean
    if not IsString(sourcePath) or sourcePath = "" then return false
    if not IsString(destPath) or destPath = "" then return false
    fs = CreateObject("roFileSystem")
    copyOk = invalid
    try
        copyOk = fs.CopyFile(sourcePath, destPath)
    catch e
        copyOk = invalid
    end try
    if copyOk = true then return true

    sabr_cacheLog(log_level_Type.DEBUG, `[SabrCache] CopyFile fallback source=${sourcePath} dest=${destPath} status=${copyOk}`)
    return sabr_cacheStreamCopyFile(sourcePath, destPath)
end function

function sabr_cacheStreamCopyFile(sourcePath as string, destPath as string) as boolean
    if not IsString(sourcePath) or sourcePath = "" then return false
    if not IsString(destPath) or destPath = "" then return false

    fs = CreateObject("roFileSystem")
    outFile = invalid
    success = true

    chunkSize = SABR_CACHE_COPY_CHUNK_SIZE_BYTES
    if chunkSize <= 0 then chunkSize = 128 * 1024

    totalSize = invalid
    stat = invalid
    try
        stat = fs.Stat(sourcePath)
    catch e
        stat = invalid
    end try
    if IsAssociativeArray(stat)
        sizeVal = stat.Lookup("size")
        if sizeVal = invalid then sizeVal = stat.Lookup("length")
        if IsInteger(sizeVal) or IsFloat(sizeVal) or IsDouble(sizeVal)
            totalSize = Int(sizeVal)
        end if
    end if

    try
        outFile = fs.OpenFile(destPath, "w")
    catch e
        outFile = invalid
    end try
    if GetInterface(outFile, "ifFile") = invalid
        sabr_cacheLog(log_level_Type.WARN, `[SabrCache] Failed to open destination file for copy dest=${destPath}`)
        return false
    end if

    buffer = CreateObject("roByteArray")
    offset = 0
    while success
        readLen = chunkSize
        if totalSize <> invalid
            remaining = totalSize - offset
            if remaining <= 0 then exit while
            if remaining < readLen then readLen = remaining
        end if
        if readLen <= 0 then exit while

        if buffer.ReadFile(sourcePath, offset, readLen) <> true
            success = false
            exit while
        end if

        chunkCount = buffer.count()
        if chunkCount = 0
            if totalSize = invalid
                exit while
            else
                success = offset >= totalSize
                exit while
            end if
        end if

        wrote = invalid
        try
            wrote = outFile.Write(buffer)
        catch e
            wrote = invalid
        end try
        if wrote <> chunkCount
            success = false
            exit while
        end if
        offset = offset + chunkCount

        if totalSize = invalid and chunkCount < readLen
            exit while
        end if
    end while

    outFile.Close()

    if success and totalSize <> invalid and offset < totalSize
        success = false
    end if

    if not success
        sabr_cacheLog(log_level_Type.WARN, `[SabrCache] Stream copy failed source=${sourcePath} dest=${destPath} offset=${offset} total=${totalSize}`)
        try
            fs.Delete(destPath)
        catch e
        end try
    end if
    return success
end function

function sabr_cacheWriteChunksToFile(destPath as string, chunkFiles as object) as boolean
    if not IsString(destPath) or destPath = "" then return false
    if not IsArray(chunkFiles) or chunkFiles.count() = 0 then return false

    fs = CreateObject("roFileSystem")
    outFile = invalid
    useBuffer = false
    try
        outFile = fs.OpenFile(destPath, "w")
    catch e
        outFile = invalid
    end try
    if GetInterface(outFile, "ifFile") = invalid
        useBuffer = true
    end if

    if useBuffer = false
        for each chunkPath in chunkFiles
            if not IsString(chunkPath) or chunkPath = "" then continue for
            chunkBytes = CreateObject("roByteArray")
            if chunkBytes.ReadFile(chunkPath) <> true
                outFile.Close()
                try
                    fs.Delete(destPath)
                catch deleteErr
                end try
                return false
            end if
            if chunkBytes.count() = 0 then continue for
            wrote = invalid
            try
                wrote = outFile.Write(chunkBytes)
            catch writeErr
                wrote = invalid
            end try
            if wrote = invalid or wrote = false
                outFile.Close()
                try
                    fs.Delete(destPath)
                catch delErr
                end try
                return false
            end if
        end for
        outFile.Close()
        return true
    end if

    ' Disabled fallback: would require concatenating entire segment in memory
    return false
end function

sub sabr_cacheLogSnapshot(reason as string, focusPath as string)
    logs = sabr_cacheLogger()
    if not IsAssociativeArray(logs) then return

    base = sabr_cacheEnsureBasePath()
    fs = CreateObject("roFileSystem")
    entries = fs.GetDirectoryListing(base)
    if not IsArray(entries) then return

    limit = SABR_CACHE_LOG_SAMPLE
    summary = ""
    total = entries.count()
    if total = 0 then return

    ' simple lexicographic sort descending
    for i = 0 to total - 2
        for j = i + 1 to total - 1
            if entries[j] > entries[i]
                temp = entries[i]
                entries[i] = entries[j]
                entries[j] = temp
            end if
        end for
    end for

    for idx = 0 to total - 1
        if idx >= limit then exit for
        file = entries[idx]
        path = `${base}/${file}`
        bytes = CreateObject("roByteArray")
        sizeLabel = "?"
        if bytes.readFile(path)
            sizeLabel = sabr_cacheFormatSize(bytes.count())
        end if
        label = `${file}(${sizeLabel})`
        if summary = ""
            summary = label
        else
            summary = `${summary}, ${label}`
        end if
    end for

    focusLabel = focusPath
    if focusLabel <> "" and focusLabel.InStr("/") >= 0
        parts = focusLabel.Split("/")
        focusLabel = parts[parts.count() - 1]
    end if

    sabr_log(logs, log_level_Type.DEBUG, `[SabrCache] snapshot reason=${reason} focus=${focusLabel} -> ${summary}`)
end sub

function sabr_cacheFormatSize(sizeValue as dynamic) as string
    sizeNum = 0
    if IsInteger(sizeValue) or IsFloat(sizeValue) or IsDouble(sizeValue)
        sizeNum = sizeValue
    else if IsString(sizeValue)
        sizeNum = Val(sizeValue)
    else
        sizeNum = 0
    end if
    if sizeNum = invalid or sizeNum < 0 then return "?"
    if sizeNum < 1024 then return `${Int(sizeNum)}B`
    kb = sizeNum / 1024.0
    if kb < 1024 then return `${Int(kb + 0.5)}KB`
    mb = kb / 1024.0
    return `${Int(mb + 0.5)}MB`
end function
