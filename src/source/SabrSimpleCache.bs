' Simple filesystem-based cache helpers for SABR segments.

import "pkg:/source/isItem.bs"
import "pkg:/source/SabrDebug.bs"

const SABR_CACHE_BASE_DIR = "tmp:/sabr-cache"
const SABR_CACHE_LOG_SAMPLE = 100
const MAX_SABR_CACHE_SEGMENT_AGE_MS = 60 * 1000
const SABR_CACHE_DELIVERED_SEQUENCE_GUARD = 3
const SABR_CACHE_DELIVERED_RANGE_GUARD = 200000
const SABR_CACHE_DELIVERED_MIN_AGE_MS = 1500
const SABR_CACHE_PENDING_SEQUENCE_DISTANCE = 4
const SABR_CACHE_PENDING_RANGE_DISTANCE = 400000
const SABR_CACHE_PENDING_PLAYER_TIME_MS = 15 * 1000
const SABR_CACHE_SEEK_GUARD_MS = 30 * 1000
const SABR_CACHE_TOTAL_SIZE_LIMIT = 10 * 1024 * 1024
const SABR_CACHE_SEGMENT_TEMP_MAX_AGE_MS = 30 * 1000

sub sabr_cacheSetLogger(logs as dynamic)
    m.sabr_cacheLogger = logs
end sub

function sabr_cacheLogger() as dynamic
    return m?.sabr_cacheLogger
end function

sub sabr_cacheLog(level as integer, message as string)
    logs = sabr_cacheLogger()
    debugOnly = (level = log_level_Type.DEBUG) or (level = log_level_Type.VERBOSE)
    sabr_log(logs, level, message, debugOnly)
end sub

function sabr_cacheCurrentTimestampMs() as integer
    dt = CreateObject("roDateTime")
    if not IsDateTime(dt) then return 0
    return (dt.AsSeconds() * 1000) + dt.GetMilliseconds()
end function

function sabr_cacheNormalizeNumber(value as dynamic) as dynamic
    if IsInteger(value)
        return value
    else if IsFloat(value) or IsDouble(value)
        return Int(value)
    else if IsString(value)
        parsed = Val(value)
        if IsInteger(parsed) or IsFloat(parsed) or IsDouble(parsed)
            return Int(parsed)
        end if
        return parsed
    end if
    return invalid
end function

function sabr_cacheEnsureBasePath() as string
    fs = CreateObject("roFileSystem")
    if not fs.Exists(SABR_CACHE_BASE_DIR)
        success = fs.CreateDirectory(SABR_CACHE_BASE_DIR)
        logObj = sabr_cacheLogger()
        if success <> true and IsAssociativeArray(logObj)
            sabr_log(logObj, log_level_Type.WARN, `[SabrCache] Failed to create cache directory ${SABR_CACHE_BASE_DIR}`, false)
        end if
    end if
    return SABR_CACHE_BASE_DIR
end function

function sabr_cacheSanitize(value as dynamic) as string
    if not isValid(value) then return ""
    str = ""
    if IsString(value)
        str = value
    else
        str = Str(value)
    end if
    str = str.trim()
    if str = "" then return ""
    result = ""
    total = Len(str)
    for i = 1 to total
        ch = Mid(str, i, 1)
        ascii = Asc(ch)
        isAlphaNum = (ascii >= 48 and ascii <= 57) or (ascii >= 65 and ascii <= 90) or (ascii >= 97 and ascii <= 122)
        if isAlphaNum
            result = result + LCase(ch)
        else if ch = "-" or ch = "_"
            result = result + ch
        else
            result = result + "_"
        end if
    end for
    return result
end function

function sabr_cacheMetadataTable() as object
    table = m?.sabr_cacheMetadataTable
    if not IsAssociativeArray(table)
        table = {}
        m.sabr_cacheMetadataTable = table
    end if
    return table
end function

sub sabr_cacheRememberMetadata(fileName as string, metadata as object)
    if not IsString(fileName) then return
    if fileName = "" then return
    if not IsAssociativeArray(metadata) then return
    meaningful = false
    fields = [ "startSegmentIndex", "endSegmentIndex", "startTimeMs", "durationMs", "timescale", "startTicks", "durationTicks", "playerTimeMs", "storedAtMs", "delivered", "deliveredAtMs", "lastAccessMs", "mediaIdHash" ]
    for each fieldName in fields
        value = invalid
        if metadata.DoesExist(fieldName)
            value = metadata.Lookup(fieldName)
        end if
        if isValid(value)
            meaningful = true
            exit for
        end if
    end for
    table = sabr_cacheMetadataTable()
    if not meaningful
        if table.DoesExist(fileName)
            table.Delete(fileName)
        end if
        return
    end if
    table = sabr_cacheMetadataTable()
    table[fileName] = metadata
end sub

function sabr_cacheLookupMetadata(fileName as string) as dynamic
    if not IsString(fileName) then return invalid
    if fileName = "" then return invalid
    table = sabr_cacheMetadataTable()
    if table.DoesExist(fileName)
        return table.Lookup(fileName)
    end if
    return invalid
end function

sub sabr_cachePruneMetadata(activeNames as object)
    if not IsArray(activeNames)
        m.sabr_cacheMetadataTable = {}
        return
    end if

    table = sabr_cacheMetadataTable()
    cleaned = {}
    for each name in activeNames
        if IsString(name) and name <> ""
            if table.DoesExist(name)
                cleaned[name] = table.Lookup(name)
            end if
        end if
    end for
    m.sabr_cacheMetadataTable = cleaned
end sub

function sabr_cacheExtractFileName(path as string) as string
    if not IsString(path) then return ""
    if path = "" then return ""
    parts = path.Split("/")
    if not IsArray(parts) or parts.count() = 0 then return path
    return parts[parts.count() - 1]
end function

function sabr_cacheBuildFilename(mediaIdHash as string, contentType as string, itag as dynamic, trackId = "" as string, isInitSegment = false as boolean, rangeStart = invalid as dynamic, rangeEnd = invalid as dynamic) as string
    parts = []
    parts.push(sabr_cacheSanitize(mediaIdHash))
    parts.push(sabr_cacheSanitize(contentType))
    parts.push(`itag${sabr_cacheSanitize(itag)}`)
    trackClean = sabr_cacheSanitize(trackId)
    if trackClean <> "" then parts.push(`track${trackClean}`)
    if isInitSegment
        parts.push("init")
    else
        parts.push("seg")
        parts.push(sabr_cacheSanitize(rangeStart))
        parts.push(sabr_cacheSanitize(rangeEnd))
    end if
    name = parts.Join("-") + ".bin"
    base = sabr_cacheEnsureBasePath()
    return `${base}/${name}`
end function

function sabr_cacheParseEntry(fileName as string) as object
    if Right(fileName, 4) <> ".bin" then return invalid
    core = Left(fileName, Len(fileName) - 4)
    parts = core.Split("-")
    if not IsArray(parts) then return invalid
    count = parts.count()
    if count < 4 then return invalid

    idx = 0
    entry = {}
    entry["mediaIdHash"] = parts[idx]
    idx = idx + 1
    entry["contentType"] = parts[idx]
    idx = idx + 1

    if count <= idx then return invalid
    itagPart = parts[idx]
    idx = idx + 1
    if itagPart.Left(4) <> "itag" then return invalid
    entry["itag"] = itagPart.Mid(4)

    entry["trackId"] = ""
    if count > idx and Left(parts[idx], 5) = "track"
        entry["trackId"] = parts[idx].Mid(5)
        idx = idx + 1
    end if

    if count <= idx then return invalid
    indicator = parts[idx]
    idx = idx + 1
    if indicator = "init"
        entry["isInit"] = true
        entry["rangeStart"] = invalid
        entry["rangeEnd"] = invalid
    else if indicator = "seg"
        entry["isInit"] = false
        if count <= idx then return invalid
        startToken = parts[idx]
        if startToken = ""
            entry["rangeStart"] = invalid
        else
            entry["rangeStart"] = Val(startToken)
        end if
        idx = idx + 1
        if count <= idx then return invalid
        endToken = parts[idx]
        if endToken = ""
            entry["rangeEnd"] = invalid
        else
            entry["rangeEnd"] = Val(endToken)
        end if
    else
        return invalid
    end if

    entry["fileName"] = fileName
    entry["path"] = `${sabr_cacheEnsureBasePath()}/${fileName}`

    extra = sabr_cacheLookupMetadata(fileName)
    if IsAssociativeArray(extra)
        if extra.DoesExist("startSegmentIndex") then entry["startSegmentIndex"] = extra.Lookup("startSegmentIndex")
        if extra.DoesExist("endSegmentIndex") then entry["endSegmentIndex"] = extra.Lookup("endSegmentIndex")
        if extra.DoesExist("startTimeMs") then entry["startTimeMs"] = extra.Lookup("startTimeMs")
        if extra.DoesExist("durationMs") then entry["durationMs"] = extra.Lookup("durationMs")
        if extra.DoesExist("timescale") then entry["timescale"] = extra.Lookup("timescale")
        if extra.DoesExist("startTicks") then entry["startTicks"] = extra.Lookup("startTicks")
        if extra.DoesExist("durationTicks") then entry["durationTicks"] = extra.Lookup("durationTicks")
        if extra.DoesExist("sequenceNumber") then entry["sequenceNumber"] = extra.Lookup("sequenceNumber")
        if extra.DoesExist("formatId") then entry["formatId"] = extra.Lookup("formatId")
        if extra.DoesExist("playerTimeMs") then entry["playerTimeMs"] = extra.Lookup("playerTimeMs")
    end if
    return entry
end function

function sabr_cacheListEntries(mediaIdHash as string, contentType as string, itag as dynamic, trackId = "" as string) as object
    base = sabr_cacheEnsureBasePath()
    fs = CreateObject("roFileSystem")
    names = fs.GetDirectoryListing(base)
    results = []
    if not IsArray(names) then return results

    sabr_cachePruneMetadata(names)

    targetMedia = sabr_cacheSanitize(mediaIdHash)
    targetType = sabr_cacheSanitize(contentType)
    targetItag = sabr_cacheSanitize(itag)
    targetTrack = sabr_cacheSanitize(trackId)

    for each name in names
        entry = sabr_cacheParseEntry(name)
        if not IsAssociativeArray(entry) then continue for
        entryMedia = sabr_cacheSanitize(entry.mediaIdHash)
        entryType = sabr_cacheSanitize(entry.contentType)
        entryItag = sabr_cacheSanitize(entry.itag)
        entryTrack = sabr_cacheSanitize(entry.trackId)
        if entryMedia <> targetMedia then continue for
        if entryType <> targetType then continue for
        if entryItag <> targetItag then continue for
        if targetTrack <> "" and entryTrack <> targetTrack then continue for
        if targetTrack = "" and entryTrack <> "" then continue for
        results.push(entry)
    end for
    return results
end function

function sabr_cacheStoreSegment(options as object) as object
    if not IsAssociativeArray(options) then return invalid

    bytes = options?.bytes
    chunkFiles = options?.chunkFiles
    dataPath = options?.dataPath
    chunkCountOpt = sabr_cacheNormalizeNumber(options?.chunkCount)
    totalBytesOpt = sabr_cacheNormalizeNumber(options?.totalBytes)

    path = sabr_cacheBuildFilename(
        options?.mediaIdHash,
        options?.contentType,
        options?.itag,
        options?.trackId ?? "",
        options?.isInit = true,
        options?.rangeStart,
        options?.rangeEnd
    )

    base = sabr_cacheEnsureBasePath()
    fs = CreateObject("roFileSystem")
    if not fs.Exists(base)
        fs.CreateDirectory(base)
    end if

    success = false
    if GetInterface(bytes, "ifByteArray") <> invalid and bytes.count() > 0
        success = bytes.writeFile(path)
        if totalBytesOpt = invalid then totalBytesOpt = bytes.count()
    else if IsArray(chunkFiles) and chunkFiles.count() > 0
        success = sabr_cacheWriteChunksToFile(path, chunkFiles)
    else if IsString(dataPath) and dataPath <> ""
        success = sabr_cacheCopyFile(dataPath, path)
    end if

    if success <> true then return invalid

    fileName = sabr_cacheExtractFileName(path)
    extra = {}
    if isValid(options?.contentType) then extra.contentType = options.contentType
    if isValid(options?.itag) then extra.itag = options.itag
    if isValid(options?.trackId) then extra.trackId = options.trackId
    if isValid(options?.mediaIdHash) then extra.mediaIdHash = options.mediaIdHash
    nowMs = sabr_cacheCurrentTimestampMs()
    if isValid(options?.startSegmentIndex)
        extra.startSegmentIndex = options.startSegmentIndex
    end if
    if isValid(options?.endSegmentIndex)
        extra.endSegmentIndex = options.endSegmentIndex
    end if
    if isValid(options?.startTimeMs)
        extra.startTimeMs = options.startTimeMs
    end if
    if isValid(options?.durationMs)
        extra.durationMs = options.durationMs
    end if
    if isValid(options?.timescale)
        extra.timescale = options.timescale
    end if
    if isValid(options?.startTicks)
        extra.startTicks = options.startTicks
    end if
    if isValid(options?.durationTicks)
        extra.durationTicks = options.durationTicks
    end if
    if isValid(options?.sequenceNumber)
        extra.sequenceNumber = options.sequenceNumber
    else if isValid(extra?.startSegmentIndex)
        extra.sequenceNumber = extra.startSegmentIndex
    end if
    formatIdOpt = options?.formatId
    if IsAssociativeArray(formatIdOpt)
        extra.formatId = formatIdOpt
    end if
    if isValid(options?.playerTimeMs)
        extra["playerTimeMs"] = options.playerTimeMs
    end if
    if chunkCountOpt <> invalid then extra.chunkCount = chunkCountOpt
    if totalBytesOpt <> invalid then extra.totalBytes = totalBytesOpt
    extra.storedAtMs = nowMs
    extra.lastAccessMs = nowMs
    extra.delivered = false
    extra.seekProtectedUntil = nowMs + SABR_CACHE_SEEK_GUARD_MS
    sabr_cacheRememberMetadata(fileName, extra)
    sizeLabel = totalBytesOpt
    if sizeLabel = invalid and GetInterface(bytes, "ifByteArray") <> invalid
        sizeLabel = bytes.count()
    end if
    sabr_cacheLog(log_level_Type.DEBUG, `[SabrCache] stored file=${fileName} size=${sabr_cacheNormalizeNumber(sizeLabel)} storedAt=${nowMs}`)

    if IsString(options?.mediaIdHash) and options.mediaIdHash <> ""
        m.sabrCacheActiveMediaId = options.mediaIdHash
    end if

    sabr_cacheRunMaintenance(path)

    sabr_cacheLogSnapshot("store", path)
    return {
        "path": path
        "rangeStart": options?.rangeStart
        "rangeEnd": options?.rangeEnd
    }
end function

function sabr_cacheLoadSegment(params as object) as object
    if not IsAssociativeArray(params) then return invalid
    entries = sabr_cacheListEntries(params?.mediaIdHash, params?.contentType, params?.itag, params?.trackId ?? "")
    if entries.count() = 0 then return invalid

    requestedStart = Val(params?.requestedStart)
    requestedEnd = Val(params?.requestedEnd)
    hasStart = requestedStart <> invalid
    hasEnd = requestedEnd <> invalid

    best = invalid
    for each entry in entries
        if entry["isInit"] = true
            if params?.isInit = true
                best = entry
                exit for
            else
                continue for
            end if
        end if

        if params?.isInit = true then continue for

        coverageStart = entry?.rangeStart
        coverageEnd = entry?.rangeEnd
        if coverageStart = invalid or coverageEnd = invalid then continue for

        matches = true
        if hasStart and requestedStart < coverageStart then matches = false
        if matches and hasEnd and requestedEnd > coverageEnd then matches = false

        if matches = false then
            ' allow exact end match when end unknown
            if hasStart and coverageStart = requestedStart and hasEnd = false
                matches = true
            end if
        end if

        if matches
            if best = invalid
                best = entry
            else
                ' prefer tighter coverage
                bestSpan = (best.rangeEnd - best.rangeStart)
                entrySpan = (coverageEnd - coverageStart)
                if entrySpan < bestSpan
                    best = entry
                end if
            end if
        end if
    end for

    if params?.isInit = true and best = invalid
        ' fallback: use first init if available
        for each entry in entries
            if entry["isInit"] = true
                best = entry
                exit for
            end if
        end for
    end if

    if best = invalid then return invalid

    bytes = CreateObject("roByteArray")
    if not bytes.readFile(best.path) then return invalid

    sabr_cacheRecordAccess(best)

    coverageStart = best?.rangeStart
    coverageEnd = best?.rangeEnd
    if best.isInit = true
        coverageStart = 0
        coverageEnd = bytes.count() - 1
    end if

    sabr_cacheLogSnapshot("load", best.path)

    result = invalid

    if params?.isInit = true
        result = {
            "data": bytes
            "rangeStart": coverageStart
            "rangeEnd": coverageEnd
            "path": best.path
        }
    else
        if hasStart and coverageStart <> invalid and requestedStart > coverageStart
            offset = requestedStart - coverageStart
        else
            offset = 0
        end if

        if hasEnd and coverageEnd <> invalid
            desiredLength = (requestedEnd - (coverageStart + offset)) + 1
            if desiredLength < 0 then desiredLength = 0
        else
            desiredLength = bytes.count() - offset
        end if

        if offset <= 0 and desiredLength >= bytes.count()
            sliced = bytes
        else
            sliced = CreateObject("roByteArray")
            if desiredLength < 0 then desiredLength = 0
            if desiredLength > bytes.count() - offset then desiredLength = bytes.count() - offset
            if desiredLength < 0 then desiredLength = 0
            if desiredLength = 0
                ' return empty array
            else
                for i = 0 to desiredLength - 1
                    sliced[i] = bytes[offset + i]
                end for
            end if
        end if

        effectiveStart = coverageStart
        if hasStart and requestedStart <> invalid
            effectiveStart = requestedStart
        end if
        effectiveEnd = effectiveStart + sliced.count() - 1

        result = {
            "data": sliced
            "rangeStart": effectiveStart
            "rangeEnd": effectiveEnd
            "path": best.path
        }
    end if

    if not IsAssociativeArray(result) then return invalid

    sabr_cacheMarkDelivered(best)
    sabr_cacheRunMaintenance(best.path)
    return result
end function

sub sabr_cacheRecordAccess(entry as object)
    if not IsAssociativeArray(entry) then return
    fileName = entry?.fileName
    if not IsString(fileName) or fileName = "" then return

    table = sabr_cacheMetadataTable()
    metadata = table.Lookup(fileName)
    if not IsAssociativeArray(metadata)
        metadata = {}
    end if

    timestamp = sabr_cacheCurrentTimestampMs()
    metadata["lastAccessMs"] = timestamp
    if not metadata.DoesExist("storedAtMs") or not isValid(metadata.storedAtMs)
        fs = CreateObject("roFileSystem")
        metadata["storedAtMs"] = Int(sabr_cacheExtractModifiedTicks(fs, entry?.path))
    end if
    table[fileName] = metadata
    sabr_cacheLog(log_level_Type.DEBUG, `[SabrCache] access file=${fileName} lastAccessMs=${metadata.lastAccessMs}`)
end sub

sub sabr_cacheMarkDelivered(entry as object)
    if not IsAssociativeArray(entry) then return
    fileName = entry?.fileName
    if not IsString(fileName) or fileName = "" then return

    table = sabr_cacheMetadataTable()
    metadata = table.Lookup(fileName)
    if not IsAssociativeArray(metadata)
        metadata = {}
    end if

    timestamp = sabr_cacheCurrentTimestampMs()
    metadata["delivered"] = true
    metadata["deliveredAtMs"] = timestamp
    metadata["lastAccessMs"] = timestamp
    if not metadata.DoesExist("storedAtMs") or not isValid(metadata.storedAtMs)
        fs = CreateObject("roFileSystem")
        metadata["storedAtMs"] = Int(sabr_cacheExtractModifiedTicks(fs, entry?.path))
    end if
    table[fileName] = metadata
    sabr_cacheUpdateDeliveryProgress(entry, metadata)
    mediaId = entry?.mediaIdHash
    if mediaId = invalid or mediaId = ""
        mediaId = metadata?.mediaIdHash
    end if
    if IsString(mediaId) and mediaId <> ""
        m.sabrCacheActiveMediaId = mediaId
    end if
    sabr_cacheLog(log_level_Type.DEBUG, `[SabrCache] delivered file=${fileName} deliveredAt=${metadata.deliveredAtMs}`)
end sub

sub sabr_cacheMarkDeliveredByPath(path as string, reason as string, extra = invalid as dynamic)
    if not IsString(path) or path = "" then return
    fileName = sabr_cacheExtractFileName(path)
    entry = sabr_cacheParseEntry(fileName)
    if not IsAssociativeArray(entry)
        entry = {
            "fileName": fileName
            "path": path
        }
    else
        entry["path"] = path
    end if
    if IsAssociativeArray(extra)
        for each key in extra
            entry[key] = extra[key]
        end for
        mediaHint = sabr_cacheSanitize(extra?.mediaIdHash)
        if mediaHint <> ""
            entry["mediaIdHash"] = mediaHint
            m.sabrCacheActiveMediaId = mediaHint
        end if
    end if
    sabr_cacheLog(log_level_Type.DEBUG, `[SabrCache] mark-delivered path=${fileName} reason=${reason}`)
    sabr_cacheMarkDelivered(entry)
    sabr_cacheRunMaintenance(path)
end sub

function sabr_cacheDeliveryProgress() as object
    progress = m?.sabr_cacheDeliveryProgress
    if not IsAssociativeArray(progress)
        progress = {}
        m.sabr_cacheDeliveryProgress = progress
    end if
    return progress
end function

function sabr_cacheEnsureDeliveryProgressKey(contentType as dynamic, itag as dynamic, trackId as dynamic) as object
    key = `${sabr_cacheSanitize(contentType)}|${sabr_cacheSanitize(itag)}|${sabr_cacheSanitize(trackId)}`
    if key = "||" then key = "unknown|none|main"
    progress = sabr_cacheDeliveryProgress()
    info = progress.Lookup(key)
    if not IsAssociativeArray(info)
        info = {}
        progress[key] = info
        m.sabr_cacheDeliveryProgress = progress
    end if
    return info
end function

sub sabr_cacheUpdateProgressForSeek(contentType as dynamic, format as dynamic, sequenceNumber as dynamic, rangeStart as dynamic, playerTimeMs as dynamic)
    itag = invalid
    trackId = invalid
    if IsAssociativeArray(format)
        itag = format?.itag
        trackId = format?.audioTrackId
    end if

    info = sabr_cacheEnsureDeliveryProgressKey(contentType, itag, trackId)
    if not IsAssociativeArray(info) then return

    seqVal = sabr_cacheNormalizeNumber(sequenceNumber)
    if seqVal <> invalid then info.lastSequence = seqVal

    rangeVal = sabr_cacheNormalizeNumber(rangeStart)
    if rangeVal <> invalid then info.lastRangeStart = rangeVal

    playerVal = sabr_cacheNormalizeNumber(playerTimeMs)
    if playerVal <> invalid then info.lastPlayerTimeMs = playerVal

    info.updatedAtMs = sabr_cacheCurrentTimestampMs()
    if rangeVal <> invalid
        currentGuard = sabr_cacheNormalizeNumber(info?.seekGuardRange)
        if currentGuard = invalid or rangeVal <= currentGuard
            info.seekGuardRange = rangeVal
            info.seekGuardExpiresAt = info.updatedAtMs + SABR_CACHE_SEEK_GUARD_MS
        end if
    end if

    progress = sabr_cacheDeliveryProgress()
    itagKey = sabr_cacheSanitize(itag)
    trackKey = sabr_cacheSanitize(trackId)
    typeKey = sabr_cacheSanitize(contentType)
    if typeKey = "" then typeKey = "unknown"
    if itagKey = "" then itagKey = "none"
    if trackKey = "" then trackKey = "main"
    progress[`${typeKey}|${itagKey}|${trackKey}`] = info
    m.sabr_cacheDeliveryProgress = progress
end sub

function sabr_cacheBuildDeliveryKey(entry as object) as string
    if not IsAssociativeArray(entry) then return ""
    typeKey = sabr_cacheSanitize(entry?.contentType)
    if typeKey = "" then typeKey = "unknown"
    itagKey = sabr_cacheSanitize(entry?.itag)
    if itagKey = "" then itagKey = "none"
    trackKey = sabr_cacheSanitize(entry?.trackId)
    if trackKey = "" then trackKey = "main"
    return `${typeKey}|${itagKey}|${trackKey}`
end function

function sabr_cacheExtractSequence(entry as object, metadata as object) as dynamic
    seqVal = sabr_cacheNormalizeNumber(metadata?.sequenceNumber)
    if seqVal = invalid then seqVal = sabr_cacheNormalizeNumber(metadata?.startSegmentIndex)
    if seqVal = invalid and IsAssociativeArray(entry)
        seqVal = sabr_cacheNormalizeNumber(entry?.sequenceNumber)
        if seqVal = invalid then seqVal = sabr_cacheNormalizeNumber(entry?.startSegmentIndex)
    end if
    return seqVal
end function

sub sabr_cacheUpdateDeliveryProgress(entry as object, metadata as object)
    progress = sabr_cacheDeliveryProgress()
    key = sabr_cacheBuildDeliveryKey(entry)
    if key = "" then return
    info = sabr_cacheEnsureDeliveryProgressKey(entry?.contentType, entry?.itag, entry?.trackId)

    seqVal = sabr_cacheExtractSequence(entry, metadata)
    if seqVal <> invalid
        lastSeq = sabr_cacheNormalizeNumber(info?.lastSequence)
        if lastSeq = invalid or seqVal > lastSeq
            info.lastSequence = seqVal
        end if
    end if

    rangeStart = sabr_cacheNormalizeNumber(metadata?.rangeStart)
    if rangeStart = invalid and IsAssociativeArray(entry)
        rangeStart = sabr_cacheNormalizeNumber(entry?.rangeStart)
    end if
    if rangeStart <> invalid
        lastRange = sabr_cacheNormalizeNumber(info?.lastRangeStart)
        if lastRange = invalid or rangeStart > lastRange
            info.lastRangeStart = rangeStart
        end if
    end if

    deliveredAt = sabr_cacheNormalizeNumber(metadata?.deliveredAtMs)
    if deliveredAt = invalid
        deliveredAt = sabr_cacheCurrentTimestampMs()
    end if
    info.lastDeliveredAtMs = deliveredAt
    info.updatedAtMs = sabr_cacheCurrentTimestampMs()

    startTimeMs = sabr_cacheNormalizeNumber(metadata?.startTimeMs)
    if startTimeMs = invalid and IsAssociativeArray(metadata?.timeRange)
        ticks = sabr_cacheNormalizeNumber(metadata.timeRange?.startTicks)
        timescale = sabr_cacheNormalizeNumber(metadata.timeRange?.timescale)
        if ticks <> invalid and timescale <> invalid and timescale > 0
            startTimeMs = Int((ticks * 1000) / timescale)
        end if
    end if
    if startTimeMs = invalid and IsAssociativeArray(entry)
        startTimeMs = sabr_cacheNormalizeNumber(entry?.startTimeMs)
    end if
    if startTimeMs <> invalid
        info.lastPlayerTimeMs = startTimeMs
    end if

    progress[key] = info
    m.sabr_cacheDeliveryProgress = progress
end sub

function sabr_cacheShouldDeferDeliveredRemoval(entry as object, metadata as object, nowMs as integer) as boolean
    if not IsAssociativeArray(metadata) then return false
    if metadata?.delivered <> true then return false

    deliveredAt = sabr_cacheNormalizeNumber(metadata?.deliveredAtMs)
    if deliveredAt <> invalid and nowMs - deliveredAt < SABR_CACHE_DELIVERED_MIN_AGE_MS
        return true
    end if

    key = sabr_cacheBuildDeliveryKey(entry)
    if key = "" then return false
    progress = sabr_cacheDeliveryProgress()
    info = progress.Lookup(key)
    if not IsAssociativeArray(info) then return false

    guardRange = sabr_cacheNormalizeNumber(info?.seekGuardRange)
    guardExpiry = sabr_cacheNormalizeNumber(info?.seekGuardExpiresAt)
    rangeStartValue = sabr_cacheNormalizeNumber(metadata?.rangeStart)
    if rangeStartValue = invalid and IsAssociativeArray(entry)
        rangeStartValue = sabr_cacheNormalizeNumber(entry?.rangeStart)
    end if
    if guardRange <> invalid and guardExpiry <> invalid and nowMs <= guardExpiry
        if rangeStartValue <> invalid and rangeStartValue <= guardRange
            return true
        end if
    end if

    seqVal = sabr_cacheExtractSequence(entry, metadata)
    lastSeq = sabr_cacheNormalizeNumber(info?.lastSequence)
    if seqVal <> invalid and lastSeq <> invalid
        diffSeq = lastSeq - seqVal
        if diffSeq < SABR_CACHE_DELIVERED_SEQUENCE_GUARD
            return true
        end if
    end if

    rangeStart = sabr_cacheNormalizeNumber(metadata?.rangeStart)
    lastRange = sabr_cacheNormalizeNumber(info?.lastRangeStart)
    if rangeStart <> invalid and lastRange <> invalid
        diffRange = lastRange - rangeStart
        if diffRange >= 0 and diffRange < SABR_CACHE_DELIVERED_RANGE_GUARD
            return true
        end if
    end if

    return false
end function

function sabr_cacheShouldCullPending(entry as object, metadata as object) as boolean
    if not IsAssociativeArray(metadata) then return false
    key = sabr_cacheBuildDeliveryKey(entry)
    if key = "" then return false
    progress = sabr_cacheDeliveryProgress()
    info = progress.Lookup(key)
    if not IsAssociativeArray(info) then return false

    nowMs = sabr_cacheCurrentTimestampMs()

    seqVal = sabr_cacheExtractSequence(entry, metadata)
    lastSeq = sabr_cacheNormalizeNumber(info?.lastSequence)
    if seqVal <> invalid and lastSeq <> invalid
        diffSeq = lastSeq - seqVal
        if diffSeq > SABR_CACHE_PENDING_SEQUENCE_DISTANCE
            return true
        end if
    end if

    rangeStart = sabr_cacheNormalizeNumber(metadata?.rangeStart)
    if rangeStart = invalid and IsAssociativeArray(entry)
        rangeStart = sabr_cacheNormalizeNumber(entry?.rangeStart)
    end if
    lastRange = sabr_cacheNormalizeNumber(info?.lastRangeStart)
    guardRange = sabr_cacheNormalizeNumber(info?.seekGuardRange)
    guardExpiry = sabr_cacheNormalizeNumber(info?.seekGuardExpiresAt)
    if guardRange <> invalid and guardExpiry <> invalid and nowMs <= guardExpiry
        if rangeStart <> invalid and rangeStart <= guardRange
            return false
        end if
    end if
    if rangeStart <> invalid and lastRange <> invalid
        diffRange = lastRange - rangeStart
        if diffRange > SABR_CACHE_PENDING_RANGE_DISTANCE
            return true
        end if
    end if

    playerTimeMs = sabr_cacheNormalizeNumber(metadata?.playerTimeMs)
    if playerTimeMs = invalid and not IsAssociativeArray(metadata?.startTimeMs)
        playerTimeMs = sabr_cacheNormalizeNumber(metadata?.startTimeMs)
    end if
    if playerTimeMs = invalid and IsAssociativeArray(entry)
        playerTimeMs = sabr_cacheNormalizeNumber(entry?.startTimeMs)
    end if
    lastPlayerMs = sabr_cacheNormalizeNumber(info?.lastPlayerTimeMs)
    if playerTimeMs <> invalid and lastPlayerMs <> invalid
        diffMs = lastPlayerMs - playerTimeMs
        if diffMs > SABR_CACHE_PENDING_PLAYER_TIME_MS
            return true
        end if
    end if

    return false
end function

sub sabr_cacheRunMaintenance(activePath as string)
    base = sabr_cacheEnsureBasePath()
    fs = CreateObject("roFileSystem")
    names = fs.GetDirectoryListing(base)
    if not IsArray(names) then return

    loggerRef = sabr_cacheLogger()
    maintenanceTimer = invalid
    if isValid(loggerRef)
        maintenanceTimer = loggerRef.mark()
    end if

    nowMs = sabr_cacheCurrentTimestampMs()
    table = sabr_cacheMetadataTable()
    removedAny = false
    removedCount = 0
    focusPath = ""
    remaining = []
    totalBytes = 0
    activeMedia = sabr_cacheSanitize(m?.sabrCacheActiveMediaId)

    sabr_cacheLog(log_level_Type.DEBUG, `[SabrCache] maintenance start total=${names.count()} activePath=${activePath}`)
    sabr_cacheLogPendingEntries(table, base, "start")

    for each name in names
        path = `${base}/${name}`
        if Right(name, 4) <> ".bin"
            if name = "segments"
                ' handled separately in sabr_cacheCleanupSegmentTemps
            else
                statDir = fs.Stat(path)
                isDir = false
                if IsAssociativeArray(statDir)
                    entryType = statDir.Lookup("type")
                    if IsString(entryType) and LCase(entryType) = "directory"
                        isDir = true
                    end if
                end if
                if isDir
                    childEntries = fs.GetDirectoryListing(path)
                    if IsArray(childEntries) and childEntries.count() = 0
                        sabr_cacheDeleteDirectory(fs, path)
                    end if
                end if
            end if
            continue for
        end if
        entryInfo = sabr_cacheParseEntry(name)
        if not IsAssociativeArray(entryInfo)
            entryInfo = {
                "fileName": name
            }
        end if
        entryInfo["path"] = path

        metadata = table.Lookup(name)
        if not IsAssociativeArray(metadata)
            metadata = {}
        end if

        if not metadata.DoesExist("contentType") and entryInfo?.contentType <> invalid
            metadata["contentType"] = entryInfo.contentType
        end if
        if not metadata.DoesExist("itag") and entryInfo?.itag <> invalid
            metadata["itag"] = entryInfo.itag
        end if
        if not metadata.DoesExist("trackId") and entryInfo?.trackId <> invalid
            metadata["trackId"] = entryInfo.trackId
        end if
        if not metadata.DoesExist("mediaIdHash") and entryInfo?.mediaIdHash <> invalid
            metadata["mediaIdHash"] = entryInfo.mediaIdHash
        end if
        table[name] = metadata

        delivered = metadata?.delivered = true
        storedAtMs = sabr_cacheNormalizeNumber(metadata?.storedAtMs)
        deliveredAtMs = sabr_cacheNormalizeNumber(metadata?.deliveredAtMs)
        lastTouchMs = sabr_cacheNormalizeNumber(metadata?.lastAccessMs)

        if storedAtMs = invalid or storedAtMs <= 0
            storedAtMs = Int(sabr_cacheExtractModifiedTicks(fs, path))
            metadata["storedAtMs"] = storedAtMs
            table[name] = metadata
        end if
        if lastTouchMs = invalid or lastTouchMs <= 0
            if deliveredAtMs <> invalid and deliveredAtMs > 0
                lastTouchMs = deliveredAtMs
            else
                lastTouchMs = storedAtMs
            end if
        metadata["lastAccessMs"] = lastTouchMs
        table[name] = metadata
    end if

        protectUntil = sabr_cacheNormalizeNumber(metadata?.seekProtectedUntil)
        if protectUntil <> invalid and nowMs < protectUntil
            sabr_cacheLog(log_level_Type.DEBUG, `[SabrCache] skip removal file=${name} reason=seek-guard`)
            sizeVal = sabr_cacheExtractSize(fs, path)
            info = {
                "entry": entryInfo,
                "metadata": metadata,
                "size": sizeVal,
                "storedAt": storedAtMs
            }
            remaining.push(info)
            totalBytes = totalBytes + sizeVal
            continue for
        end if

        shouldRemove = false
        removalReason = ""
        isInitEntry = entryInfo?.isInit = true
        entryMediaId = sabr_cacheSanitize(entryInfo?.mediaIdHash)

        if delivered
            if sabr_cacheShouldDeferDeliveredRemoval(entryInfo, metadata, nowMs)
                sabr_cacheLog(log_level_Type.DEBUG, `[SabrCache] skip removal file=${name} reason=recent-delivery`)
            else
                shouldRemove = true
                removalReason = "delivered"
            end if
        else
            if sabr_cacheShouldCullPending(entryInfo, metadata)
                shouldRemove = true
                removalReason = "orphan-early"
            else
                if storedAtMs <> invalid and storedAtMs > 0
                    ageMs = nowMs - storedAtMs
                    if ageMs >= MAX_SABR_CACHE_SEGMENT_AGE_MS
                        shouldRemove = true
                        removalReason = `stale-age stored=${storedAtMs} age=${ageMs}`
                    end if
                else if lastTouchMs <> invalid and lastTouchMs > 0
                    ageFallback = nowMs - lastTouchMs
                    if ageFallback >= MAX_SABR_CACHE_SEGMENT_AGE_MS
                        shouldRemove = true
                        removalReason = `stale-lastTouch last=${lastTouchMs} age=${ageFallback}`
                    end if
                end if
            end if
        end if

        if shouldRemove and isInitEntry
            if activeMedia <> "" and entryMediaId = activeMedia
                shouldRemove = false
                removalReason = ""
            end if
        end if

        if shouldRemove and activePath <> "" and path = activePath and delivered = false
            shouldRemove = false
            sabr_cacheLog(log_level_Type.DEBUG, `[SabrCache] skip removal file=${name} reason=active-request`)
        end if

        if shouldRemove
            focus = sabr_cacheFinalizeRemoval(fs, base, table, entryInfo, metadata, removalReason)
            if focus <> ""
                removedAny = true
                removedCount = removedCount + 1
                focusPath = focus
            end if
        else
            sizeVal = sabr_cacheExtractSize(fs, path)
            info = {
                "entry": entryInfo,
                "metadata": metadata,
                "size": sizeVal,
                "storedAt": storedAtMs
            }
            remaining.push(info)
            totalBytes = totalBytes + sizeVal
        end if
    end for

    keys = table.keys()
    for each key in keys
        lookupPath = `${base}/${key}`
        if not fs.Exists(lookupPath)
            table.Delete(key)
            removedAny = true
            focusPath = lookupPath
        end if
    end for

    if activeMedia <> ""
        for idx = remaining.count() - 1 to 0 step -1
            info = remaining[idx]
            entryMedia = sabr_cacheSanitize(info.entry?.mediaIdHash)
            if entryMedia <> "" and entryMedia <> activeMedia
                focus = sabr_cacheFinalizeRemoval(fs, base, table, info.entry, info.metadata, "foreign-media")
                if focus <> ""
                    removedAny = true
                    removedCount = removedCount + 1
                    focusPath = focus
                    totalBytes = totalBytes - info.size
                end if
                remaining.Delete(idx)
            end if
        end for
    end if

    if SABR_CACHE_TOTAL_SIZE_LIMIT > 0 and totalBytes > SABR_CACHE_TOTAL_SIZE_LIMIT
        while totalBytes > SABR_CACHE_TOTAL_SIZE_LIMIT and remaining.count() > 0
            oldestIdx = 0
            oldestVal = remaining[0]?.storedAt
            for idx = 1 to remaining.count() - 1
                info = remaining[idx]
                value = info?.storedAt
                if oldestVal = invalid or (value <> invalid and value < oldestVal)
                    oldestIdx = idx
                    oldestVal = value
                end if
            end for
            info = remaining[oldestIdx]
            focus = sabr_cacheFinalizeRemoval(fs, base, table, info.entry, info.metadata, "quota")
            if focus <> ""
                removedAny = true
                removedCount = removedCount + 1
                focusPath = focus
            end if
            totalBytes = totalBytes - info.size
            remaining.Delete(oldestIdx)
        end while
    end if

    sabr_cacheCleanupSegmentTemps(nowMs)

    if maintenanceTimer <> invalid
        summaryLabel = `[SabrCache] maintenance duration removed=${removedCount} remaining=${remaining.count()} bytes=${totalBytes}`
        loggerRef.printTime(log_level_Type.INFO, summaryLabel, maintenanceTimer, -1)
    end if

    if removedAny
        updated = fs.GetDirectoryListing(base)
        sabr_cachePruneMetadata(updated)
        sabr_cacheLogSnapshot("cleanup", focusPath)
        entriesCount = 0
        if IsArray(updated)
            entriesCount = updated.count()
        end if
        sabr_cacheLog(log_level_Type.INFO, `[SabrCache] maintenance removed=${removedCount} remaining=${entriesCount}`)
    else
        sabr_cacheLog(log_level_Type.DEBUG, "[SabrCache] maintenance removed=0")
    end if
    sabr_cacheLogPendingEntries(table, base, "end")
end sub

sub sabr_cacheLogPendingEntries(table as object, base as string, phase as string)
    if not IsAssociativeArray(table) then return

    nowMs = sabr_cacheCurrentTimestampMs()
    pendingLabels = []
    deliveredLabels = []

    keys = table.keys()
    total = 0
    deliveredCount = 0
    pendingCount = 0

    for each key in keys
        metadata = table.Lookup(key)
        total = total + 1
        deliveredFlag = false
        if IsAssociativeArray(metadata)
            deliveredValue = metadata?.delivered
            if isValid(deliveredValue)
                deliveredFlag = (deliveredValue = true)
            end if
        end if

        storedMs = invalid
        lastMs = invalid
        deliveredMs = invalid
        if IsAssociativeArray(metadata)
            storedMs = sabr_cacheNormalizeNumber(metadata?.storedAtMs)
            lastMs = sabr_cacheNormalizeNumber(metadata?.lastAccessMs)
            deliveredMs = sabr_cacheNormalizeNumber(metadata?.deliveredAtMs)
        end if

        ageStored = invalid
        ageLast = invalid
        if storedMs <> invalid and storedMs > 0
            ageStored = nowMs - storedMs
        end if
        if lastMs <> invalid and lastMs > 0
            ageLast = nowMs - lastMs
        end if

        statusLabel = "pending"
        if deliveredFlag then statusLabel = "delivered"

        infoLabel = `${key} status=${statusLabel}`
        if ageStored <> invalid
            infoLabel = `${infoLabel} ageStored=${ageStored}`
        end if
        if ageLast <> invalid
            infoLabel = `${infoLabel} ageLast=${ageLast}`
        end if
        if deliveredMs <> invalid
            infoLabel = `${infoLabel} deliveredAtAge=${nowMs - deliveredMs}`
        end if

        if deliveredFlag
            deliveredCount = deliveredCount + 1
            deliveredLabels.push(infoLabel)
        else
            pendingCount = pendingCount + 1
            pendingLabels.push(infoLabel)
        end if
    end for

    labelPending = sabr_cacheBuildSample(pendingLabels)
    labelDelivered = sabr_cacheBuildSample(deliveredLabels)
    sabr_cacheLog(log_level_Type.DEBUG, `[SabrCache] state phase=${phase} total=${total} pending=${pendingCount} delivered=${deliveredCount}`)
    if pendingCount > 0
        sabr_cacheLog(log_level_Type.DEBUG, `[SabrCache] pending sample (${pendingLabels.count()} total) -> ${labelPending}`)
    end if
    if deliveredCount > 0
        sabr_cacheLog(log_level_Type.DEBUG, `[SabrCache] delivered sample (${deliveredLabels.count()} total) -> ${labelDelivered}`)
    end if
end sub

function sabr_cacheBuildSample(items as object) as string
    if not IsArray(items) then return ""
    maxItems = 10
    summary = ""
    total = items.count()
    if total = 0 then return summary
    limit = maxItems
    if total < limit then limit = total
    for idx = 0 to limit - 1
        entry = items[idx]
        if summary = ""
            summary = entry
        else
            summary = `${summary} | ${entry}`
        end if
    end for
    if total > limit
        summary = `${summary} | ...(${total - limit} more)`
    end if
    return summary
end function

function sabr_cacheFinalizeRemoval(fs as object, base as string, table as object, entry as object, metadata as object, reason as string) as string
    if not IsAssociativeArray(entry) then return ""
    fileName = entry?.fileName
    path = entry?.path
    if not IsString(fileName) or fileName = "" then return ""
    if not IsString(reason) or reason = "" then reason = "unspecified"

    sabr_cacheLog(log_level_Type.DEBUG, `[SabrCache] removing file=${fileName} reason=${reason}`)

    success = true
    if GetInterface(fs, "ifFileSystem") <> invalid and IsString(path) and path <> ""
        if fs.Exists(path)
            success = fs.Delete(path)
        end if
    end if

    if IsAssociativeArray(table) and table.DoesExist(fileName)
        table.Delete(fileName)
    end if

    focus = path
    if success and GetInterface(fs, "ifFileSystem") <> invalid
        confirmExists = fs.Exists(path)
        dirAfter = fs.GetDirectoryListing(base)
        listingLabel = ""
        if IsArray(dirAfter)
            idxCount = 0
            for each entryName in dirAfter
                if entryName = fileName then confirmExists = true
                if idxCount >= 10 then exit for
                if listingLabel = ""
                    listingLabel = entryName
                else
                    listingLabel = `${listingLabel},${entryName}`
                end if
                idxCount = idxCount + 1
            end for
        end if
        sabr_cacheLog(log_level_Type.DEBUG, `[SabrCache] post-delete verification file=${fileName} exists=${confirmExists} sampleEntries=${listingLabel}`)
        sabr_cacheLogPendingEntries(table, base, "post-delete")
    else if success = false
        sabr_cacheLog(log_level_Type.WARN, `[SabrCache] failed to delete file=${fileName}`)
    end if

    return focus
end function

function sabr_cacheExtractSize(fs as object, path as string) as integer
    if GetInterface(fs, "ifFileSystem") = invalid then return 0
    info = fs.Stat(path)
    if not IsAssociativeArray(info) then return 0
    keys = [ "size", "filesize", "length" ]
    for each key in keys
        if info.DoesExist(key)
            raw = info.Lookup(key)
            if IsInteger(raw) or IsFloat(raw) or IsDouble(raw)
                return Int(raw)
            else if IsString(raw)
                return Int(Val(raw))
            end if
        end if
    end for
    return 0
end function

function sabr_cacheExtractModifiedTicks(fs as object, path as string) as double
    if fs = invalid then return 0.0
    info = fs.Stat(path)
    if not IsAssociativeArray(info) then return 0.0

    keys = [ "modified", "modificationTime", "creationTime", "ctime", "mtime" ]
    stamp = invalid
    for each key in keys
        if info.DoesExist(key)
            stamp = info.Lookup(key)
            exit for
        end if
    end for

    if stamp = invalid then return 0.0

    if IsDateTime(stamp)
        return (stamp.AsSeconds() * 1000.0) + stamp.GetMilliseconds()
    end if

    if IsInteger(stamp) or IsFloat(stamp) or IsDouble(stamp)
        return stamp + 0.0
    end if

    return 0.0
end function

function sabr_cacheSegmentTempRoot() as string
    return `${SABR_CACHE_BASE_DIR}/segments`
end function

sub sabr_cacheDeleteDirectory(fs as object, path as string)
    if GetInterface(fs, "ifFileSystem") = invalid then return
    if not IsString(path) or path = "" then return
    try
        fs.Delete(path)
    catch e
    end try
end sub

sub sabr_cacheCleanupSegmentTemps(nowMs as integer)
    root = sabr_cacheSegmentTempRoot()
    fs = CreateObject("roFileSystem")
    if fs = invalid then return

    exists = false
    try
        exists = fs.Exists(root)
    catch e
        exists = false
    end try
    if not exists then return

    mediaDirs = fs.GetDirectoryListing(root)
    if not IsArray(mediaDirs) then return

    for each mediaName in mediaDirs
        mediaPath = `${root}/${mediaName}`
        requestDirs = fs.GetDirectoryListing(mediaPath)
        if not IsArray(requestDirs) then requestDirs = []

        for each reqName in requestDirs
            reqPath = `${mediaPath}/${reqName}`
            entries = fs.GetDirectoryListing(reqPath)
            if not IsArray(entries) or entries.count() = 0
                sabr_cacheDeleteDirectory(fs, reqPath)
            else
                latestTick = 0.0
                for each entryName in entries
                    entryPath = `${reqPath}/${entryName}`
                    stamp = sabr_cacheExtractModifiedTicks(fs, entryPath)
                    if stamp > latestTick then latestTick = stamp
                end for
                if latestTick <= 0
                    latestTick = sabr_cacheExtractModifiedTicks(fs, reqPath)
                end if
                ageMs = nowMs - Int(latestTick)
                if ageMs < 0 then ageMs = 0

                if ageMs >= SABR_CACHE_SEGMENT_TEMP_MAX_AGE_MS
                    sabr_cacheLog(log_level_Type.DEBUG, `[SabrCache] temp-cleanup dir=${reqPath} ageMs=${ageMs}`)
                    for each entryName in entries
                        entryPath = `${reqPath}/${entryName}`
                        try
                            if fs.Exists(entryPath)
                                fs.Delete(entryPath)
                            end if
                        catch e
                        end try
                    end for
                    sabr_cacheDeleteDirectory(fs, reqPath)
                end if
            end if
        end for

        remaining = fs.GetDirectoryListing(mediaPath)
        if IsArray(remaining) and remaining.count() = 0
            sabr_cacheDeleteDirectory(fs, mediaPath)
        end if
    end for

    rootEntries = fs.GetDirectoryListing(root)
    if IsArray(rootEntries) and rootEntries.count() = 0
        sabr_cacheDeleteDirectory(fs, root)
    end if
end sub

function sabr_cacheCopyFile(sourcePath as string, destPath as string) as boolean
    if not IsString(sourcePath) or sourcePath = "" then return false
    if not IsString(destPath) or destPath = "" then return false
    fs = CreateObject("roFileSystem")
    copyOk = invalid
    try
        copyOk = fs.CopyFile(sourcePath, destPath)
    catch e
        copyOk = invalid
    end try
    if copyOk = true then return true

    tempBytes = CreateObject("roByteArray")
    if tempBytes.ReadFile(sourcePath) <> true then return false
    return tempBytes.WriteFile(destPath)
end function

function sabr_cacheWriteChunksToFile(destPath as string, chunkFiles as object) as boolean
    if not IsString(destPath) or destPath = "" then return false
    if not IsArray(chunkFiles) or chunkFiles.count() = 0 then return false

    fs = CreateObject("roFileSystem")
    outFile = invalid
    useBuffer = false
    try
        outFile = fs.OpenFile(destPath, "w")
    catch e
        outFile = invalid
    end try
    if GetInterface(outFile, "ifFile") = invalid
        useBuffer = true
    end if

    if useBuffer = false
        for each chunkPath in chunkFiles
            if not IsString(chunkPath) or chunkPath = "" then continue for
            chunkBytes = CreateObject("roByteArray")
            if chunkBytes.ReadFile(chunkPath) <> true
                outFile.Close()
                try
                    fs.Delete(destPath)
                catch deleteErr
                end try
                return false
            end if
            if chunkBytes.count() = 0 then continue for
            wrote = invalid
            try
                wrote = outFile.Write(chunkBytes)
            catch writeErr
                wrote = invalid
            end try
            if wrote = invalid or wrote = false
                outFile.Close()
                try
                    fs.Delete(destPath)
                catch delErr
                end try
                return false
            end if
        end for
        outFile.Close()
        return true
    end if

    combined = CreateObject("roByteArray")
    for each chunkPath in chunkFiles
        if not IsString(chunkPath) or chunkPath = "" then continue for
        chunkBytes = CreateObject("roByteArray")
        if chunkBytes.ReadFile(chunkPath) <> true then return false
        chunkLen = chunkBytes.count()
        if chunkLen <= 0 then continue for
        startIndex = combined.count()
        combined[startIndex + chunkLen - 1] = 0
        destIndex = startIndex
        for i = 0 to chunkLen - 1
            combined[destIndex] = chunkBytes[i]
            destIndex = destIndex + 1
        end for
    end for
    return combined.WriteFile(destPath)
end function

sub sabr_cacheLogSnapshot(reason as string, focusPath as string)
    logs = sabr_cacheLogger()
    if not IsAssociativeArray(logs) then return

    base = sabr_cacheEnsureBasePath()
    fs = CreateObject("roFileSystem")
    entries = fs.GetDirectoryListing(base)
    if not IsArray(entries) then return

    limit = SABR_CACHE_LOG_SAMPLE
    summary = ""
    total = entries.count()
    if total = 0 then return

    ' simple lexicographic sort descending
    for i = 0 to total - 2
        for j = i + 1 to total - 1
            if entries[j] > entries[i]
                temp = entries[i]
                entries[i] = entries[j]
                entries[j] = temp
            end if
        end for
    end for

    for idx = 0 to total - 1
        if idx >= limit then exit for
        file = entries[idx]
        path = `${base}/${file}`
        bytes = CreateObject("roByteArray")
        sizeLabel = "?"
        if bytes.readFile(path)
            sizeLabel = sabr_cacheFormatSize(bytes.count())
        end if
        label = `${file}(${sizeLabel})`
        if summary = ""
            summary = label
        else
            summary = `${summary}, ${label}`
        end if
    end for

    focusLabel = focusPath
    if focusLabel <> "" and focusLabel.InStr("/") >= 0
        parts = focusLabel.Split("/")
        focusLabel = parts[parts.count() - 1]
    end if

    sabr_log(logs, log_level_Type.DEBUG, `[SabrCache] snapshot reason=${reason} focus=${focusLabel} -> ${summary}`)
end sub

function sabr_cacheFormatSize(sizeValue as dynamic) as string
    sizeNum = 0
    if IsInteger(sizeValue) or IsFloat(sizeValue) or IsDouble(sizeValue)
        sizeNum = sizeValue
    else if IsString(sizeValue)
        sizeNum = Val(sizeValue)
    else
        sizeNum = 0
    end if
    if sizeNum = invalid or sizeNum < 0 then return "?"
    if sizeNum < 1024 then return `${Int(sizeNum)}B`
    kb = sizeNum / 1024.0
    if kb < 1024 then return `${Int(kb + 0.5)}KB`
    mb = kb / 1024.0
    return `${Int(mb + 0.5)}MB`
end function
