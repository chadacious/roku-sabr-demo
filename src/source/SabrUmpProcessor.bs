' Lightweight BrightScript port of the TypeScript SabrUmpProcessor
' Handles decoding of SABR/UMP multipart responses so Roku clients can cache init data
' and react to server directives.

import "pkg:/source/ytproto/generated/runtime.brs"
import "pkg:/source/ytproto/generated/messages/FormatInitializationMetadata.brs"
import "pkg:/source/ytproto/generated/messages/Range.brs"
import "pkg:/source/ytproto/generated/messages/NextRequestPolicy.brs"
import "pkg:/source/ytproto/generated/messages/PlaybackCookie.brs"
import "pkg:/source/ytproto/generated/messages/SabrError.brs"
import "pkg:/source/SabrDebug.bs"
import "pkg:/source/SabrMp4Parser.bs"
import "pkg:/source/SabrUtils.bs"
import "pkg:/source/ytproto/generated/messages/SabrRedirect.brs"
import "pkg:/source/ytproto/generated/messages/SabrContextUpdate.brs"
import "pkg:/source/ytproto/generated/messages/SabrContextSendingPolicy.brs"
import "pkg:/source/ytproto/generated/messages/SnackbarMessage.brs"
import "pkg:/source/ytproto/generated/messages/StreamProtectionStatus.brs"
import "pkg:/source/ytproto/generated/messages/ReloadPlaybackContext.brs"
import "pkg:/source/ytproto/generated/messages/ReloadPlaybackParams.brs"
import "pkg:/source/ytproto/generated/messages/MediaHeader.brs"
import "pkg:/source/isItem.bs"

' UMP part identifiers used by YouTube SABR responses
const UMP_PART_ID_MEDIA_HEADER = 20
const UMP_PART_ID_MEDIA = 21
const UMP_PART_ID_MEDIA_END = 22
const UMP_PART_ID_NEXT_REQUEST_POLICY = 35
const UMP_PART_ID_FORMAT_INIT_METADATA = 42
const UMP_PART_ID_SABR_REDIRECT = 43
const UMP_PART_ID_SABR_ERROR = 44
const UMP_PART_ID_RELOAD_PLAYER_RESPONSE = 46
const UMP_PART_ID_SABR_CONTEXT_UPDATE = 57
const UMP_PART_ID_STREAM_PROTECTION_STATUS = 58
const UMP_PART_ID_SABR_CONTEXT_SENDING_POLICY = 59
const UMP_PART_ID_SNACKBAR_MESSAGE = 67

' Usage: the remaining helpers focus on scanning the SABR spool file directly.

function sabr_ump_inferVarintLength(firstByte as integer) as integer
    if firstByte < 128 then return 1
    if firstByte < 192 then return 2
    if firstByte < 224 then return 3
    if firstByte < 240 then return 4
    return 5
end function

'------------------------------------------------------------------------------
' Function : sabr_ump_finalizeVarintValue
' Purpose  : Normalizes decoded varint values into BrightScript-friendly ints
'            while preserving unsigned 32-bit values when required.
'------------------------------------------------------------------------------
function sabr_ump_finalizeVarintValue(rawValue as dynamic) as dynamic
    value = rawValue
    if (type(value) = "Float" or type(value) = "Double")
        if value >= -2147483648.0 and value <= 2147483647.0
            return int(value)
        else if value >= 0 and value <= 4294967295.0
            return value
        end if
    end if
    return value
end function

'------------------------------------------------------------------------------
' Function : sabr_ump_readVarint
' Purpose  : Reads a SABR varint from a byte array, returning the value, next
'            offset, and completion flag without throwing on malformed data.
'------------------------------------------------------------------------------
function sabr_ump_readVarint(buffer as object, offset as integer) as object
    info = {
        "value": -1
        "nextOffset": offset
        "origOffset": offset
        "complete": false
    }

    if GetInterface(buffer, "ifByteArray") = invalid then return info
    totalCount = buffer.count()
    if offset < 0 or offset >= totalCount then return info

    firstByte = buffer[offset]
    byteLength = sabr_ump_inferVarintLength(firstByte)
    if byteLength <= 0 or offset + byteLength > totalCount then return info

    cursor = offset
    value = 0.0

    if byteLength = 1
        value = buffer[cursor]
        cursor = cursor + 1
    else if byteLength = 2
        byte1 = buffer[cursor] : cursor = cursor + 1
        byte2 = buffer[cursor] : cursor = cursor + 1
        value = (byte1 and &h3f) + 64.0 * byte2
    else if byteLength = 3
        byte1 = buffer[cursor] : cursor = cursor + 1
        byte2 = buffer[cursor] : cursor = cursor + 1
        byte3 = buffer[cursor] : cursor = cursor + 1
        value = (byte1 and &h1f) + 32.0 * (byte2 + 256.0 * byte3)
    else if byteLength = 4
        byte1 = buffer[cursor] : cursor = cursor + 1
        byte2 = buffer[cursor] : cursor = cursor + 1
        byte3 = buffer[cursor] : cursor = cursor + 1
        byte4 = buffer[cursor] : cursor = cursor + 1
        value = (byte1 and &h0f) + 16.0 * (byte2 + 256.0 * (byte3 + 256.0 * byte4))
    else
        cursor = cursor + 1
        byte1 = buffer[cursor] : cursor = cursor + 1
        byte2 = buffer[cursor] : cursor = cursor + 1
        byte3 = buffer[cursor] : cursor = cursor + 1
        byte4 = buffer[cursor] : cursor = cursor + 1
        value = byte1 + 256.0 * byte2 + 65536.0 * byte3 + 16777216.0 * byte4
    end if

    info.value = sabr_ump_finalizeVarintValue(value)
    info.nextOffset = cursor
    info.complete = true
    return info
end function

'------------------------------------------------------------------------------
' Function : sabr_ump_buildSpoolPartMap
' Purpose  : Scans a SABR spool file, interprets each part header, and returns
'            structured metadata including segment linkage and summary stats.
'------------------------------------------------------------------------------
function sabr_ump_buildSpoolPartMap(path as string, maxHeaderBytes = 16 as integer, keyParam = "" as string) as dynamic
    result = {
        "parts": []
        "durationMs": 0
        "totalBytes": 0
        "reads": 0
        "sliceBytes": maxHeaderBytes
    }
    if not IsString(path) or path = "" then return result

    fs = CreateObject("roFileSystem")
    stat = invalid
    try
        stat = fs.Stat(path)
    catch e
        stat = invalid
    end try
    totalSize = invalid
    if IsAssociativeArray(stat)
        totalSize = stat.Lookup("size")
        if totalSize = invalid then totalSize = stat.Lookup("length")
    end if
    if totalSize = invalid then return result
    if totalSize <= 0 then
        result.totalBytes = 0
        return result
    end if

    timer = CreateObject("roTimespan")
    if timer <> invalid then timer.Mark()

    parts = []
    headerIndex = createObject("roAssociativeArray")
    segmentIndex = createObject("roAssociativeArray")
    headerToSegmentKey = createObject("roAssociativeArray")
    suffixBase = sabr_ump_toSafeString(keyParam)
    currentHeaderId = invalid
    offset = 0
    actualBytesRead = 0
    while offset < totalSize
        remaining = totalSize - offset
        sliceLength = maxHeaderBytes
        if sliceLength > remaining then sliceLength = remaining
        if sliceLength <= 0 then exit while

        headerBytes = CreateObject("roByteArray")
        if headerBytes.ReadFile(path, offset, sliceLength) <> true
            result["error"] = "read_failed"
            result["errorOffset"] = offset
            exit while
        end if
        result.reads = result.reads + 1
        actualBytesRead = actualBytesRead + sliceLength

        typeInfo = sabr_ump_readVarint(headerBytes, 0)
        if typeInfo.complete <> true
            result["error"] = "type_incomplete"
            result["errorOffset"] = offset
            exit while
        end if

        sizeInfo = sabr_ump_readVarint(headerBytes, typeInfo.nextOffset)
        if sizeInfo.complete <> true
            result["error"] = "size_incomplete"
            result["errorOffset"] = offset
            exit while
        end if

        partType = sabr_ump_toInt(typeInfo.value)
        partSize = sabr_ump_toInt(sizeInfo.value)
        headerLength = sizeInfo.nextOffset

        if partSize = invalid or partSize < 0
            result["error"] = "invalid_size"
            result["errorOffset"] = offset
            exit while
        end if

        partEntry = {
            "type": partType
            "typeLabel": sabr_ump_partTypeLabel(partType)
            "offset": offset
            "headerBytes": headerLength
            "payloadOffset": offset + headerLength
            "payloadSize": partSize
            "payloadEnd": (offset + headerLength + partSize) - 1
            "totalLength": headerLength + partSize
        }

        if partType = UMP_PART_ID_MEDIA_HEADER
            headerData = CreateObject("roByteArray")
            if partSize > 0 and headerData.ReadFile(path, partEntry.payloadOffset, partSize) = true
                result.reads = result.reads + 1
                actualBytesRead = actualBytesRead + partSize
                decodedHeader = sabr_ump_decodePart(MediaHeaderDecode, headerData, invalid, "spool_media_header")
                ' headerRecord = decodedHeader
                if IsAssociativeArray(decodedHeader)
                    headerIdVal = sabr_ump_toInt(decodedHeader.Lookup("headerId"))
                    itagVal = sabr_ump_toInt(decodedHeader.Lookup("itag"))
                    isInitFlag = decodedHeader.Lookup("isInitSeg") = true
                    rangeStartVal = sabr_ump_toInt(decodedHeader.Lookup("startRange"))
                    contentLengthVal = sabr_ump_toInt(decodedHeader.Lookup("contentLength"))
                    rangeEndVal = invalid
                    if rangeStartVal <> invalid and contentLengthVal <> invalid and contentLengthVal > 0
                        rangeEndVal = rangeStartVal + contentLengthVal - 1
                    end if

                    partEntry["mediaHeader"] = decodedHeader
                    if headerIdVal <> invalid then partEntry["headerId"] = headerIdVal
                    if itagVal <> invalid then partEntry["itag"] = itagVal
                    if isInitFlag then partEntry["segmentIsInit"] = true
                    if rangeStartVal <> invalid then partEntry["segmentRangeStart"] = rangeStartVal
                    if rangeEndVal <> invalid then partEntry["segmentRangeEnd"] = rangeEndVal

                    headerRecord = {
                        "headerId": headerIdVal
                        "itag": itagVal
                        "segmentIsInit": isInitFlag
                    }
                    headerRecord["mediaHeader"] = decodedHeader
                    if rangeStartVal <> invalid then headerRecord["segmentRangeStart"] = rangeStartVal
                    if rangeEndVal <> invalid then headerRecord["segmentRangeEnd"] = rangeEndVal
                    if contentLengthVal <> invalid and contentLengthVal > 0
                        partEntry["segmentContentLength"] = contentLengthVal
                        headerRecord["segmentContentLength"] = contentLengthVal
                    end if
                    if headerIdVal <> invalid
                        headerKey = sabr_ump_toSafeString(headerIdVal)
                        if headerKey <> ""
                            headerIndex[headerKey] = headerRecord
                        end if
                        currentHeaderId = headerIdVal
                    else
                        currentHeaderId = invalid
                    end if
                else
                    currentHeaderId = invalid
                end if
            else
                currentHeaderId = invalid
            end if
        else if partType = UMP_PART_ID_MEDIA or partType = UMP_PART_ID_MEDIA_END
            headerIdVal = invalid
            if partSize > 0
                peekLength = maxHeaderBytes
                if partType = UMP_PART_ID_MEDIA_END and peekLength > 1 then peekLength = 1
                if peekLength > partSize then peekLength = partSize
                if peekLength > 0
                    peekBytes = CreateObject("roByteArray")
                    if peekBytes.ReadFile(path, partEntry.payloadOffset, peekLength) = true
                        result.reads = result.reads + 1
                        actualBytesRead = actualBytesRead + peekLength
                        if partType = UMP_PART_ID_MEDIA
                            headerVar = sabr_ump_readVarint(peekBytes, 0)
                            if headerVar.complete = true
                                headerIdVal = sabr_ump_toInt(headerVar.value)
                            end if
                        else if partType = UMP_PART_ID_MEDIA_END
                            if peekBytes.count() > 0
                                headerIdVal = peekBytes[0]
                            else
                                headerIdVal = invalid
                            end if
                        end if
                    end if
                end if
            end if

            if headerIdVal <> invalid
                partEntry["headerId"] = headerIdVal
                headerKey = sabr_ump_toSafeString(headerIdVal)
                headerRecord = invalid
                if headerKey <> "" and headerIndex.DoesExist(headerKey)
                    headerRecord = headerIndex.Lookup(headerKey)
                else if currentHeaderId <> invalid and headerIdVal = currentHeaderId
                    currentKey = sabr_ump_toSafeString(currentHeaderId)
                    if currentKey <> "" and headerIndex.DoesExist(currentKey)
                        headerRecord = headerIndex.Lookup(currentKey)
                    end if
                end if
                if IsAssociativeArray(headerRecord)
                    if headerRecord.DoesExist("itag") then partEntry["itag"] = headerRecord.itag
                    if headerRecord.DoesExist("segmentIsInit") and headerRecord.segmentIsInit = true
                        partEntry["segmentIsInit"] = true
                    end if
                    if headerRecord.DoesExist("mediaHeader") then partEntry["mediaHeader"] = headerRecord.mediaHeader
                    if headerRecord.DoesExist("segmentRangeStart")
                        partEntry["segmentRangeStart"] = headerRecord.segmentRangeStart
                    end if
                    if headerRecord.DoesExist("segmentRangeEnd")
                        partEntry["segmentRangeEnd"] = headerRecord.segmentRangeEnd
                    end if
                    if headerRecord.DoesExist("segmentContentLength")
                        partEntry["segmentContentLength"] = headerRecord.segmentContentLength
                    end if
                end if
            end if

            if partType = UMP_PART_ID_MEDIA_END
                currentHeaderId = invalid
            end if
        end if

        parts.push(partEntry)

        if IsAssociativeArray(partEntry)
            partTypeVal = sabr_ump_toInt(partEntry?.type)
            headerIdForPart = sabr_ump_toInt(partEntry?.headerId)
            if headerIdForPart <> invalid and (partTypeVal = UMP_PART_ID_MEDIA_HEADER or partTypeVal = UMP_PART_ID_MEDIA)
                headerKeyLabel = sabr_ump_toSafeString(headerIdForPart)
                existingSegmentKey = invalid
                if headerKeyLabel <> "" and headerToSegmentKey.DoesExist(headerKeyLabel)
                    existingSegmentKey = headerToSegmentKey.Lookup(headerKeyLabel)
                end if

                if partTypeVal = UMP_PART_ID_MEDIA_HEADER or existingSegmentKey = invalid
                    startRangeVal = sabr_ump_toInt(partEntry?.segmentRangeStart)
                    mediaHeader = partEntry?.mediaHeader
                    if startRangeVal = invalid and IsAssociativeArray(mediaHeader)
                        startRangeVal = sabr_ump_toInt(mediaHeader?.startRange)
                        if startRangeVal = invalid then startRangeVal = sabr_ump_toInt(mediaHeader?.start)
                    end if

                    endRangeVal = sabr_ump_toInt(partEntry?.segmentRangeEnd)
                    if endRangeVal = invalid and IsAssociativeArray(mediaHeader)
                        contentLengthVal = sabr_ump_toInt(mediaHeader?.contentLength)
                        if contentLengthVal <> invalid and contentLengthVal > 0 and startRangeVal <> invalid
                            endRangeVal = startRangeVal + contentLengthVal - 1
                        end if
                    end if

                    suffixLabel = suffixBase
                    if suffixLabel = "" then suffixLabel = sabr_ump_toSafeString(partEntry?.itag)
                    if suffixLabel <> ""
                        suffixLastChar = Mid(suffixLabel, Len(suffixLabel), 1)
                        if suffixLastChar <> ":"
                            suffixLabel = `${suffixLabel}:`
                        end if
                    end if

                    startLabel = sabr_ump_toSafeString(startRangeVal)
                    if startLabel = "" then startLabel = "0"
                    segmentKey = suffixLabel <> "" ? `${startLabel}:${suffixLabel}` : `${startLabel}:`

                    segmentRecord = invalid
                    if segmentKey <> "" and segmentIndex.DoesExist(segmentKey)
                        segmentRecord = segmentIndex.Lookup(segmentKey)
                    end if
                    if segmentRecord = invalid
                        segmentRecord = {
                            "path": path
                            "headerId": headerIdForPart
                            "startRange": startRangeVal
                            "endRange": endRangeVal
                            "isInitSeg": (partEntry?.segmentIsInit = true)
                            "chunks": []
                        }
                        segmentRecord["mediaHeader"] = mediaHeader
                        segmentRecord["itag"] = sabr_ump_toInt(partEntry?.itag)
                        segmentRecord["totalBytes"] = 0
                    else
                        if segmentRecord.startRange = invalid then segmentRecord.startRange = startRangeVal
                        if segmentRecord.endRange = invalid then segmentRecord.endRange = endRangeVal
                        if segmentRecord.mediaHeader = invalid and IsAssociativeArray(mediaHeader)
                            segmentRecord.mediaHeader = mediaHeader
                        end if
                        if partEntry?.segmentIsInit = true then segmentRecord.isInitSeg = true
                        if segmentRecord.DoesExist("itag") = false or segmentRecord.itag = invalid
                            segmentRecord["itag"] = sabr_ump_toInt(partEntry?.itag)
                        end if
                    end if

                    if segmentKey <> ""
                        segmentIndex[segmentKey] = segmentRecord
                        if headerKeyLabel <> ""
                            headerToSegmentKey[headerKeyLabel] = segmentKey
                        end if
                        existingSegmentKey = segmentKey
                    end if
                end if

                if partTypeVal = UMP_PART_ID_MEDIA and existingSegmentKey <> invalid and existingSegmentKey <> ""
                    if segmentIndex.DoesExist(existingSegmentKey)
                        segmentRecord = segmentIndex.Lookup(existingSegmentKey)
                        chunks = segmentRecord?.chunks
                        if not IsArray(chunks) then chunks = []

                        payloadOffsetVal = sabr_ump_toInt(partEntry?.payloadOffset)
                        payloadSizeVal = sabr_ump_toInt(partEntry?.payloadSize)
                        if payloadOffsetVal <> invalid and payloadSizeVal <> invalid and payloadSizeVal > 1
                            chunk = {
                                "offset": payloadOffsetVal + 1
                                "length": payloadSizeVal - 1
                            }
                            if chunk.length > 0
                                chunks.push(chunk)
                                segmentRecord["chunks"] = chunks
                                totalBytesVal = sabr_ump_toInt(segmentRecord?.totalBytes)
                                if totalBytesVal = invalid then totalBytesVal = 0
                                segmentRecord["totalBytes"] = totalBytesVal + chunk.length
                                segmentIndex[existingSegmentKey] = segmentRecord
                            end if
                        end if
                    end if
                end if
            end if
        end if

        nextOffset = offset + headerLength + partSize
        if nextOffset <= offset
            result["error"] = "non_progress"
            result["errorOffset"] = offset
            exit while
        end if
        offset = nextOffset
    end while

    if IsAssociativeArray(segmentIndex)
        for each segmentKey in segmentIndex
            entry = segmentIndex.Lookup(segmentKey)
            if entry?.isInitSeg = true
                sidxUpdate = sabr_ump_extractSidxFromSpool(path, entry)
                if IsAssociativeArray(sidxUpdate)
                    entry["sidxIndex"] = sidxUpdate
                    segmentIndex[segmentKey] = entry
                end if
            end if
        end for
    end if

    result["parts"] = parts
    result["segmentIndex"] = segmentIndex
    result["segmentMap"] = sabr_ump_buildSpoolSegmentMap(parts, keyParam, path)
    result["totalBytes"] = totalSize
    result["actualBytesRead"] = actualBytesRead
    result["partCount"] = parts.count()
    containsInit = false
    for each partSummary in parts
        if IsAssociativeArray(partSummary)
            if partSummary.DoesExist("segmentIsInit") and partSummary.segmentIsInit = true
                containsInit = true
                exit for
            end if
        end if
    end for
    if containsInit then result["containsInit"] = true
    if timer <> invalid
        result["durationMs"] = Int(timer.TotalMilliseconds())
    end if
    if not result.DoesExist("error") and offset >= totalSize
        result["complete"] = true
    end if
    result["bytesScanned"] = offset
    return result
end function

'------------------------------------------------------------------------------
' Function : sabr_ump_buildSpoolSegmentMap
' Purpose  : Groups raw UMP parts into higher-level segment records (media,
'            init, control metadata) to support direct streaming from spool files.
'------------------------------------------------------------------------------
function sabr_ump_buildSpoolSegmentMap(partArray as object, keyParam as string, path as string) as object
    segmentMap = {}
    if not IsArray(partArray) then return segmentMap

    suffixBase = sabr_ump_toSafeString(keyParam)

    for each part in partArray
        if not IsAssociativeArray(part) then continue for
        ' if part.type = UMP_PART_ID_MEDIA_HEADER then headerOffsetBytes = sabr_ump_toInt(part?.headerBytes)
        if part?.type <> UMP_PART_ID_MEDIA then continue for

        payloadOffset = sabr_ump_toInt(part?.payloadOffset) + part.headerBytes - 1
        payloadSize = sabr_ump_toInt(part?.payloadSize)
        if payloadOffset = invalid or payloadSize = invalid or payloadSize <= 0 then continue for

        mediaHeader = part?.mediaHeader
        rangeStart = sabr_ump_toInt(part?.segmentRangeStart)
        if rangeStart = invalid and IsAssociativeArray(mediaHeader)
            rangeStart = sabr_ump_toInt(mediaHeader?.startRange)
            if rangeStart = invalid then rangeStart = sabr_ump_toInt(mediaHeader?.start)
        end if
        if rangeStart = invalid then continue for

        rangeEnd = sabr_ump_toInt(part?.segmentRangeEnd)
        if rangeEnd = invalid and IsAssociativeArray(mediaHeader)
            contentLength = sabr_ump_toInt(mediaHeader?.contentLength)
            if contentLength <> invalid and contentLength > 0
                rangeEnd = rangeStart + contentLength - 1
            end if
        end if

        itagVal = sabr_ump_toSafeString(part?.itag)
        if itagVal = "" and IsAssociativeArray(mediaHeader)
            itagVal = sabr_ump_toSafeString(mediaHeader?.itag)
        end if

        suffixLabel = suffixBase
        if suffixLabel = "" then suffixLabel = itagVal
        if suffixLabel <> "" and Right(suffixLabel, 1) <> ":"
            suffixLabel = `${suffixLabel}:`
        end if

        startLabel = sabr_ump_toSafeString(rangeStart)
        if startLabel = "" then startLabel = "0"
        key = suffixLabel <> "" ? `${startLabel}:${suffixLabel}` : `${startLabel}:`

        entry = {
            "payloadOffset": payloadOffset
            "payloadSize": payloadSize
            "payloadEnd": sabr_ump_toInt(part?.payloadEnd)
            "headerId": sabr_ump_toInt(part?.headerId)
            "itag": sabr_ump_toInt(part?.itag)
            "startRange": rangeStart
            "endRange": rangeEnd
            "isInitSeg": (part?.segmentIsInit = true)
            "path": path
        }
        if entry.payloadEnd = invalid
            entry.payloadEnd = payloadOffset + payloadSize - 1
        end if
        if IsAssociativeArray(mediaHeader)
            entry["mediaHeader"] = mediaHeader
        end if

        segmentMap[key] = entry
    end for

    return segmentMap
end function

' Reads bytes for a specific part payload from the spool file.
'------------------------------------------------------------------------------
' Function : sabr_ump_readSpoolPayload
' Purpose  : Reads a chunk of bytes from the SABR spool file while guarding
'            against invalid offsets or lengths.
'------------------------------------------------------------------------------
function sabr_ump_readSpoolPayload(path as string, offset as dynamic, length as dynamic) as dynamic
    safeOffset = sabr_ump_toInt(offset)
    if safeOffset = invalid or safeOffset < 0 then return invalid
    safeLength = sabr_ump_toInt(length)
    if safeLength = invalid or safeLength <= 0 then return invalid
    if not IsString(path) or path = "" then return invalid
    bytes = CreateObject("roByteArray")
    if bytes.ReadFile(path, safeOffset, safeLength) <> true then return invalid
    return bytes
end function

function sabr_ump_materializeInitSegment(entry as object, spoolPath as string, mediaIdHash as string, contentType as string, keyParam as string) as string
    if not IsAssociativeArray(entry) then return ""
    if entry?.isInitSeg <> true then return ""
    if not IsString(spoolPath) or spoolPath = "" then return ""
    if not IsString(mediaIdHash) or mediaIdHash = "" then return ""

    payloadOffset = sabr_ump_toInt(entry?.payloadOffset)
    payloadSize = sabr_ump_toInt(entry?.payloadSize)
    if payloadOffset = invalid or payloadSize = invalid or payloadSize <= 0 then return ""

    typeLabel = contentType
    if not IsString(typeLabel) or typeLabel = "" then typeLabel = "unknown"

    keyLabel = sabr_ump_toSafeString(keyParam)
    if keyLabel = "" then keyLabel = "nokey"

    itagLabel = sabr_ump_toSafeString(entry?.itag)
    if itagLabel = "" then itagLabel = "noitag"

    baseDir = `tmp:/${mediaIdHash}`
    fs = CreateObject("roFileSystem")
    fs.CreateDirectory(baseDir)
    fileName = sabr_ump_sanitizeForFilename(`init-${typeLabel}-${keyLabel}-${itagLabel}.mp4`)
    if fileName = "" then fileName = "init.mp4"
    targetPath = `${baseDir}/${fileName}`

    if fs.Exists(targetPath) then return targetPath

    payloadBytes = sabr_ump_readSpoolPayload(spoolPath, payloadOffset, payloadSize)
    if GetInterface(payloadBytes, "ifByteArray") = invalid or payloadBytes.count() = 0 then return ""

    if payloadBytes.WriteFile(targetPath) <> true then return ""

    return targetPath
end function

' Pulls non-media UMP parts (policies, errors, redirects, etc.) out of the spool.
'------------------------------------------------------------------------------
' Function : sabr_ump_extractControlParts
' Purpose  : Collects non-media UMP parts (policies, context updates, errors)
'            so the streaming adapter can update its state machine quickly.
'------------------------------------------------------------------------------
function sabr_ump_extractControlParts(spoolMap as object, path as string, mediaIdHash = "" as string, contentType = "" as string, keyParam = "" as string) as object
    results = {}
    if not IsAssociativeArray(spoolMap) then return results

    if IsString(mediaIdHash) and mediaIdHash <> "" and IsString(path) and path <> ""
        segmentIndex = spoolMap?.segmentIndex
        if IsAssociativeArray(segmentIndex)
            safeKeyLabel = sabr_ump_sanitizeForFilename(sabr_ump_toSafeString(keyParam))
            if safeKeyLabel = "" then safeKeyLabel = "nokey"
            safeTypeLabel = sabr_ump_sanitizeForFilename(sabr_ump_toSafeString(contentType))
            if safeTypeLabel = "" then safeTypeLabel = "unknown"
            baseDir = `tmp:/${mediaIdHash}`
            fs = CreateObject("roFileSystem")
            if fs <> invalid
                fs.CreateDirectory(baseDir)
                targetPath = `${baseDir}/init-${safeKeyLabel}-${safeTypeLabel}.bin`
                targetExists = fs.Exists(targetPath)
                keys = segmentIndex.Keys()
                if IsArray(keys)
                    for each segmentKey in keys
                        segEntry = segmentIndex.Lookup(segmentKey)
                        if not IsAssociativeArray(segEntry) then continue for
                        if segEntry?.isInitSeg <> true then continue for
                        if targetExists <> true
                            chunkData = sabr_ump_readChunksFromSpool(path, segEntry?.chunks, sabr_ump_toInt(segEntry?.totalBytes))
                            if GetInterface(chunkData, "ifByteArray") = invalid or chunkData.count() <= 0 then continue for
                            if chunkData.WriteFile(targetPath) = true
                                targetExists = true
                            else
                                continue for
                            end if
                        end if
                        if targetExists = true
                            segEntry["initPath"] = targetPath
                            segmentIndex[segmentKey] = segEntry
                            exit for
                        end if
                    end for
                end if
                if targetExists = true
                    results["initSegmentPath"] = targetPath
                end if
            end if
        end if
    end if

    parts = spoolMap?.parts
    if not IsArray(parts) or parts.count() = 0 then return results

    for each part in parts
        partType = sabr_ump_toInt(part?.type)
        if partType = invalid then partType = sabr_ump_toInt(part?.typeId)
        if partType = UMP_PART_ID_NEXT_REQUEST_POLICY or partType = UMP_PART_ID_SABR_CONTEXT_UPDATE or partType = UMP_PART_ID_SABR_CONTEXT_SENDING_POLICY or partType = UMP_PART_ID_SABR_REDIRECT or partType = UMP_PART_ID_SABR_ERROR or partType = UMP_PART_ID_RELOAD_PLAYER_RESPONSE
            payload = sabr_ump_readSpoolPayload(path, part?.payloadOffset, part?.payloadSize)
            if GetInterface(payload, "ifByteArray") = invalid or payload.count() = 0 then continue for
            if partType = UMP_PART_ID_NEXT_REQUEST_POLICY
                decoded = sabr_ump_decodePart(NextRequestPolicyDecode, payload, invalid, "spool_next_request_policy")
                if isValid(decoded)
                    results["nextRequestPolicy"] = decoded
                end if
            else if partType = UMP_PART_ID_SABR_CONTEXT_UPDATE
                decoded = sabr_ump_decodePart(SabrContextUpdateDecode, payload, invalid, "spool_context_update")
                if isValid(decoded)
                    results["sabrContextUpdate"] = decoded
                end if
            else if partType = UMP_PART_ID_SABR_CONTEXT_SENDING_POLICY
                decoded = sabr_ump_decodePart(SabrContextSendingPolicyDecode, payload, invalid, "spool_context_sending_policy")
                if isValid(decoded)
                    results["sabrContextSendingPolicy"] = decoded
                end if
            else if partType = UMP_PART_ID_SABR_REDIRECT
                decoded = sabr_ump_decodePart(SabrRedirectDecode, payload, invalid, "spool_redirect")
                if isValid(decoded)
                    results["redirect"] = decoded
                end if
            else if partType = UMP_PART_ID_SABR_ERROR
                decoded = sabr_ump_decodePart(SabrErrorDecode, payload, invalid, "spool_sabr_error")
                if isValid(decoded)
                    results["sabrError"] = decoded
                end if
            else if partType = UMP_PART_ID_RELOAD_PLAYER_RESPONSE
                decoded = sabr_ump_decodePart(ReloadPlaybackContextDecode, payload, invalid, "spool_reload_playback_response")
                if isValid(decoded)
                    results["reloadPlaybackContext"] = decoded
                end if
            end if
        end if
    end for

    return results
end function

'------------------------------------------------------------------------------
' Function : sabr_ump_extractSidxFromSpool
' Purpose  : Parses the SIDX box from an init segment within the spool to
'            build seekable timing metadata for subsequent requests.
'------------------------------------------------------------------------------
function sabr_ump_extractSidxFromSpool(path as string, segmentEntry as object) as dynamic
    if not IsAssociativeArray(segmentEntry) then return invalid
    if segmentEntry?.isInitSeg <> true then return invalid
    if not IsString(path) or path = "" then return invalid

    mediaHeader = segmentEntry?.mediaHeader
    if not IsAssociativeArray(mediaHeader) then return invalid

    chunks = segmentEntry?.chunks
    if not IsArray(chunks) or chunks.count() = 0 then return invalid

    segmentBytes = sabr_ump_readChunksFromSpool(path, chunks, sabr_ump_toInt(segmentEntry?.totalBytes))
    if GetInterface(segmentBytes, "ifByteArray") = invalid or segmentBytes.count() <= 0 then return invalid

    return sabr_ump_buildSidxIndexUpdate(invalid, mediaHeader, segmentBytes)
end function

'------------------------------------------------------------------------------
' Function : sabr_ump_readChunksFromSpool
' Purpose  : Materializes chunk byte ranges into memory or the aggregation
'            structure so streaming can read contiguous data efficiently.
'------------------------------------------------------------------------------
function sabr_ump_readChunksFromSpool(path as string, chunks as object, declaredTotal = invalid as dynamic) as object
    if not IsArray(chunks) or chunks.count() = 0 then return invalid

    sortedChunks = []
    for each entry in chunks
        if not IsAssociativeArray(entry) then continue for
        offsetVal = sabr_ump_toInt(entry?.offset)
        lengthVal = sabr_ump_toInt(entry?.length)
        if offsetVal = invalid or lengthVal = invalid or lengthVal <= 0 then continue for
        sortedChunks.push({
            "offset": offsetVal
            "length": lengthVal
        })
    end for

    totalChunks = sortedChunks.count()
    if totalChunks = 0 then return invalid

    ' simple insertion sort by offset
    for i = 0 to totalChunks - 2
        minIndex = i
        for j = i + 1 to totalChunks - 1
            if sortedChunks[j].offset < sortedChunks[minIndex].offset then minIndex = j
        end for
        if minIndex <> i
            temp = sortedChunks[i]
            sortedChunks[i] = sortedChunks[minIndex]
            sortedChunks[minIndex] = temp
        end if
    end for

    totalBytes = sabr_ump_toInt(declaredTotal)
    if totalBytes = invalid or totalBytes <= 0
        totalBytes = 0
        for each chunkInfo in sortedChunks
            totalBytes = totalBytes + chunkInfo.length
        end for
    end if
    if totalBytes <= 0 then return invalid

    aggregate = CreateObject("roByteArray")
    aggregate[totalBytes - 1] = 0
    destIndex = 0

    for each chunkInfo in sortedChunks
        chunkBytes = CreateObject("roByteArray")
        if chunkBytes.ReadFile(path, chunkInfo.offset, chunkInfo.length) <> true then return invalid
        chunkLen = chunkBytes.count()
        if chunkLen <= 0 then return invalid
        for idx = 0 to chunkLen - 1
            aggregate[destIndex] = chunkBytes[idx]
            destIndex = destIndex + 1
        end for
    end for

    if destIndex < totalBytes
        ' trim unused tail
        trimmed = CreateObject("roByteArray")
        if destIndex > 0
            trimmed[destIndex - 1] = 0
            for k = 0 to destIndex - 1
                trimmed[k] = aggregate[k]
            end for
        end if
        return trimmed
    end if

    return aggregate
end function

'------------------------------------------------------------------------------
' Function : sabr_ump_partTypeLabel
' Purpose  : Provides a human-readable label for UMP part IDs to improve logs
'            and debugging output.
'------------------------------------------------------------------------------
function sabr_ump_partTypeLabel(partType as integer) as string
    if partType = UMP_PART_ID_MEDIA_HEADER then return "MEDIA_HEADER"
    if partType = UMP_PART_ID_MEDIA then return "MEDIA"
    if partType = UMP_PART_ID_MEDIA_END then return "MEDIA_END"
    if partType = UMP_PART_ID_NEXT_REQUEST_POLICY then return "NEXT_REQUEST_POLICY"
    if partType = UMP_PART_ID_FORMAT_INIT_METADATA then return "FORMAT_INIT_METADATA"
    if partType = UMP_PART_ID_SABR_REDIRECT then return "SABR_REDIRECT"
    if partType = UMP_PART_ID_SABR_ERROR then return "SABR_ERROR"
    if partType = UMP_PART_ID_RELOAD_PLAYER_RESPONSE then return "RELOAD_PLAYBACK_CONTEXT"
    if partType = UMP_PART_ID_SABR_CONTEXT_UPDATE then return "SABR_CONTEXT_UPDATE"
    if partType = UMP_PART_ID_STREAM_PROTECTION_STATUS then return "STREAM_PROTECTION_STATUS"
    if partType = UMP_PART_ID_SABR_CONTEXT_SENDING_POLICY then return "SABR_CONTEXT_SENDING_POLICY"
    if partType = UMP_PART_ID_SNACKBAR_MESSAGE then return "SNACKBAR_MESSAGE"
    return `${partType}`
end function

'------------------------------------------------------------------------------
' Function : sabr_ump_decodePart
' Purpose  : Helper that safely decodes a payload subsection using a provided
'            protobuf decoder, logging failures and falling back to defaults.
'------------------------------------------------------------------------------
function sabr_ump_decodePart(decodeFunc as dynamic, payload as dynamic, defaultValue = invalid as dynamic, label = "" as string) as dynamic
    if decodeFunc = invalid then return defaultValue
    if not isValid(payload) then return defaultValue

    encoded = invalid
    if GetInterface(payload, "ifByteArray") <> invalid
        encoded = payload.ToBase64String()
    else if IsString(payload)
        encoded = payload
    end if
    if not IsString(encoded) or encoded = "" then return defaultValue

    result = defaultValue
    success = true
    try
        result = decodeFunc(encoded)
    catch e
        success = false
    end try
    if success then return result
    return defaultValue
end function

'------------------------------------------------------------------------------
' Function : sabr_ump_buildSidxIndexUpdate
' Purpose  : Creates the normalized structure stored in playback context when
'            new SIDX information is discovered in a spool payload.
'------------------------------------------------------------------------------
function sabr_ump_buildSidxIndexUpdate(existing as dynamic, mediaHeader as object, segmentBytes as object) as dynamic
    if GetInterface(segmentBytes, "ifByteArray") = invalid or segmentBytes.count() <= 0 then return invalid

    indexInfo = sabr_mp4_extractSidxIndex(segmentBytes)
    if not IsAssociativeArray(indexInfo) then return invalid

    timescale = sabr_toInt(indexInfo?.timescale)
    if timescale = invalid or timescale <= 0 then timescale = 1

    entries = []
    accumulated = 0
    references = indexInfo?.references
    if IsArray(references)
        for each reference in references
            if not IsAssociativeArray(reference) then continue for
            duration = sabr_toInt(reference?.subsegmentDuration)
            if duration = invalid or duration < 0 then duration = 0
            startMs = int((accumulated * 1000.0) / timescale)
            durationMs = int((duration * 1000.0) / timescale)
            rangeStart = sabr_toInt(reference?.rangeStart)
            if rangeStart = invalid then rangeStart = int(reference?.rangeStart)
            rangeEnd = sabr_toInt(reference?.rangeEnd)
            if rangeEnd = invalid then rangeEnd = int(reference?.rangeEnd)
            entries.push({
                "rangeStart": rangeStart
                "rangeEnd": rangeEnd
                "startTimeMs": startMs
                "durationMs": durationMs
                "referenceType": sabr_toInt(reference?.referenceType)
            })
            accumulated = accumulated + duration
        end for
    end if

    formatKey = ""
    formatInfo = mediaHeader?.formatId
    if not IsAssociativeArray(formatInfo)
        formatInfo = mediaHeader?.format
    end if
    if IsAssociativeArray(formatInfo)
        itagLabel = sabr_valueToLabel(formatInfo.Lookup("itag"))
        xtagLabel = sabr_valueToLabel(formatInfo.Lookup("xtags"))
        formatKey = `${itagLabel}:${xtagLabel}`
    else
        itagLabel = sabr_valueToLabel(mediaHeader?.itag)
        xtagLabel = sabr_valueToLabel(mediaHeader?.xtags)
        formatKey = `${itagLabel}:${xtagLabel}`
    end if
    if formatKey = ":" then formatKey = ""

    contentType = `${mediaHeader?.contentType ?? ""}`
    if contentType = "" and IsAssociativeArray(mediaHeader?.format)
        contentType = `${mediaHeader.format?.contentType ?? ""}`
    end if

    update = {
        "formatKey": formatKey
        "entries": entries
        "timescale": timescale
        "earliestPresentationTime": indexInfo?.earliestPresentationTime
        "contentType": contentType
    }

    if entries.count() = 0
        update["unsupportedReason"] = "empty_sidx"
    end if

    return update
end function
