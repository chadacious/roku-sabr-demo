' Lightweight BrightScript port of the TypeScript SabrUmpProcessor
' Handles decoding of SABR/UMP multipart responses so Roku clients can cache init data
' and react to server directives.

import "pkg:/source/ytproto/generated/runtime.brs"
import "pkg:/source/ytproto/generated/messages/FormatInitializationMetadata.brs"
import "pkg:/source/ytproto/generated/messages/Range.brs"
import "pkg:/source/ytproto/generated/messages/NextRequestPolicy.brs"
import "pkg:/source/ytproto/generated/messages/PlaybackCookie.brs"
import "pkg:/source/ytproto/generated/messages/SabrError.brs"
import "pkg:/source/SabrDebug.bs"
import "pkg:/source/SabrMp4Parser.bs"
import "pkg:/source/SabrUtils.bs"
import "pkg:/source/ytproto/generated/messages/SabrRedirect.brs"
import "pkg:/source/ytproto/generated/messages/SabrContextUpdate.brs"
import "pkg:/source/ytproto/generated/messages/SabrContextSendingPolicy.brs"
import "pkg:/source/ytproto/generated/messages/SnackbarMessage.brs"
import "pkg:/source/ytproto/generated/messages/StreamProtectionStatus.brs"
import "pkg:/source/ytproto/generated/messages/ReloadPlaybackContext.brs"
import "pkg:/source/ytproto/generated/messages/ReloadPlaybackParams.brs"
import "pkg:/source/ytproto/generated/messages/MediaHeader.brs"
import "pkg:/source/isItem.bs"

' UMP part identifiers used by YouTube SABR responses
const UMP_PART_ID_MEDIA_HEADER = 20
const UMP_PART_ID_MEDIA = 21
const UMP_PART_ID_MEDIA_END = 22
const UMP_PART_ID_NEXT_REQUEST_POLICY = 35
const UMP_PART_ID_FORMAT_INIT_METADATA = 42
const UMP_PART_ID_SABR_REDIRECT = 43
const UMP_PART_ID_SABR_ERROR = 44
const UMP_PART_ID_RELOAD_PLAYER_RESPONSE = 46
const UMP_PART_ID_SABR_CONTEXT_UPDATE = 57
const UMP_PART_ID_STREAM_PROTECTION_STATUS = 58
const UMP_PART_ID_SABR_CONTEXT_SENDING_POLICY = 59
const UMP_PART_ID_SNACKBAR_MESSAGE = 67

' Usage: the remaining helpers focus on scanning the SABR spool file directly.

function sabr_ump_inferVarintLength(firstByte as integer) as integer
    if firstByte < 128 then return 1
    if firstByte < 192 then return 2
    if firstByte < 224 then return 3
    if firstByte < 240 then return 4
    return 5
end function

'------------------------------------------------------------------------------
' Function : sabr_ump_finalizeVarintValue
' Purpose  : Normalizes decoded varint values into BrightScript-friendly ints
'            while preserving unsigned 32-bit values when required.
'------------------------------------------------------------------------------
function sabr_ump_finalizeVarintValue(rawValue as dynamic) as dynamic
    value = rawValue
    if (type(value) = "Float" or type(value) = "Double")
        if value >= -2147483648.0 and value <= 2147483647.0
            return int(value)
        else if value >= 0 and value <= 4294967295.0
            return value
        end if
    end if
    return value
end function

'------------------------------------------------------------------------------
' Function : sabr_ump_readVarint
' Purpose  : Reads a SABR varint from a byte array, returning the value, next
'            offset, and completion flag without throwing on malformed data.
'------------------------------------------------------------------------------
function sabr_ump_readVarint(buffer as object, offset as integer) as object
    info = {
        "value": -1
        "nextOffset": offset
        "origOffset": offset
        "complete": false
    }

    if GetInterface(buffer, "ifByteArray") = invalid then return info
    totalCount = buffer.count()
    if offset < 0 or offset >= totalCount then return info

    firstByte = buffer[offset]
    byteLength = sabr_ump_inferVarintLength(firstByte)
    if byteLength <= 0 or offset + byteLength > totalCount then return info

    cursor = offset
    value = 0

    if byteLength = 1
        value = buffer[cursor]
        cursor = cursor + 1
    else if byteLength = 2
        byte1 = buffer[cursor] : cursor = cursor + 1
        byte2 = buffer[cursor] : cursor = cursor + 1
        value = (byte1 and &h3f) + 64 * byte2
    else if byteLength = 3
        byte1 = buffer[cursor] : cursor = cursor + 1
        byte2 = buffer[cursor] : cursor = cursor + 1
        byte3 = buffer[cursor] : cursor = cursor + 1
        value = (byte1 and &h1f) + 32 * (byte2 + 256 * byte3)
    else if byteLength = 4
        byte1 = buffer[cursor] : cursor = cursor + 1
        byte2 = buffer[cursor] : cursor = cursor + 1
        byte3 = buffer[cursor] : cursor = cursor + 1
        byte4 = buffer[cursor] : cursor = cursor + 1
        value = (byte1 and &h0f) + 16 * (byte2 + 256 * (byte3 + 256 * byte4))
    else
        cursor = cursor + 1
        byte1 = buffer[cursor] : cursor = cursor + 1
        byte2 = buffer[cursor] : cursor = cursor + 1
        byte3 = buffer[cursor] : cursor = cursor + 1
        byte4 = buffer[cursor] : cursor = cursor + 1
        value = byte1 + 256 * byte2 + 65536 * byte3 + 16777216 * byte4
    end if

    info.value = sabr_ump_finalizeVarintValue(value)
    info.nextOffset = cursor
    info.complete = true
    return info
end function

'------------------------------------------------------------------------------
' Function : sabr_ump_createStreamTap
' Purpose  : Builds a lightweight streaming parser that watches a growing SABR
'            spool file and stops the download once the target segment is ready.
'------------------------------------------------------------------------------
function sabr_ump_createStreamTap(config as object) as object
    if not IsAssociativeArray(config) then return invalid

    tap = {
        "config": config
        "offset": 0
        "peekBytes": 16
        "headerIndex": createObject("roAssociativeArray")
        "controlEffects": createObject("roAssociativeArray")
        "formatInitList": []
        "targetChunks": []
        "targetTotalBytes": 0
    }

    peekOverride = sabr_ump_toInt(config?.peekBytes)
    if peekOverride <> invalid and peekOverride > 4 then tap.peekBytes = peekOverride

    tap.destPath = sabr_ump_toSafeString(config?.destPath)
    tap.keyParam = sabr_ump_toSafeString(config?.keyParam)
    tap.targetItag = sabr_ump_toInt(config?.targetItag)
    tap.targetRangeStart = sabr_ump_toInt(config?.targetRangeStart)
    tap.targetRangeEnd = sabr_ump_toInt(config?.targetRangeEnd)
    tap.isInitRequest = config?.isInitRequest = true
    tap.contentType = sabr_ump_toSafeString(config?.contentType)
    tap.mediaIdHash = sabr_ump_toSafeString(config?.mediaIdHash)

    tap.poll = function(path as string, fileSize as integer) as dynamic
        return sabr_ump_streamTapPoll(m, path, fileSize)
    end function

    tap.resetForNewFile = sub()
        m.offset = 0
        m.headerIndex = createObject("roAssociativeArray")
        m.controlEffects = createObject("roAssociativeArray")
        m.formatInitList = []
        m.targetChunks = []
        m.targetTotalBytes = 0
        m.targetHeaderId = invalid
        m.targetMatched = false
        m.targetComplete = false
        m.resultReady = false
        m.segmentMediaHeader = invalid
        m.segmentEntry = invalid
        m.segmentCoverage = invalid
    end sub

    tap.resetForNewFile()

    return tap
end function

'------------------------------------------------------------------------------
' Function : sabr_ump_streamTapPoll
' Purpose  : Advances the streaming reader state while the spool file grows.
'------------------------------------------------------------------------------
function sabr_ump_streamTapPoll(tap as object, path as string, fileSize as integer) as dynamic
    if not IsAssociativeArray(tap) then return invalid
    if not IsString(path) or path = "" then return invalid

    sizeVal = sabr_ump_toInt(fileSize)
    if sizeVal = invalid or sizeVal <= tap.offset then return invalid

    peekBytes = sabr_ump_toInt(tap?.peekBytes)
    if peekBytes = invalid or peekBytes <= 4 then peekBytes = 16

    while tap.offset < sizeVal
        remaining = sizeVal - tap.offset
        sliceLength = peekBytes
        if sliceLength > remaining then sliceLength = remaining
        if sliceLength <= 0 then exit while

        headerBytes = CreateObject("roByteArray")
        if headerBytes.ReadFile(path, tap.offset, sliceLength) <> true then exit while

        typeInfo = sabr_ump_readVarint(headerBytes, 0)
        if typeInfo.complete <> true then exit while

        sizeInfo = sabr_ump_readVarint(headerBytes, typeInfo.nextOffset)
        if sizeInfo.complete <> true then exit while

        partType = sabr_ump_toInt(typeInfo.value)
        partSize = sabr_ump_toInt(sizeInfo.value)
        headerLength = sizeInfo.nextOffset

        if partType = invalid or partSize = invalid or partSize < 0 then
            tap.offset = tap.offset + 1
            continue while
        end if

        nextOffset = tap.offset + headerLength + partSize
        if nextOffset > sizeVal then
            tap.nextRequired = nextOffset
            exit while
        end if

        payloadOffset = tap.offset + headerLength

        if partType = UMP_PART_ID_MEDIA_HEADER then
            sabr_ump_streamHandleMediaHeader(tap, path, payloadOffset, partSize)
        else if partType = UMP_PART_ID_MEDIA then
            sabr_ump_streamHandleMediaPart(tap, path, payloadOffset, partSize)
        else if partType = UMP_PART_ID_MEDIA_END then
            sabr_ump_streamHandleMediaEnd(tap, path, payloadOffset, partSize)
        else if partType = UMP_PART_ID_FORMAT_INIT_METADATA then
            sabr_ump_streamHandleInitMetadata(tap, path, payloadOffset, partSize)
        else if partType = UMP_PART_ID_NEXT_REQUEST_POLICY or partType = UMP_PART_ID_SABR_CONTEXT_UPDATE or partType = UMP_PART_ID_SABR_CONTEXT_SENDING_POLICY or partType = UMP_PART_ID_SABR_REDIRECT or partType = UMP_PART_ID_SABR_ERROR or partType = UMP_PART_ID_RELOAD_PLAYER_RESPONSE or partType = UMP_PART_ID_STREAM_PROTECTION_STATUS or partType = UMP_PART_ID_SNACKBAR_MESSAGE then
            sabr_ump_streamHandleControlPart(tap, partType, path, payloadOffset, partSize)
        end if

        tap.offset = nextOffset

        if tap.targetComplete = true and tap.resultReady <> true then
            tap.resultReady = true
            result = {
                "cancel": true
                "done": true
            }

            segmentEntry = tap.segmentEntry
            if not IsAssociativeArray(segmentEntry) then segmentEntry = invalid
            if IsAssociativeArray(segmentEntry)
                if tap.destPath <> "" then segmentEntry["path"] = tap.destPath
                result["segmentEntry"] = segmentEntry
            end if

            coverage = tap.segmentCoverage
            if IsAssociativeArray(coverage) then result["coverage"] = coverage

            controlEffects = tap.controlEffects
            if IsAssociativeArray(controlEffects) and controlEffects.Count() > 0
                result["controlEffects"] = controlEffects
            end if

            if IsArray(tap.formatInitList) and tap.formatInitList.Count() > 0
                result["formatInitMetadata"] = tap.formatInitList
            end if

            spoolKey = sabr_ump_streamComputeSpoolKey(segmentEntry, tap.keyParam)
            if spoolKey <> "" then result["spoolKey"] = spoolKey

            return result
        end if
    end while

    return invalid
end function

'------------------------------------------------------------------------------
' Helper : sabr_ump_streamComputeSpoolKey
'------------------------------------------------------------------------------
function sabr_ump_streamComputeSpoolKey(segmentEntry as object, keyParam as string) as string
    if not IsAssociativeArray(segmentEntry) then return ""
    startRange = sabr_ump_toInt(segmentEntry?.startRange)
    startLabel = sabr_ump_toSafeString(startRange)
    if startLabel = "" then startLabel = "0"
    suffix = sabr_ump_toSafeString(keyParam)
    return `${startLabel}:${suffix}`
end function

'------------------------------------------------------------------------------
' Helper : sabr_ump_streamHandleMediaHeader
'------------------------------------------------------------------------------
sub sabr_ump_streamHandleMediaHeader(tap as object, path as string, payloadOffset as integer, partSize as integer)
    if not IsAssociativeArray(tap) then return
    if partSize <= 0 then return

    payload = CreateObject("roByteArray")
    if payload.ReadFile(path, payloadOffset, partSize) <> true then return

    decodedHeader = sabr_ump_decodePart(MediaHeaderDecode, payload, invalid, "stream_media_header")
    if not IsAssociativeArray(decodedHeader) then return

    headerIdVal = sabr_ump_toInt(decodedHeader.Lookup("headerId"))
    itagVal = sabr_ump_toInt(decodedHeader.Lookup("itag"))
    rangeStartVal = sabr_ump_toInt(decodedHeader.Lookup("startRange"))
    if rangeStartVal = invalid then rangeStartVal = sabr_ump_toInt(decodedHeader.Lookup("start"))
    contentLengthVal = sabr_ump_toInt(decodedHeader.Lookup("contentLength"))
    rangeEndVal = invalid
    if rangeStartVal <> invalid and contentLengthVal <> invalid and contentLengthVal > 0
        rangeEndVal = rangeStartVal + contentLengthVal - 1
    end if

    headerRecord = {
        "headerId": headerIdVal
        "itag": itagVal
        "segmentRangeStart": rangeStartVal
        "segmentRangeEnd": rangeEndVal
        "segmentContentLength": contentLengthVal
        "mediaHeader": decodedHeader
        "segmentIsInit": decodedHeader.Lookup("isInitSeg") = true
    }

    if headerIdVal <> invalid
        tap.headerIndex[`${headerIdVal}`] = headerRecord
    end if

    if sabr_ump_streamHeaderMatchesTarget(tap, headerRecord)
        tap.targetHeaderId = headerIdVal
        tap.targetMatched = true
        tap.segmentMediaHeader = decodedHeader
        tap.segmentRangeStart = rangeStartVal
        tap.segmentRangeEnd = rangeEndVal
        tap.segmentIsInit = headerRecord.segmentIsInit
        tap.targetChunks = []
        tap.targetTotalBytes = 0
        tap.segmentEntry = {
            "headerId": headerIdVal
            "itag": itagVal
            "startRange": rangeStartVal
            "endRange": rangeEndVal
            "isInitSeg": headerRecord.segmentIsInit
            "mediaHeader": decodedHeader
            "chunks": []
            "totalBytes": 0
        }
        tap.segmentCoverage = {
            "rangeStart": rangeStartVal
            "rangeEnd": rangeEndVal
        }
        if tap.destPath <> "" then tap.segmentEntry["path"] = tap.destPath
    end if
end sub

'------------------------------------------------------------------------------
' Helper : sabr_ump_streamHeaderMatchesTarget
'------------------------------------------------------------------------------
function sabr_ump_streamHeaderMatchesTarget(tap as object, headerRecord as object) as boolean
    if not IsAssociativeArray(tap) or not IsAssociativeArray(headerRecord) then return false

    targetItag = sabr_ump_toInt(tap?.targetItag)
    headerItag = sabr_ump_toInt(headerRecord?.itag)
    if targetItag <> invalid and headerItag <> invalid and targetItag <> headerItag then return false

    targetStart = sabr_ump_toInt(tap?.targetRangeStart)
    headerStart = sabr_ump_toInt(headerRecord?.segmentRangeStart)
    if tap?.isInitRequest = true
        if headerRecord?.segmentIsInit <> true then return false
    else if targetStart <> invalid and headerStart <> invalid and targetStart <> headerStart
        return false
    end if

    targetEnd = sabr_ump_toInt(tap?.targetRangeEnd)
    headerEnd = sabr_ump_toInt(headerRecord?.segmentRangeEnd)
    if targetEnd <> invalid and headerEnd <> invalid and targetEnd <> headerEnd
        return false
    end if

    return true
end function

'------------------------------------------------------------------------------
' Helper : sabr_ump_streamHandleMediaPart
'------------------------------------------------------------------------------
sub sabr_ump_streamHandleMediaPart(tap as object, path as string, payloadOffset as integer, partSize as integer)
    if not IsAssociativeArray(tap) then return
    if partSize <= 1 then return

    varInfo = sabr_ump_streamReadVarintFromFile(path, payloadOffset, partSize)
    if not IsAssociativeArray(varInfo) then return
    headerIdVal = sabr_ump_toInt(varInfo?.value)
    if headerIdVal = invalid then return

    if tap.targetMatched <> true or tap.targetHeaderId = invalid then return
    if headerIdVal <> tap.targetHeaderId then return

    headerIdLength = sabr_ump_toInt(varInfo?.length)
    if headerIdLength = invalid or headerIdLength <= 0 or headerIdLength > partSize then headerIdLength = 1

    chunkOffset = payloadOffset + headerIdLength
    chunkLength = partSize - headerIdLength
    if chunkLength <= 0 then return

    chunkRecord = {
        "offset": chunkOffset
        "length": chunkLength
    }

    tap.targetChunks.push(chunkRecord)
    tap.targetTotalBytes = tap.targetTotalBytes + chunkLength

    if IsAssociativeArray(tap.segmentEntry)
        if tap.segmentEntry.DoesExist("payloadOffset") = false
            tap.segmentEntry["payloadOffset"] = payloadOffset
            tap.segmentEntry["payloadSize"] = partSize
        else
            totalPayloadSize = sabr_ump_toInt(tap.segmentEntry.Lookup("payloadSize"))
            if totalPayloadSize = invalid then totalPayloadSize = 0
            tap.segmentEntry["payloadSize"] = totalPayloadSize + partSize
        end if
        tap.segmentEntry["payloadEnd"] = payloadOffset + partSize - 1

        chunks = tap.segmentEntry.Lookup("chunks")
        if not IsArray(chunks) then chunks = []
        chunks.push(chunkRecord)
        tap.segmentEntry["chunks"] = chunks
        tap.segmentEntry["totalBytes"] = tap.targetTotalBytes
    end if
end sub

'------------------------------------------------------------------------------
' Helper : sabr_ump_streamHandleMediaEnd
'------------------------------------------------------------------------------
sub sabr_ump_streamHandleMediaEnd(tap as object, path as string, payloadOffset as integer, partSize as integer)
    if not IsAssociativeArray(tap) then return
    if partSize <= 0 then return

    headerBytes = CreateObject("roByteArray")
    readLen = partSize
    if readLen > 8 then readLen = 8
    if headerBytes.ReadFile(path, payloadOffset, readLen) <> true then return
    if headerBytes.count() <= 0 then return

    headerIdVal = headerBytes[0]

    if tap.targetMatched <> true or tap.targetHeaderId = invalid then return
    if headerIdVal <> tap.targetHeaderId then return

    tap.targetComplete = true
    if IsAssociativeArray(tap.segmentEntry)
        tap.segmentEntry["payloadEnd"] = payloadOffset + partSize - 1
        tap.segmentEntry["totalBytes"] = tap.targetTotalBytes
    end if

    if IsAssociativeArray(tap.segmentCoverage)
        if tap.isInitRequest = true and tap.targetRangeStart <> invalid and tap.targetRangeEnd <> invalid
            tap.segmentCoverage["rangeStart"] = tap.targetRangeStart
            tap.segmentCoverage["rangeEnd"] = tap.targetRangeEnd
        else
            if tap.targetRangeStart <> invalid then tap.segmentCoverage["rangeStart"] = tap.targetRangeStart
            if tap.targetRangeEnd <> invalid then tap.segmentCoverage["rangeEnd"] = tap.targetRangeEnd
        end if
    end if
end sub

'------------------------------------------------------------------------------
' Helper : sabr_ump_streamHandleInitMetadata
'------------------------------------------------------------------------------
sub sabr_ump_streamHandleInitMetadata(tap as object, path as string, payloadOffset as integer, partSize as integer)
    if not IsAssociativeArray(tap) then return
    if partSize <= 0 then return

    payload = CreateObject("roByteArray")
    if payload.ReadFile(path, payloadOffset, partSize) <> true then return

    decoded = sabr_ump_decodePart(FormatInitializationMetadataDecode, payload, invalid, "stream_format_init")
    if decoded <> invalid then tap.formatInitList.push(decoded)
end sub

'------------------------------------------------------------------------------
' Helper : sabr_ump_streamHandleControlPart
'------------------------------------------------------------------------------
sub sabr_ump_streamHandleControlPart(tap as object, partType as integer, path as string, payloadOffset as integer, partSize as integer)
    if not IsAssociativeArray(tap) then return
    if partSize <= 0 then return

    payload = CreateObject("roByteArray")
    if payload.ReadFile(path, payloadOffset, partSize) <> true then return

    sabr_ump_storeControlEffect(tap.controlEffects, partType, payload, "stream")
end sub

'------------------------------------------------------------------------------
' Helper : sabr_ump_storeControlEffect
' Purpose: Shared logic for decoding control parts and recording them against
'          either the streaming tap state or the offline spool scan.
'------------------------------------------------------------------------------
sub sabr_ump_storeControlEffect(target as dynamic, partType as integer, payload as object, labelPrefix as string)
    if not IsAssociativeArray(target) then return
    if GetInterface(payload, "ifByteArray") = invalid then return

    prefix = labelPrefix
    if prefix = "" then prefix = "sabr"

    if partType = UMP_PART_ID_NEXT_REQUEST_POLICY
        decoded = sabr_ump_decodePart(NextRequestPolicyDecode, payload, invalid, `${prefix}_next_request_policy`)
        if decoded <> invalid then target["nextRequestPolicy"] = decoded
    else if partType = UMP_PART_ID_SABR_CONTEXT_UPDATE
        decoded = sabr_ump_decodePart(SabrContextUpdateDecode, payload, invalid, `${prefix}_context_update`)
        if decoded <> invalid then target["sabrContextUpdate"] = decoded
    else if partType = UMP_PART_ID_SABR_CONTEXT_SENDING_POLICY
        decoded = sabr_ump_decodePart(SabrContextSendingPolicyDecode, payload, invalid, `${prefix}_context_sending_policy`)
        if decoded <> invalid then target["sabrContextSendingPolicy"] = decoded
    else if partType = UMP_PART_ID_SABR_REDIRECT
        decoded = sabr_ump_decodePart(SabrRedirectDecode, payload, invalid, `${prefix}_redirect`)
        if decoded <> invalid then target["redirect"] = decoded
    else if partType = UMP_PART_ID_SABR_ERROR
        decoded = sabr_ump_decodePart(SabrErrorDecode, payload, invalid, `${prefix}_sabr_error`)
        if decoded <> invalid then target["sabrError"] = decoded
    else if partType = UMP_PART_ID_RELOAD_PLAYER_RESPONSE
        decoded = sabr_ump_decodePart(ReloadPlaybackContextDecode, payload, invalid, `${prefix}_reload_playback`)
        if decoded <> invalid then target["reloadPlaybackContext"] = decoded
    else if partType = UMP_PART_ID_STREAM_PROTECTION_STATUS
        decoded = sabr_ump_decodePart(StreamProtectionStatusDecode, payload, invalid, `${prefix}_stream_protection_status`)
        if decoded <> invalid then target["streamProtectionStatus"] = decoded
    else if partType = UMP_PART_ID_SNACKBAR_MESSAGE
        decoded = sabr_ump_decodePart(SnackbarMessageDecode, payload, invalid, `${prefix}_snackbar`)
        if decoded <> invalid then target["snackbarMessage"] = decoded
    end if
end sub

'------------------------------------------------------------------------------
' Helper : sabr_ump_streamReadVarintFromFile
'------------------------------------------------------------------------------
function sabr_ump_streamReadVarintFromFile(path as string, offset as integer, partSize as integer) as object
    maxLen = partSize
    if maxLen > 8 then maxLen = 8
    if maxLen <= 0 then return invalid

    bytes = CreateObject("roByteArray")
    if bytes.ReadFile(path, offset, maxLen) <> true then return invalid

    varInfo = sabr_ump_readVarint(bytes, 0)
    if varInfo.complete <> true then return invalid

    return {
        "value": varInfo.value
        "length": varInfo.nextOffset
    }
end function

'------------------------------------------------------------------------------
' Function : sabr_ump_buildSpoolPartMap
' Purpose  : Scans a SABR spool file, interprets each part header, and returns
'            structured metadata including segment linkage, control effects, and
'            summary stats.
'------------------------------------------------------------------------------
function sabr_ump_buildSpoolPartMap(path as string, maxHeaderBytes = 16 as integer, keyParam = "" as string) as dynamic
    result = {
        "parts": []
        "durationMs": 0
        "totalBytes": 0
        "reads": 0
        "sliceBytes": maxHeaderBytes
    }
    if not IsString(path) or path = "" then return result

    fs = CreateObject("roFileSystem")
    stat = invalid
    try
        stat = fs.Stat(path)
    catch e
        stat = invalid
    end try
    totalSize = invalid
    if IsAssociativeArray(stat)
        totalSize = stat.Lookup("size")
        if totalSize = invalid then totalSize = stat.Lookup("length")
    end if
    if totalSize = invalid then return result
    if totalSize <= 0 then
        result.totalBytes = 0
        return result
    end if

    timer = CreateObject("roTimespan")
    if timer <> invalid then timer.Mark()

    parts = []
    headerIndex = createObject("roAssociativeArray")
    segmentIndex = createObject("roAssociativeArray")
    headerToSegmentKey = createObject("roAssociativeArray")
    controlEffects = createObject("roAssociativeArray")
    suffixBase = sabr_ump_toSafeString(keyParam)
    currentHeaderId = invalid
    offset = 0
    actualBytesRead = 0
    while offset < totalSize
        remaining = totalSize - offset
        sliceLength = maxHeaderBytes
        if sliceLength > remaining then sliceLength = remaining
        if sliceLength <= 0 then exit while

        headerBytes = CreateObject("roByteArray")
        if headerBytes.ReadFile(path, offset, sliceLength) <> true
            result["error"] = "read_failed"
            result["errorOffset"] = offset
            exit while
        end if
        result.reads = result.reads + 1
        actualBytesRead = actualBytesRead + sliceLength

        typeInfo = sabr_ump_readVarint(headerBytes, 0)
        if typeInfo.complete <> true
            result["error"] = "type_incomplete"
            result["errorOffset"] = offset
            exit while
        end if

        sizeInfo = sabr_ump_readVarint(headerBytes, typeInfo.nextOffset)
        if sizeInfo.complete <> true
            result["error"] = "size_incomplete"
            result["errorOffset"] = offset
            exit while
        end if

        partType = sabr_ump_toInt(typeInfo.value)
        partSize = sabr_ump_toInt(sizeInfo.value)
        headerLength = sizeInfo.nextOffset

        if partSize = invalid or partSize < 0
            result["error"] = "invalid_size"
            result["errorOffset"] = offset
            exit while
        end if

        partEntry = {
            "type": partType
            "typeLabel": sabr_ump_partTypeLabel(partType)
            "offset": offset
            "headerBytes": headerLength
            "payloadOffset": offset + headerLength
            "payloadSize": partSize
            "payloadEnd": (offset + headerLength + partSize) - 1
            "totalLength": headerLength + partSize
        }

        handlesControl = partType = UMP_PART_ID_NEXT_REQUEST_POLICY or partType = UMP_PART_ID_SABR_CONTEXT_UPDATE or partType = UMP_PART_ID_SABR_CONTEXT_SENDING_POLICY or partType = UMP_PART_ID_SABR_REDIRECT or partType = UMP_PART_ID_SABR_ERROR or partType = UMP_PART_ID_RELOAD_PLAYER_RESPONSE or partType = UMP_PART_ID_STREAM_PROTECTION_STATUS or partType = UMP_PART_ID_SNACKBAR_MESSAGE

        if partType = UMP_PART_ID_MEDIA_HEADER
            headerData = CreateObject("roByteArray")
            if partSize > 0 and headerData.ReadFile(path, partEntry.payloadOffset, partSize) = true
                result.reads = result.reads + 1
                actualBytesRead = actualBytesRead + partSize
                decodedHeader = sabr_ump_decodePart(MediaHeaderDecode, headerData, invalid, "spool_media_header")
                ' headerRecord = decodedHeader
                if IsAssociativeArray(decodedHeader)
                    headerIdVal = sabr_ump_toInt(decodedHeader.Lookup("headerId"))
                    itagVal = sabr_ump_toInt(decodedHeader.Lookup("itag"))
                    isInitFlag = decodedHeader.Lookup("isInitSeg") = true
                    rangeStartVal = sabr_ump_toInt(decodedHeader.Lookup("startRange"))
                    contentLengthVal = sabr_ump_toInt(decodedHeader.Lookup("contentLength"))
                    rangeEndVal = invalid
                    if rangeStartVal <> invalid and contentLengthVal <> invalid and contentLengthVal > 0
                        rangeEndVal = rangeStartVal + contentLengthVal - 1
                    end if

                    partEntry["mediaHeader"] = decodedHeader
                    if headerIdVal <> invalid then partEntry["headerId"] = headerIdVal
                    if itagVal <> invalid then partEntry["itag"] = itagVal
                    if isInitFlag then partEntry["segmentIsInit"] = true
                    if rangeStartVal <> invalid then partEntry["segmentRangeStart"] = rangeStartVal
                    if rangeEndVal <> invalid then partEntry["segmentRangeEnd"] = rangeEndVal

                    headerRecord = {
                        "headerId": headerIdVal
                        "itag": itagVal
                        "segmentIsInit": isInitFlag
                    }
                    headerRecord["mediaHeader"] = decodedHeader
                    if rangeStartVal <> invalid then headerRecord["segmentRangeStart"] = rangeStartVal
                    if rangeEndVal <> invalid then headerRecord["segmentRangeEnd"] = rangeEndVal
                    if contentLengthVal <> invalid and contentLengthVal > 0
                        partEntry["segmentContentLength"] = contentLengthVal
                        headerRecord["segmentContentLength"] = contentLengthVal
                    end if
                    if headerIdVal <> invalid
                        headerKey = sabr_ump_toSafeString(headerIdVal)
                        if headerKey <> ""
                            headerIndex[headerKey] = headerRecord
                        end if
                        currentHeaderId = headerIdVal
                    else
                        currentHeaderId = invalid
                    end if
                else
                    currentHeaderId = invalid
                end if
            else
                currentHeaderId = invalid
            end if
        else if partType = UMP_PART_ID_MEDIA or partType = UMP_PART_ID_MEDIA_END
            headerIdVal = invalid
            if partSize > 0
                peekLength = maxHeaderBytes
                if partType = UMP_PART_ID_MEDIA_END and peekLength > 1 then peekLength = 1
                if peekLength > partSize then peekLength = partSize
                if peekLength > 0
                    peekBytes = CreateObject("roByteArray")
                    if peekBytes.ReadFile(path, partEntry.payloadOffset, peekLength) = true
                        result.reads = result.reads + 1
                        actualBytesRead = actualBytesRead + peekLength
                        if partType = UMP_PART_ID_MEDIA
                            headerVar = sabr_ump_readVarint(peekBytes, 0)
                            if headerVar.complete = true
                                headerIdVal = sabr_ump_toInt(headerVar.value)
                            end if
                        else if partType = UMP_PART_ID_MEDIA_END
                            if peekBytes.count() > 0
                                headerIdVal = peekBytes[0]
                            else
                                headerIdVal = invalid
                            end if
                        end if
                    end if
                end if
            end if

            if headerIdVal <> invalid
                partEntry["headerId"] = headerIdVal
                headerKey = sabr_ump_toSafeString(headerIdVal)
                headerRecord = invalid
                if headerKey <> "" and headerIndex.DoesExist(headerKey)
                    headerRecord = headerIndex.Lookup(headerKey)
                else if currentHeaderId <> invalid and headerIdVal = currentHeaderId
                    currentKey = sabr_ump_toSafeString(currentHeaderId)
                    if currentKey <> "" and headerIndex.DoesExist(currentKey)
                        headerRecord = headerIndex.Lookup(currentKey)
                    end if
                end if
                if IsAssociativeArray(headerRecord)
                    if headerRecord.DoesExist("itag") then partEntry["itag"] = headerRecord.itag
                    if headerRecord.DoesExist("segmentIsInit") and headerRecord.segmentIsInit = true
                        partEntry["segmentIsInit"] = true
                    end if
                    if headerRecord.DoesExist("mediaHeader") then partEntry["mediaHeader"] = headerRecord.mediaHeader
                    if headerRecord.DoesExist("segmentRangeStart")
                        partEntry["segmentRangeStart"] = headerRecord.segmentRangeStart
                    end if
                    if headerRecord.DoesExist("segmentRangeEnd")
                        partEntry["segmentRangeEnd"] = headerRecord.segmentRangeEnd
                    end if
                    if headerRecord.DoesExist("segmentContentLength")
                        partEntry["segmentContentLength"] = headerRecord.segmentContentLength
                    end if
                end if
            end if

            if partType = UMP_PART_ID_MEDIA_END
                currentHeaderId = invalid
            end if
        else if handlesControl
            controlPayload = CreateObject("roByteArray")
            if partSize > 0 and controlPayload.ReadFile(path, partEntry.payloadOffset, partSize) = true
                result.reads = result.reads + 1
                actualBytesRead = actualBytesRead + partSize
                sabr_ump_storeControlEffect(controlEffects, partType, controlPayload, "spool")
            end if
        end if

        parts.push(partEntry)

        if IsAssociativeArray(partEntry)
            partTypeVal = sabr_ump_toInt(partEntry?.type)
            headerIdForPart = sabr_ump_toInt(partEntry?.headerId)
            if headerIdForPart <> invalid and (partTypeVal = UMP_PART_ID_MEDIA_HEADER or partTypeVal = UMP_PART_ID_MEDIA)
                headerKeyLabel = sabr_ump_toSafeString(headerIdForPart)
                existingSegmentKey = invalid
                if headerKeyLabel <> "" and headerToSegmentKey.DoesExist(headerKeyLabel)
                    existingSegmentKey = headerToSegmentKey.Lookup(headerKeyLabel)
                end if

                if partTypeVal = UMP_PART_ID_MEDIA_HEADER or existingSegmentKey = invalid
                    startRangeVal = sabr_ump_toInt(partEntry?.segmentRangeStart)
                    mediaHeader = partEntry?.mediaHeader
                    if startRangeVal = invalid and IsAssociativeArray(mediaHeader)
                        startRangeVal = sabr_ump_toInt(mediaHeader?.startRange)
                        if startRangeVal = invalid then startRangeVal = sabr_ump_toInt(mediaHeader?.start)
                    end if

                    endRangeVal = sabr_ump_toInt(partEntry?.segmentRangeEnd)
                    if endRangeVal = invalid and IsAssociativeArray(mediaHeader)
                        contentLengthVal = sabr_ump_toInt(mediaHeader?.contentLength)
                        if contentLengthVal <> invalid and contentLengthVal > 0 and startRangeVal <> invalid
                            endRangeVal = startRangeVal + contentLengthVal - 1
                        end if
                    end if

                    suffixLabel = suffixBase
                    if suffixLabel = "" then suffixLabel = sabr_ump_toSafeString(partEntry?.itag)
                    if suffixLabel <> ""
                        suffixLastChar = Mid(suffixLabel, Len(suffixLabel), 1)
                        if suffixLastChar <> ":"
                            suffixLabel = `${suffixLabel}:`
                        end if
                    end if

                    startLabel = sabr_ump_toSafeString(startRangeVal)
                    if startLabel = "" then startLabel = "0"
                    segmentKey = suffixLabel <> "" ? `${startLabel}:${suffixLabel}` : `${startLabel}:`

                    segmentRecord = invalid
                    if segmentKey <> "" and segmentIndex.DoesExist(segmentKey)
                        segmentRecord = segmentIndex.Lookup(segmentKey)
                    end if
                    if segmentRecord = invalid
                        segmentRecord = {
                            "path": path
                            "headerId": headerIdForPart
                            "startRange": startRangeVal
                            "endRange": endRangeVal
                            "isInitSeg": (partEntry?.segmentIsInit = true)
                            "chunks": []
                        }
                        segmentRecord["mediaHeader"] = mediaHeader
                        segmentRecord["itag"] = sabr_ump_toInt(partEntry?.itag)
                        segmentRecord["totalBytes"] = 0
                    else
                        if segmentRecord.startRange = invalid then segmentRecord.startRange = startRangeVal
                        if segmentRecord.endRange = invalid then segmentRecord.endRange = endRangeVal
                        if segmentRecord.mediaHeader = invalid and IsAssociativeArray(mediaHeader)
                            segmentRecord.mediaHeader = mediaHeader
                        end if
                        if partEntry?.segmentIsInit = true then segmentRecord.isInitSeg = true
                        if segmentRecord.DoesExist("itag") = false or segmentRecord.itag = invalid
                            segmentRecord["itag"] = sabr_ump_toInt(partEntry?.itag)
                        end if
                    end if

                    if segmentKey <> ""
                        segmentIndex[segmentKey] = segmentRecord
                        if headerKeyLabel <> ""
                            headerToSegmentKey[headerKeyLabel] = segmentKey
                        end if
                        existingSegmentKey = segmentKey
                    end if
                end if

                if partTypeVal = UMP_PART_ID_MEDIA and existingSegmentKey <> invalid and existingSegmentKey <> ""
                    if segmentIndex.DoesExist(existingSegmentKey)
                        segmentRecord = segmentIndex.Lookup(existingSegmentKey)
                        chunks = segmentRecord?.chunks
                        if not IsArray(chunks) then chunks = []

                        payloadOffsetVal = sabr_ump_toInt(partEntry?.payloadOffset)
                        payloadSizeVal = sabr_ump_toInt(partEntry?.payloadSize)
                        if payloadOffsetVal <> invalid and payloadSizeVal <> invalid and payloadSizeVal > 1
                            chunk = {
                                "offset": payloadOffsetVal + 1
                                "length": payloadSizeVal - 1
                            }
                            if chunk.length > 0
                                chunks.push(chunk)
                                segmentRecord["chunks"] = chunks
                                totalBytesVal = sabr_ump_toInt(segmentRecord?.totalBytes)
                                if totalBytesVal = invalid then totalBytesVal = 0
                                segmentRecord["totalBytes"] = totalBytesVal + chunk.length
                                segmentIndex[existingSegmentKey] = segmentRecord
                            end if
                        end if
                    end if
                end if
            end if
        end if

        nextOffset = offset + headerLength + partSize
        if nextOffset <= offset
            result["error"] = "non_progress"
            result["errorOffset"] = offset
            exit while
        end if
        offset = nextOffset
    end while

    if IsAssociativeArray(segmentIndex)
        for each segmentKey in segmentIndex
            entry = segmentIndex.Lookup(segmentKey)
            if entry?.isInitSeg = true
                sidxUpdate = sabr_ump_extractSidxFromSpool(path, entry)
                if IsAssociativeArray(sidxUpdate)
                    entry["sidxIndex"] = sidxUpdate
                    segmentIndex[segmentKey] = entry
                end if
            end if
        end for
    end if

    result["parts"] = parts
    result["segmentIndex"] = segmentIndex
    result["segmentMap"] = sabr_ump_buildSpoolSegmentMap(parts, keyParam, path)
    result["totalBytes"] = totalSize
    result["actualBytesRead"] = actualBytesRead
    result["partCount"] = parts.count()
    result["controlEffects"] = controlEffects
    containsInit = false
    for each partSummary in parts
        if IsAssociativeArray(partSummary)
            if partSummary.DoesExist("segmentIsInit") and partSummary.segmentIsInit = true
                containsInit = true
                exit for
            end if
        end if
    end for
    if containsInit then result["containsInit"] = true
    if timer <> invalid
        result["durationMs"] = Int(timer.TotalMilliseconds())
    end if
    if not result.DoesExist("error") and offset >= totalSize
        result["complete"] = true
    end if
    result["bytesScanned"] = offset
    return result
end function

'------------------------------------------------------------------------------
' Function : sabr_ump_buildSpoolSegmentMap
' Purpose  : Groups raw UMP parts into higher-level segment records (media,
'            init, control metadata) to support direct streaming from spool files.
'------------------------------------------------------------------------------
function sabr_ump_buildSpoolSegmentMap(partArray as object, keyParam as string, path as string) as object
    segmentMap = {}
    if not IsArray(partArray) then return segmentMap

    suffixBase = sabr_ump_toSafeString(keyParam)

    for each part in partArray
        if not IsAssociativeArray(part) then continue for
        ' if part.type = UMP_PART_ID_MEDIA_HEADER then headerOffsetBytes = sabr_ump_toInt(part?.headerBytes)
        if part?.type <> UMP_PART_ID_MEDIA then continue for

        payloadOffset = sabr_ump_toInt(part?.payloadOffset) + part.headerBytes - 1
        payloadSize = sabr_ump_toInt(part?.payloadSize)
        if payloadOffset = invalid or payloadSize = invalid or payloadSize <= 0 then continue for

        mediaHeader = part?.mediaHeader
        rangeStart = sabr_ump_toInt(part?.segmentRangeStart)
        if rangeStart = invalid and IsAssociativeArray(mediaHeader)
            rangeStart = sabr_ump_toInt(mediaHeader?.startRange)
            if rangeStart = invalid then rangeStart = sabr_ump_toInt(mediaHeader?.start)
        end if
        if rangeStart = invalid then continue for

        rangeEnd = sabr_ump_toInt(part?.segmentRangeEnd)
        if rangeEnd = invalid and IsAssociativeArray(mediaHeader)
            contentLength = sabr_ump_toInt(mediaHeader?.contentLength)
            if contentLength <> invalid and contentLength > 0
                rangeEnd = rangeStart + contentLength - 1
            end if
        end if

        itagVal = sabr_ump_toSafeString(part?.itag)
        if itagVal = "" and IsAssociativeArray(mediaHeader)
            itagVal = sabr_ump_toSafeString(mediaHeader?.itag)
        end if

        suffixLabel = suffixBase
        if suffixLabel = "" then suffixLabel = itagVal
        if suffixLabel <> "" and Right(suffixLabel, 1) <> ":"
            suffixLabel = `${suffixLabel}:`
        end if

        startLabel = sabr_ump_toSafeString(rangeStart)
        if startLabel = "" then startLabel = "0"
        key = suffixLabel <> "" ? `${startLabel}:${suffixLabel}` : `${startLabel}:`

        entry = {
            "payloadOffset": payloadOffset
            "payloadSize": payloadSize
            "payloadEnd": sabr_ump_toInt(part?.payloadEnd)
            "headerId": sabr_ump_toInt(part?.headerId)
            "itag": sabr_ump_toInt(part?.itag)
            "startRange": rangeStart
            "endRange": rangeEnd
            "isInitSeg": (part?.segmentIsInit = true)
            "path": path
        }
        if entry.payloadEnd = invalid
            entry.payloadEnd = payloadOffset + payloadSize - 1
        end if
        if IsAssociativeArray(mediaHeader)
            entry["mediaHeader"] = mediaHeader
        end if

        segmentMap[key] = entry
    end for

    return segmentMap
end function

' Reads bytes for a specific part payload from the spool file.
'------------------------------------------------------------------------------
' Function : sabr_ump_readSpoolPayload
' Purpose  : Reads a chunk of bytes from the SABR spool file while guarding
'            against invalid offsets or lengths.
'------------------------------------------------------------------------------
function sabr_ump_readSpoolPayload(path as string, offset as dynamic, length as dynamic) as dynamic
    safeOffset = sabr_ump_toInt(offset)
    if safeOffset = invalid or safeOffset < 0 then return invalid
    safeLength = sabr_ump_toInt(length)
    if safeLength = invalid or safeLength <= 0 then return invalid
    if not IsString(path) or path = "" then return invalid
    bytes = CreateObject("roByteArray")
    if bytes.ReadFile(path, safeOffset, safeLength) <> true then return invalid
    return bytes
end function

function sabr_ump_materializeInitSegment(entry as object, spoolPath as string, mediaIdHash as string, contentType as string, keyParam as string) as string
    if not IsAssociativeArray(entry) then return ""
    if entry?.isInitSeg <> true then return ""
    if not IsString(spoolPath) or spoolPath = "" then return ""
    if not IsString(mediaIdHash) or mediaIdHash = "" then return ""

    payloadOffset = sabr_ump_toInt(entry?.payloadOffset)
    payloadSize = sabr_ump_toInt(entry?.payloadSize)
    if payloadOffset = invalid or payloadSize = invalid or payloadSize <= 0 then return ""

    typeLabel = contentType
    if not IsString(typeLabel) or typeLabel = "" then typeLabel = "unknown"

    keyLabel = sabr_ump_toSafeString(keyParam)
    if keyLabel = "" then keyLabel = "nokey"

    itagLabel = sabr_ump_toSafeString(entry?.itag)
    if itagLabel = "" then itagLabel = "noitag"

    startRangeVal = sabr_ump_toInt(entry?.startRange)
    endRangeVal = sabr_ump_toInt(entry?.endRange)
    mediaHeader = entry?.mediaHeader
    if startRangeVal = invalid and IsAssociativeArray(mediaHeader)
        startRangeVal = sabr_ump_toInt(mediaHeader?.startRange)
        if startRangeVal = invalid then startRangeVal = sabr_ump_toInt(mediaHeader?.start)
    end if
    if endRangeVal = invalid and IsAssociativeArray(mediaHeader)
        contentLengthVal = sabr_ump_toInt(mediaHeader?.contentLength)
        if contentLengthVal <> invalid and contentLengthVal > 0 and startRangeVal <> invalid
            endRangeVal = startRangeVal + contentLengthVal - 1
        end if
    end if

    startLabelValue = startRangeVal <> invalid ? `${startRangeVal}` : "start"
    endLabelValue = endRangeVal <> invalid ? `${endRangeVal}` : "end"
    startLabel = sabr_ump_sanitizeForFilename(startLabelValue)
    endLabel = sabr_ump_sanitizeForFilename(endLabelValue)
    keyLabel = sabr_ump_sanitizeForFilename(keyLabel)
    itagLabel = sabr_ump_sanitizeForFilename(itagLabel)

    sabr_ensureMediaDir(mediaIdHash)
    baseDir = sabr_mediaDir(mediaIdHash)
    fs = CreateObject("roFileSystem")
    fileName = sabr_ump_sanitizeForFilename(`init-${typeLabel}-${keyLabel}-${startLabel}-${endLabel}-${itagLabel}.bin`)
    if fileName = "" then fileName = "init.bin"
    targetPath = `${baseDir}/${fileName}`

    if fs.Exists(targetPath) then return targetPath

    payloadBytes = sabr_ump_readSpoolPayload(spoolPath, payloadOffset, payloadSize)
    if GetInterface(payloadBytes, "ifByteArray") = invalid or payloadBytes.count() = 0 then return ""

    if payloadBytes.WriteFile(targetPath) <> true then return ""

    return targetPath
end function

' Pulls non-media UMP parts (policies, errors, redirects, etc.) out of the spool.

'------------------------------------------------------------------------------
' Function : sabr_ump_extractSidxFromSpool
' Purpose  : Parses the SIDX box from an init segment within the spool to
'            build seekable timing metadata for subsequent requests.
'------------------------------------------------------------------------------
function sabr_ump_extractSidxFromSpool(path as string, segmentEntry as object) as dynamic
    if not IsAssociativeArray(segmentEntry) then return invalid
    if segmentEntry?.isInitSeg <> true then return invalid
    if not IsString(path) or path = "" then return invalid

    mediaHeader = segmentEntry?.mediaHeader
    if not IsAssociativeArray(mediaHeader) then return invalid

    chunks = segmentEntry?.chunks
    if not IsArray(chunks) or chunks.count() = 0 then return invalid

    segmentBytes = sabr_ump_readChunksFromSpool(path, chunks, sabr_ump_toInt(segmentEntry?.totalBytes))
    if GetInterface(segmentBytes, "ifByteArray") = invalid or segmentBytes.count() <= 0 then return invalid

    return sabr_ump_buildSidxIndexUpdate(invalid, mediaHeader, segmentBytes)
end function

'------------------------------------------------------------------------------
' Function : sabr_ump_readChunksFromSpool
' Purpose  : Materializes chunk byte ranges into memory or the aggregation
'            structure so streaming can read contiguous data efficiently.
'------------------------------------------------------------------------------
function sabr_ump_readChunksFromSpool(path as string, chunks as object, declaredTotal = invalid as dynamic) as object
    if not IsArray(chunks) or chunks.count() = 0 then return invalid

    sortedChunks = []
    for each entry in chunks
        if not IsAssociativeArray(entry) then continue for
        offsetVal = sabr_ump_toInt(entry?.offset)
        lengthVal = sabr_ump_toInt(entry?.length)
        if offsetVal = invalid or lengthVal = invalid or lengthVal <= 0 then continue for
        sortedChunks.push({
            "offset": offsetVal
            "length": lengthVal
        })
    end for

    totalChunks = sortedChunks.count()
    if totalChunks = 0 then return invalid

    ' simple insertion sort by offset
    for i = 0 to totalChunks - 2
        minIndex = i
        for j = i + 1 to totalChunks - 1
            if sortedChunks[j].offset < sortedChunks[minIndex].offset then minIndex = j
        end for
        if minIndex <> i
            temp = sortedChunks[i]
            sortedChunks[i] = sortedChunks[minIndex]
            sortedChunks[minIndex] = temp
        end if
    end for

    totalBytes = sabr_ump_toInt(declaredTotal)
    if totalBytes = invalid or totalBytes <= 0
        totalBytes = 0
        for each chunkInfo in sortedChunks
            totalBytes = totalBytes + chunkInfo.length
        end for
    end if
    if totalBytes <= 0 then return invalid

    aggregate = CreateObject("roByteArray")
    aggregate[totalBytes - 1] = 0
    destIndex = 0

    for each chunkInfo in sortedChunks
        chunkBytes = CreateObject("roByteArray")
        if chunkBytes.ReadFile(path, chunkInfo.offset, chunkInfo.length) <> true then return invalid
        chunkLen = chunkBytes.count()
        if chunkLen <= 0 then return invalid
        for idx = 0 to chunkLen - 1
            aggregate[destIndex] = chunkBytes[idx]
            destIndex = destIndex + 1
        end for
    end for

    if destIndex < totalBytes
        ' trim unused tail
        trimmed = CreateObject("roByteArray")
        if destIndex > 0
            trimmed[destIndex - 1] = 0
            for k = 0 to destIndex - 1
                trimmed[k] = aggregate[k]
            end for
        end if
        return trimmed
    end if

    return aggregate
end function

'------------------------------------------------------------------------------
' Function : sabr_ump_partTypeLabel
' Purpose  : Provides a human-readable label for UMP part IDs to improve logs
'            and debugging output.
'------------------------------------------------------------------------------
function sabr_ump_partTypeLabel(partType as integer) as string
    if partType = UMP_PART_ID_MEDIA_HEADER then return "MEDIA_HEADER"
    if partType = UMP_PART_ID_MEDIA then return "MEDIA"
    if partType = UMP_PART_ID_MEDIA_END then return "MEDIA_END"
    if partType = UMP_PART_ID_NEXT_REQUEST_POLICY then return "NEXT_REQUEST_POLICY"
    if partType = UMP_PART_ID_FORMAT_INIT_METADATA then return "FORMAT_INIT_METADATA"
    if partType = UMP_PART_ID_SABR_REDIRECT then return "SABR_REDIRECT"
    if partType = UMP_PART_ID_SABR_ERROR then return "SABR_ERROR"
    if partType = UMP_PART_ID_RELOAD_PLAYER_RESPONSE then return "RELOAD_PLAYBACK_CONTEXT"
    if partType = UMP_PART_ID_SABR_CONTEXT_UPDATE then return "SABR_CONTEXT_UPDATE"
    if partType = UMP_PART_ID_STREAM_PROTECTION_STATUS then return "STREAM_PROTECTION_STATUS"
    if partType = UMP_PART_ID_SABR_CONTEXT_SENDING_POLICY then return "SABR_CONTEXT_SENDING_POLICY"
    if partType = UMP_PART_ID_SNACKBAR_MESSAGE then return "SNACKBAR_MESSAGE"
    return `${partType}`
end function

'------------------------------------------------------------------------------
' Function : sabr_ump_decodePart
' Purpose  : Helper that safely decodes a payload subsection using a provided
'            protobuf decoder, logging failures and falling back to defaults.
'------------------------------------------------------------------------------
function sabr_ump_decodePart(decodeFunc as dynamic, payload as dynamic, defaultValue = invalid as dynamic, label = "" as string) as dynamic
    if decodeFunc = invalid then return defaultValue
    if not isValid(payload) then return defaultValue

    encoded = invalid
    if GetInterface(payload, "ifByteArray") <> invalid
        encoded = payload.ToBase64String()
    else if IsString(payload)
        encoded = payload
    end if
    if not IsString(encoded) or encoded = "" then return defaultValue

    result = defaultValue
    success = true
    try
        result = decodeFunc(encoded)
    catch e
        success = false
    end try
    if success then return result
    return defaultValue
end function

'------------------------------------------------------------------------------
' Function : sabr_ump_buildSidxIndexUpdate
' Purpose  : Creates the normalized structure stored in playback context when
'            new SIDX information is discovered in a spool payload.
'------------------------------------------------------------------------------
function sabr_ump_buildSidxIndexUpdate(existing as dynamic, mediaHeader as object, segmentBytes as object) as dynamic
    if GetInterface(segmentBytes, "ifByteArray") = invalid or segmentBytes.count() <= 0 then return invalid

    indexInfo = sabr_mp4_extractSidxIndex(segmentBytes)
    if not IsAssociativeArray(indexInfo) then return invalid

    timescale = sabr_toInt(indexInfo?.timescale)
    if timescale = invalid or timescale <= 0 then timescale = 1

    entries = []
    accumulated = 0
    references = indexInfo?.references
    if IsArray(references)
        for each reference in references
            if not IsAssociativeArray(reference) then continue for
            duration = sabr_toInt(reference?.subsegmentDuration)
            if duration = invalid or duration < 0 then duration = 0
            startMs = int((accumulated * 1000) / timescale)
            durationMs = int((duration * 1000) / timescale)
            rangeStart = sabr_toInt(reference?.rangeStart)
            if rangeStart = invalid then rangeStart = int(reference?.rangeStart)
            rangeEnd = sabr_toInt(reference?.rangeEnd)
            if rangeEnd = invalid then rangeEnd = int(reference?.rangeEnd)
            entries.push({
                "rangeStart": rangeStart
                "rangeEnd": rangeEnd
                "startTimeMs": startMs
                "durationMs": durationMs
                "referenceType": sabr_toInt(reference?.referenceType)
            })
            accumulated = accumulated + duration
        end for
    end if

    formatKey = ""
    formatInfo = mediaHeader?.formatId
    if not IsAssociativeArray(formatInfo)
        formatInfo = mediaHeader?.format
    end if
    if IsAssociativeArray(formatInfo)
        itagLabel = sabr_valueToLabel(formatInfo.Lookup("itag"))
        xtagLabel = sabr_valueToLabel(formatInfo.Lookup("xtags"))
        formatKey = `${itagLabel}:${xtagLabel}`
    else
        itagLabel = sabr_valueToLabel(mediaHeader?.itag)
        xtagLabel = sabr_valueToLabel(mediaHeader?.xtags)
        formatKey = `${itagLabel}:${xtagLabel}`
    end if
    if formatKey = ":" then formatKey = ""

    contentType = `${mediaHeader?.contentType ?? ""}`
    if contentType = "" and IsAssociativeArray(mediaHeader?.format)
        contentType = `${mediaHeader.format?.contentType ?? ""}`
    end if

    update = {
        "formatKey": formatKey
        "entries": entries
        "timescale": timescale
        "earliestPresentationTime": indexInfo?.earliestPresentationTime
        "contentType": contentType
    }

    if entries.count() = 0
        update["unsupportedReason"] = "empty_sidx"
    end if

    return update
end function
