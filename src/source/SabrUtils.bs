' Shared utility helpers used across SABR modules.

' Returns mediaIdHash (string) or invalid if not found
function sabr_extractMediaIdHash(url as string) as dynamic
    ' /sabr/<anything-not-a-slash>(optional slash)
    re = CreateObject("roRegex", "/sabr/([^/]+)/?", "i")
    m = re.Match(url)
    if m.Count() >= 2 then return m[1]
    return invalid
end function

function sabr_toInt(value as dynamic) as dynamic
    if not isValid(value) then return invalid
    if IsInteger(value) then return value
    if IsFloat(value) or IsDouble(value) then return int(value)
    if IsString(value)
        trimmed = value.trim()
        if trimmed = "" then return invalid
        return trimmed.toInt()
    end if
    return invalid
end function

function sabr_safeToInt(value as dynamic) as integer
    result = sabr_toInt(value)
    if result = invalid then return 0
    return result
end function

function sabr_toSafeString(value as dynamic) as string
    if not isValid(value) then return ""
    if IsString(value) then return value.trim()
    if IsBoolean(value) then return value = true ? "true" : "false"
    if IsInteger(value) then return value.toStr()
    if IsFloat(value) or IsDouble(value)
        precise = FormatJson(value)
        if precise <> "" and Instr(1, precise, "e") = 0 and Instr(1, precise, "E") = 0 then return precise
        intVal = int(value)
        if Abs(value - intVal) < 0.000001 then return intVal.toStr()
        ' fallback to manual formatting without scientific notation
        return Str(value).trim()
    end if
    return Str(value).trim()
end function

function sabr_currentTimestampMs() as integer
    dt = CreateObject("roDateTime")
    if not IsDateTime(dt) then return 0
    return (dt.AsSeconds() * 1000) + dt.GetMilliseconds()
end function

function sabr_formatExceptionDetail(err as dynamic) as string
    if not isValid(err) then return ""
    if IsString(err) then return err
    if IsAssociativeArray(err)
        serializable = {}
        for each key in err
            serializable[key] = err[key]
        end for
        detail = invalid
        try
            detail = FormatJson(serializable)
        catch jsonErr
            detail = invalid
        end try
        if isValid(detail) and detail <> ""
            return detail
        end if
        return Str(err).trim()
    end if
    detail = invalid
    try
        detail = FormatJson(err)
    catch jsonErr
        detail = invalid
    end try
    if isValid(detail) and detail <> ""
        return detail
    end if
    return Str(err).trim()
end function

function sabr_joinWithPipe(parts as object) as string
    if not IsArray(parts) then return ""
    total = parts.count()
    if total = 0 then return ""
    result = ""
    for i = 0 to total - 1
        piece = parts[i] ?? ""
        if result <> "" then result = `${result}|`
        result = `${result}${piece}`
    end for
    return result
end function

function sabr_isNumericLiteralString(text as string) as boolean
    if not IsString(text) then return false
    trimmed = text.trim()
    if trimmed = "" then return false

    hasDigit = false
    total = Len(trimmed)
    for i = 1 to total
        ch = Mid(trimmed, i, 1)
        ascii = Asc(ch)
        if ascii >= 48 and ascii <= 57
            hasDigit = true
        else if ascii = 43 or ascii = 45 or ascii = 46 or ascii = 69 or ascii = 101
            ' allowed characters: + - . E e
        else
            return false
        end if
    end for

    return hasDigit
end function

function sabr_valueToLabel(value as dynamic) as string
    if not isValid(value) then return ""
    if IsString(value)
        trimmed = value.trim()
        if trimmed = "" then return ""
        if (Instr(1, trimmed, "e") > 0 or Instr(1, trimmed, "E") > 0) and sabr_isNumericLiteralString(trimmed)
            numeric = trimmed.toFloat()
            if numeric <> invalid
                return sabr_valueToLabel(numeric)
            end if
        end if
        return trimmed
    end if
    if IsInteger(value) then return value.toStr()
    if IsFloat(value) or IsDouble(value)
        precise = FormatJson(value)
        if precise <> "" and Instr(1, precise, "e") = 0 and Instr(1, precise, "E") = 0
            return precise
        end if
        intVal = int(value)
        if Abs(value - intVal) < 0.000001 then return intVal.toStr()
        strVal = Str(value).trim()
        if Instr(1, strVal, "e") > 0 or Instr(1, strVal, "E") > 0
            return FormatJson(int(value))
        end if
        return strVal
    end if
    return Str(value).trim()
end function

function sabr_formatRequestedRangeForPath(byteRange as object) as string
    if not isValid(byteRange) then return "none"
    startLabel = sabr_valueToLabel(byteRange?.startRange)
    if startLabel = "" then startLabel = sabr_valueToLabel(byteRange?.start)
    endLabel = sabr_valueToLabel(byteRange?.endRange)
    if endLabel = "" then endLabel = sabr_valueToLabel(byteRange?.end)
    if startLabel <> "" and endLabel <> ""
        return `${startLabel}-${endLabel}`
    else if startLabel <> ""
        return `${startLabel}-`
    else if endLabel <> ""
        return `-${endLabel}`
    end if
    return "none"
end function

function sabr_extractRequestNumber(value as dynamic) as string
    if not isValid(value) then return ""
    if IsAssociativeArray(value)
        if value.DoesExist("requestNumber")
            return sabr_extractRequestNumber(value.requestNumber)
        end if
        return ""
    end if
    return sabr_valueToLabel(value)
end function

function sabr_formatToKey(format as dynamic) as string
    if not isValid(format) then return ""
    itagPart = ""
    if isValid(format.itag)
        itagPart = `${format.itag}`
    end if
    xtagsPart = ""
    if isValid(format.xtags)
        xtagsPart = `${format.xtags}`
    end if
    return `${itagPart}:${xtagsPart}`
end function

function sabr_cloneObject(value as dynamic) as dynamic
    if not isValid(value) then return invalid
    json = ""
    clone = invalid
    try
        json = FormatJson(value)
        if isValid(json) and json <> ""
            clone = ParseJson(json)
        end if
    catch e
        clone = invalid
    end try
    if not isValid(clone) then clone = value
    return clone
end function

function sabr_formatToFormatId(format as object) as object
    if not isValid(format) then return {}
    return {
        "itag": format.itag,
        "xtags": format.xtags,
        "lastModified": format.lastModified
    }
end function

function sabr_findInArray(arr as object, value as string) as boolean
    if not IsArray(arr) then return false
    for each item in arr
        if IsString(item) and item = value
            return true
        end if
    end for
    return false
end function

function sabr_urlEncode(value as string) as string
    if not isValid(value) then return ""
    encoder = CreateObject("roUrlTransfer")
    return encoder.Escape(value)
end function

function sabr_sanitizeForFilename(value as string) as string
    if not isValid(value) then return ""
    sanitized = ""
    for i = 1 to Len(value)
        ch = Mid(value, i, 1)
        if ch = "/" or ch = "\\"
            sanitized = sanitized + "_"
        else
            ascii = Asc(ch)
            if (ascii >= 48 and ascii <= 57) or (ascii >= 65 and ascii <= 90) or (ascii >= 97 and ascii <= 122) or ch = "." or ch = "-" or ch = "_"
                sanitized = sanitized + ch
            else
                sanitized = sanitized + "_"
            end if
        end if
    end for
    return sanitized
end function

function sabr_joinPath(base as string, name as string) as string
    if not IsString(base) then base = ""
    if not IsString(name) then name = ""
    if base = "" then return name
    if name = "" then return base
    separator = Right(base, 1) = "/" ? "" : "/"
    return `${base}${separator}${name}`
end function

function sabr_pathIsDir(path as string) as boolean
    if not isValid(path) or path = "" then return false

    lastChar = Right(path, 1)
    if lastChar = "/" or lastChar = "\\" then return true

    currentSegment = ""
    for i = 1 to Len(path)
        ch = Mid(path, i, 1)
        if ch = "/" or ch = "\\"
            currentSegment = ""
        else
            currentSegment = currentSegment + ch
        end if
    end for

    if currentSegment = "" then return true

    dotPos = currentSegment.InStr(".")
    return dotPos = 0
end function

' Aliases kept for legacy SABR UMP helpers so callers need not change.

function sabr_ump_toInt(value as dynamic) as dynamic
    return sabr_toInt(value)
end function

function sabr_ump_toSafeString(value as dynamic) as string
    return sabr_toSafeString(value)
end function

function sabr_ump_joinWithPipe(values as object) as string
    return sabr_joinWithPipe(values)
end function

function sabr_ump_valueToLabel(value as dynamic) as string
    return sabr_valueToLabel(value)
end function

function sabr_ump_findInArray(arr as object, value as string) as boolean
    return sabr_findInArray(arr, value)
end function

function sabr_ump_urlEncode(value as string) as string
    return sabr_urlEncode(value)
end function

function sabr_ump_sanitizeForFilename(value as string) as string
    return sabr_sanitizeForFilename(value)
end function

function sabr_ump_joinPath(base as string, name as string) as string
    return sabr_joinPath(base, name)
end function

function sabr_ump_pathIsDir(path as string) as boolean
    return sabr_pathIsDir(path)
end function
