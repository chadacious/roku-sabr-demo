' Shared utility helpers used across SABR modules.

' Returns mediaIdHash (string) or invalid if not found
function sabr_extractMediaIdHash(url as string) as dynamic
    ' /sabr/<anything-not-a-slash>(optional slash)
    re = CreateObject("roRegex", "/sabr/([^/]+)/?", "i")
    m = re.Match(url)
    if m.Count() >= 2 then return m[1]
    return invalid
end function

'------------------------------------------------------------------------------
' Function: sabr_toInt
' Purpose : Normalize any primitive into the signed 32-bit integer range we use
'           across SABR files. Returns invalid for non-numeric inputs.
'------------------------------------------------------------------------------
function sabr_toInt(value as dynamic) as dynamic
    if not isValid(value) then return invalid
    if IsInteger(value) then return value
    if IsFloat(value) or IsDouble(value) then return int(value)
    if IsString(value)
        trimmed = value.trim()
        if trimmed = "" then return invalid
        return trimmed.toInt()
    end if
    return invalid
end function

'------------------------------------------------------------------------------
' Function: sabr_toSafeString
' Purpose : Convert diverse primitive types into deterministic ascii strings.
'------------------------------------------------------------------------------
function sabr_toSafeString(value as dynamic) as string
    if not isValid(value) then return ""
    if IsString(value) then return value.trim()
    if IsBoolean(value) then return value = true ? "true" : "false"
    if IsInteger(value) then return value.toStr()
    if IsFloat(value) or IsDouble(value)
        ' FormatJson keeps full precision when the runtime would otherwise fall back to scientific notation.
        precise = FormatJson(value)
        if precise <> "" and Instr(1, precise, "e") = 0 and Instr(1, precise, "E") = 0 then return precise
        intVal = int(value)
        if Abs(value - intVal) < 0.000001 then return intVal.toStr()
        ' fallback to manual formatting without scientific notation
        return Str(value).trim()
    end if
    return Str(value).trim()
end function

function sabr_formatExceptionDetail(err as dynamic) as string
    if not isValid(err) then return ""
    if IsString(err) then return err
    if IsAssociativeArray(err)
        serializable = {}
        for each key in err
            serializable[key] = err[key]
        end for
        detail = invalid
        try
            detail = FormatJson(serializable)
        catch jsonErr
            detail = invalid
        end try
        if isValid(detail) and detail <> ""
            return detail
        end if
        return Str(err).trim()
    end if
    detail = invalid
    try
        detail = FormatJson(err)
    catch jsonErr
        detail = invalid
    end try
    if isValid(detail) and detail <> ""
        return detail
    end if
    return Str(err).trim()
end function

function sabr_joinWithPipe(parts as object) as string
    if not IsArray(parts) then return ""
    total = parts.count()
    if total = 0 then return ""
    result = ""
    for i = 0 to total - 1
        piece = parts[i] ?? ""
        if result <> "" then result = `${result}|`
        result = `${result}${piece}`
    end for
    return result
end function

function sabr_isNumericLiteralString(text as string) as boolean
    if not IsString(text) then return false
    trimmed = text.trim()
    if trimmed = "" then return false

    hasDigit = false
    total = Len(trimmed)
    for i = 1 to total
        ch = Mid(trimmed, i, 1)
        ascii = Asc(ch)
        if ascii >= 48 and ascii <= 57
            hasDigit = true
        else if ascii = 43 or ascii = 45 or ascii = 46 or ascii = 69 or ascii = 101
            ' allowed characters: + - . E e
        else
            return false
        end if
    end for

    return hasDigit
end function

function sabr_valueToLabel(value as dynamic) as string
    if not isValid(value) then return ""
    if IsString(value)
        trimmed = value.trim()
        if trimmed = "" then return ""
        if (Instr(1, trimmed, "e") > 0 or Instr(1, trimmed, "E") > 0) and sabr_isNumericLiteralString(trimmed)
            numeric = trimmed.toFloat()
            if numeric <> invalid
                return sabr_valueToLabel(numeric)
            end if
        end if
        return trimmed
    end if
    if IsInteger(value) then return value.toStr()
    if IsFloat(value) or IsDouble(value)
        precise = FormatJson(value)
        if precise <> "" and Instr(1, precise, "e") = 0 and Instr(1, precise, "E") = 0
            return precise
        end if
        intVal = int(value)
        if Abs(value - intVal) < 0.000001 then return intVal.toStr()
        strVal = Str(value).trim()
        if Instr(1, strVal, "e") > 0 or Instr(1, strVal, "E") > 0
            return FormatJson(int(value))
        end if
        return strVal
    end if
    return Str(value).trim()
end function

function sabr_formatRequestedRangeForPath(byteRange as object) as string
    if not isValid(byteRange) then return "none"
    startLabel = sabr_valueToLabel(byteRange?.startRange)
    if startLabel = "" then startLabel = sabr_valueToLabel(byteRange?.start)
    endLabel = sabr_valueToLabel(byteRange?.endRange)
    if endLabel = "" then endLabel = sabr_valueToLabel(byteRange?.end)
    if startLabel <> "" and endLabel <> ""
        return `${startLabel}-${endLabel}`
    else if startLabel <> ""
        return `${startLabel}-`
    else if endLabel <> ""
        return `-${endLabel}`
    end if
    return "none"
end function

function sabr_extractRequestNumber(value as dynamic) as string
    if not isValid(value) then return ""
    if IsAssociativeArray(value)
        if value.DoesExist("requestNumber")
            return sabr_extractRequestNumber(value.requestNumber)
        end if
        return ""
    end if
    return sabr_valueToLabel(value)
end function

function sabr_formatToFormatId(format as object) as object
    if not isValid(format) then return {}
    return {
        "itag": format.itag,
        "xtags": format.xtags,
        "lastModified": format.lastModified
    }
end function

function sabr_findInArray(arr as object, value as string) as boolean
    if not IsArray(arr) then return false
    for each item in arr
        if IsString(item) and item = value
            return true
        end if
    end for
    return false
end function

function sabr_urlEncode(value as string) as string
    if not isValid(value) then return ""
    encoder = CreateObject("roUrlTransfer")
    return encoder.Escape(value)
end function

function sabr_sanitizeForFilename(value as string) as string
    if not isValid(value) then return ""
    sanitized = ""
    for i = 1 to Len(value)
        ch = Mid(value, i, 1)
        if ch = "/" or ch = "\\"
            sanitized = sanitized + "_"
        else
            ascii = Asc(ch)
            if (ascii >= 48 and ascii <= 57) or (ascii >= 65 and ascii <= 90) or (ascii >= 97 and ascii <= 122) or ch = "." or ch = "-" or ch = "_"
                sanitized = sanitized + ch
            else
                sanitized = sanitized + "_"
            end if
        end if
    end for
    return sanitized
end function

'------------------------------------------------------------------------------
' Storage helpers for SABR artifacts
'------------------------------------------------------------------------------
function sabr_storageRoot() as string
    return "tmp:/sabr"
end function

sub sabr_ensureStorageRoot()
    rootPath = sabr_storageRoot()
    fs = CreateObject("roFileSystem")
    fs.CreateDirectory(rootPath)
end sub

function sabr_mediaDir(mediaIdHash as string) as string
    baseDir = sabr_storageRoot()
    safeHash = sabr_sanitizeForFilename(sabr_toSafeString(mediaIdHash))
    if safeHash = "" then return baseDir
    return `${baseDir}/${safeHash}`
end function

sub sabr_ensureMediaDir(mediaIdHash as string)
    sabr_ensureStorageRoot()
    safeHash = sabr_sanitizeForFilename(sabr_toSafeString(mediaIdHash))
    if safeHash = "" then return
    fs = CreateObject("roFileSystem")
    fs.CreateDirectory(`${sabr_storageRoot()}/${safeHash}`)
end sub

sub sabr_deleteDirectoryRecursive(path as string)
    if not IsString(path) or path = "" then return
    fs = CreateObject("roFileSystem")
    if fs.Exists(path) <> true then return
    listing = fs.GetDirectoryListing(path)
    if IsArray(listing)
        for each entry in listing
            childPath = `${path}/${entry}`
            childListing = fs.GetDirectoryListing(childPath)
            if IsArray(childListing)
                ' Recurse into nested directories before deleting the parent.
                sabr_deleteDirectoryRecursive(childPath)
            else
                fs.Delete(childPath)
            end if
        end for
    end if
    fs.Delete(path)
end sub

sub sabr_deleteMediaDir(mediaIdHash as string)
    safeHash = sabr_sanitizeForFilename(sabr_toSafeString(mediaIdHash))
    if safeHash = "" then return
    sabr_deleteDirectoryRecursive(`${sabr_storageRoot()}/${safeHash}`)
end sub

sub sabr_pruneOtherMediaDirs(activeMediaId as string)
    sabr_ensureStorageRoot()
    rootPath = sabr_storageRoot()
    fs = CreateObject("roFileSystem")
    listing = fs.GetDirectoryListing(rootPath)
    activeHash = sabr_sanitizeForFilename(sabr_toSafeString(activeMediaId))
    if activeHash = "" then return
    if IsArray(listing)
        for each entry in listing
            childPath = `${rootPath}/${entry}`
            childListing = fs.GetDirectoryListing(childPath)
            if IsArray(childListing)
                if activeHash = "" or entry <> activeHash
                    sabr_deleteDirectoryRecursive(childPath)
                end if
            end if
        end for
    end if
end sub

function sabr_joinPath(base as string, name as string) as string
    if not IsString(base) then base = ""
    if not IsString(name) then name = ""
    if base = "" then return name
    if name = "" then return base
    separator = Right(base, 1) = "/" ? "" : "/"
    return `${base}${separator}${name}`
end function

function sabr_pathIsDir(path as string) as boolean
    if not isValid(path) or path = "" then return false

    lastChar = Right(path, 1)
    if lastChar = "/" or lastChar = "\\" then return true

    currentSegment = ""
    for i = 1 to Len(path)
        ch = Mid(path, i, 1)
        if ch = "/" or ch = "\\"
            currentSegment = ""
        else
            currentSegment = currentSegment + ch
        end if
    end for

    if currentSegment = "" then return true

    dotPos = currentSegment.InStr(".")
    return dotPos = 0
end function

' Aliases kept for legacy SABR UMP helpers so callers need not change.

function sabr_ump_toInt(value as dynamic) as dynamic
    return sabr_toInt(value)
end function

function sabr_ump_toSafeString(value as dynamic) as string
    return sabr_toSafeString(value)
end function

function sabr_ump_joinWithPipe(values as object) as string
    return sabr_joinWithPipe(values)
end function

function sabr_ump_valueToLabel(value as dynamic) as string
    return sabr_valueToLabel(value)
end function

function sabr_ump_sanitizeForFilename(value as string) as string
    return sabr_sanitizeForFilename(value)
end function
