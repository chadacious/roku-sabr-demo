' Shared utility helpers used across SABR modules.

' Returns mediaIdHash (string) or invalid if not found
function sabr_extractMediaIdHash(url as string) as dynamic
    ' /sabr/<anything-not-a-slash>(optional slash)
    re = CreateObject("roRegex", "/sabr/([^/]+)/?", "i")
    m = re.Match(url)
    if m.Count() >= 2 then return m[1]
    return invalid
end function

'------------------------------------------------------------------------------
' Function: sabr_toInt
' Purpose : Normalize any primitive into the signed 32-bit integer range we use
'           across SABR files. Returns invalid for non-numeric inputs.
'------------------------------------------------------------------------------
function sabr_toInt(value as dynamic) as dynamic
    if not isValid(value) then return invalid
    if IsInteger(value) then return value
    if IsFloat(value) or IsDouble(value) then return int(value)
    if IsString(value)
        trimmed = value.trim()
        if trimmed = "" then return invalid
        return trimmed.toInt()
    end if
    return invalid
end function

'------------------------------------------------------------------------------
' Function: sabr_toSafeString
' Purpose : Convert diverse primitive types into deterministic ascii strings.
'------------------------------------------------------------------------------
function sabr_toSafeString(value as dynamic) as string
    if not isValid(value) then return ""
    if IsString(value) then return value.trim()
    if IsBoolean(value) then return value = true ? "true" : "false"
    if IsInteger(value) then return value.toStr()
    if IsFloat(value) or IsDouble(value)
        ' FormatJson keeps full precision when the runtime would otherwise fall back to scientific notation.
        precise = FormatJson(value)
        if precise <> "" and Instr(1, precise, "e") = 0 and Instr(1, precise, "E") = 0 then return precise
        intVal = int(value)
        if Abs(value - intVal) < 0.000001 then return intVal.toStr()
        ' fallback to manual formatting without scientific notation
        return Str(value).trim()
    end if
    return Str(value).trim()
end function

function sabr_formatExceptionDetail(err as dynamic) as string
    if not isValid(err) then return ""
    if IsString(err) then return err
    if IsAssociativeArray(err)
        serializable = {}
        for each key in err
            serializable[key] = err[key]
        end for
        detail = invalid
        try
            detail = FormatJson(serializable)
        catch jsonErr
            detail = invalid
        end try
        if isValid(detail) and detail <> ""
            return detail
        end if
        return Str(err).trim()
    end if
    detail = invalid
    try
        detail = FormatJson(err)
    catch jsonErr
        detail = invalid
    end try
    if isValid(detail) and detail <> ""
        return detail
    end if
    return Str(err).trim()
end function

function sabr_joinWithPipe(parts as object) as string
    if not IsArray(parts) then return ""
    total = parts.count()
    if total = 0 then return ""
    result = ""
    for i = 0 to total - 1
        piece = parts[i] ?? ""
        if result <> "" then result = `${result}|`
        result = `${result}${piece}`
    end for
    return result
end function

' Parse SABR key in format itag:xtags:scope (exactly two colons; xtags may be empty)
function sabr_parseScopedKey(keyValue as dynamic) as dynamic
    if not isValid(keyValue) then return invalid
    if not IsString(keyValue) then return invalid
    trimmed = keyValue.trim()
    if trimmed = "" then return invalid
    re = CreateObject("roRegex", "^([^:]+):([^:]*):([^:]+)$", "i")
    match = re.Match(trimmed)
    if match.Count() <> 4 then return invalid
    itagVal = sabr_toInt(match[1])
    if itagVal = invalid then return invalid
    return {
        "raw": trimmed
        "itag": itagVal
        "xtags": match[2]
        "scope": match[3]
    }
end function

function sabr_isNumericLiteralString(text as string) as boolean
    if not IsString(text) then return false
    trimmed = text.trim()
    if trimmed = "" then return false

    hasDigit = false
    total = Len(trimmed)
    for i = 1 to total
        ch = Mid(trimmed, i, 1)
        ascii = Asc(ch)
        if ascii >= 48 and ascii <= 57
            hasDigit = true
        else if ascii = 43 or ascii = 45 or ascii = 46 or ascii = 69 or ascii = 101
            ' allowed characters: + - . E e
        else
            return false
        end if
    end for

    return hasDigit
end function

function sabr_valueToLabel(value as dynamic) as string
    if not isValid(value) then return ""
    if IsString(value)
        trimmed = value.trim()
        if trimmed = "" then return ""
        if (Instr(1, trimmed, "e") > 0 or Instr(1, trimmed, "E") > 0) and sabr_isNumericLiteralString(trimmed)
            numeric = trimmed.toFloat()
            if numeric <> invalid
                return sabr_valueToLabel(numeric)
            end if
        end if
        return trimmed
    end if
    if IsInteger(value) then return value.toStr()
    if IsFloat(value) or IsDouble(value)
        precise = FormatJson(value)
        if precise <> "" and Instr(1, precise, "e") = 0 and Instr(1, precise, "E") = 0
            return precise
        end if
        intVal = int(value)
        if Abs(value - intVal) < 0.000001 then return intVal.toStr()
        strVal = Str(value).trim()
        if Instr(1, strVal, "e") > 0 or Instr(1, strVal, "E") > 0
            return FormatJson(int(value))
        end if
        return strVal
    end if
    return Str(value).trim()
end function

function sabr_formatRequestedRangeForPath(byteRange as object) as string
    if not isValid(byteRange) then return "none"
    startLabel = sabr_valueToLabel(byteRange?.startRange)
    if startLabel = "" then startLabel = sabr_valueToLabel(byteRange?.start)
    endLabel = sabr_valueToLabel(byteRange?.endRange)
    if endLabel = "" then endLabel = sabr_valueToLabel(byteRange?.end)
    if startLabel <> "" and endLabel <> ""
        return `${startLabel}-${endLabel}`
    else if startLabel <> ""
        return `${startLabel}-`
    else if endLabel <> ""
        return `-${endLabel}`
    end if
    return "none"
end function

function sabr_extractRequestNumber(value as dynamic) as string
    if not isValid(value) then return ""
    if IsAssociativeArray(value)
        if value.DoesExist("requestNumber")
            return sabr_extractRequestNumber(value.requestNumber)
        end if
        return ""
    end if
    return sabr_valueToLabel(value)
end function

function sabr_formatToFormatId(format as object) as object
    if not isValid(format) then return {}
    return {
        "itag": format.itag,
        "xtags": format.xtags,
        "lastModified": format.lastModified
    }
end function

function sabr_findInArray(arr as object, value as string) as boolean
    if not IsArray(arr) then return false
    for each item in arr
        if IsString(item) and item = value
            return true
        end if
    end for
    return false
end function

function sabr_urlEncode(value as string) as string
    if not isValid(value) then return ""
    encoder = CreateObject("roUrlTransfer")
    return encoder.Escape(value)
end function

function sabr_sanitizeForFilename(value as string) as string
    if not isValid(value) then return ""
    sanitized = ""
    for i = 1 to Len(value)
        ch = Mid(value, i, 1)
        if ch = "/" or ch = "\\"
            sanitized = sanitized + "_"
        else
            ascii = Asc(ch)
            if (ascii >= 48 and ascii <= 57) or (ascii >= 65 and ascii <= 90) or (ascii >= 97 and ascii <= 122) or ch = "." or ch = "-" or ch = "_"
                sanitized = sanitized + ch
            else
                sanitized = sanitized + "_"
            end if
        end if
    end for
    return sanitized
end function

'------------------------------------------------------------------------------
' Storage helpers for SABR artifacts
'------------------------------------------------------------------------------
function sabr_storageRoot() as string
    return "tmp:/sabr"
end function

sub sabr_ensureStorageRoot()
    rootPath = sabr_storageRoot()
    fs = CreateObject("roFileSystem")
    fs.CreateDirectory(rootPath)
end sub

function sabr_mediaDir(mediaIdHash as string) as string
    baseDir = sabr_storageRoot()
    safeHash = sabr_sanitizeForFilename(sabr_toSafeString(mediaIdHash))
    if safeHash = "" then return baseDir
    return `${baseDir}/${safeHash}`
end function

sub sabr_ensureMediaDir(mediaIdHash as string)
    sabr_ensureStorageRoot()
    safeHash = sabr_sanitizeForFilename(sabr_toSafeString(mediaIdHash))
    if safeHash = "" then return
    fs = CreateObject("roFileSystem")
    fs.CreateDirectory(`${sabr_storageRoot()}/${safeHash}`)
end sub

sub sabr_deleteDirectoryRecursive(path as string)
    if not IsString(path) or path = "" then return
    fs = CreateObject("roFileSystem")
    if fs.Exists(path) <> true then return
    listing = fs.GetDirectoryListing(path)
    if IsArray(listing)
        for each entry in listing
            childPath = `${path}/${entry}`
            childListing = fs.GetDirectoryListing(childPath)
            if IsArray(childListing)
                ' Recurse into nested directories before deleting the parent.
                sabr_deleteDirectoryRecursive(childPath)
            else
                fs.Delete(childPath)
            end if
        end for
    end if
    fs.Delete(path)
end sub

sub sabr_deleteMediaDir(mediaIdHash as string)
    safeHash = sabr_sanitizeForFilename(sabr_toSafeString(mediaIdHash))
    if safeHash = "" then return
    sabr_deleteDirectoryRecursive(`${sabr_storageRoot()}/${safeHash}`)
end sub

sub sabr_pruneOtherMediaDirs(activeMediaId as string)
    sabr_ensureStorageRoot()
    rootPath = sabr_storageRoot()
    fs = CreateObject("roFileSystem")
    listing = fs.GetDirectoryListing(rootPath)
    activeHash = sabr_sanitizeForFilename(sabr_toSafeString(activeMediaId))
    if activeHash = "" then return
    if IsArray(listing)
        for each entry in listing
            childPath = `${rootPath}/${entry}`
            childListing = fs.GetDirectoryListing(childPath)
            if IsArray(childListing)
                if activeHash = "" or entry <> activeHash
                    sabr_deleteDirectoryRecursive(childPath)
                end if
            end if
        end for
    end if
end sub

function sabr_joinPath(base as string, name as string) as string
    if not IsString(base) then base = ""
    if not IsString(name) then name = ""
    if base = "" then return name
    if name = "" then return base
    separator = Right(base, 1) = "/" ? "" : "/"
    return `${base}${separator}${name}`
end function

function sabr_pathIsDir(path as string) as boolean
    if not isValid(path) or path = "" then return false

    lastChar = Right(path, 1)
    if lastChar = "/" or lastChar = "\\" then return true

    currentSegment = ""
    for i = 1 to Len(path)
        ch = Mid(path, i, 1)
        if ch = "/" or ch = "\\"
            currentSegment = ""
        else
            currentSegment = currentSegment + ch
        end if
    end for

    if currentSegment = "" then return true

    dotPos = currentSegment.InStr(".")
    return dotPos = 0
end function

'------------------------------------------------------------------------------
' SABR SupplementalProperty extraction (scoped SABR payloads)
'------------------------------------------------------------------------------
function sabr_extractScopedSabrPayloads(manifest as string, logs = invalid as dynamic) as object
    payloadsByScope = {}
    cleanedManifest = manifest
    if not isValid(manifest) or Len(manifest) = 0 then return { "manifest": cleanedManifest, "payloads": payloadsByScope }

    mpd = CreateObject("roXMLElement")
    parsed = false
    try
        parsed = mpd.Parse(manifest)
    catch e
        parsed = false
    end try
    if parsed
        sabr_collectScopedPayloads(mpd, payloadsByScope, logs)
    else if isValid(logs)
        logs.printl(log_level_Type.WARN, "[SabrUtils] Failed to parse MPD XML while extracting SABR payloads")
    end if

    removeRegex = CreateObject("roRegex", `<SupplementalProperty[^>]*schemeIdUri=["'][^"']*urn:youtube:sabr["'][^>]*?value=["'][^"']*["'][^>]*?>`, "gi")
    cleanedManifest = removeRegex.ReplaceAll(manifest, "")

    return {
        "manifest": cleanedManifest
        "payloads": payloadsByScope
    }
end function

sub sabr_collectScopedPayloads(mpd as object, payloads as object, logs = invalid as dynamic)
    if not isValid(mpd) then return

    ' Root-level SupplementalProperty entries
    childElements = mpd.GetChildElements()
    for each child in childElements
        if sabr_isSabrSupplementalProperty(child)
            payload = sabr_decodeSabrPayload(child, logs, "root")
            if isValid(payload)
                payloads["root"] = payload
            end if
        end if
    end for

    ' Period-level SupplementalProperty entries
    idx = 0
    for each child in childElements
        if LCase(child.GetName()) <> "period" then goto nextPeriod
        attrs = child.GetAttributes()
        scopeId = sabr_toSafeString(attrs?.Lookup("id"))
        if scopeId = ""
            scopeId = `period-${idx}`
        end if
        for each periodChild in child.GetChildElements()
            if sabr_isSabrSupplementalProperty(periodChild)
                payload = sabr_decodeSabrPayload(periodChild, logs, scopeId)
                if isValid(payload)
                    payloads[scopeId] = payload
                end if
            end if
        end for
        idx = idx + 1
        nextPeriod:
    end for
end sub

function sabr_isSabrSupplementalProperty(node as dynamic) as boolean
    if not isValid(node) then return false
    if LCase(node.GetName()) <> "supplementalproperty" then return false
    attrs = node.GetAttributes()
    if not isValid(attrs) then return false
    schemeId = LCase(sabr_toSafeString(attrs?.Lookup("schemeIdUri")))
    return Instr(1, schemeId, "urn:youtube:sabr") > 0
end function

function sabr_decodeSabrPayload(node as dynamic, logs = invalid as dynamic, scopeId = "" as string) as dynamic
    if not isValid(node) then return invalid
    attrs = node.GetAttributes()
    if not isValid(attrs) then return invalid
    encoded = sabr_toSafeString(attrs?.Lookup("value"))
    if encoded = "" then return invalid
    decodedText = fromBase64(encoded)
    payload = ParseJson(decodedText)
    if payload = invalid and isValid(logs)
        logs.printl(log_level_Type.WARN, `[SabrUtils] Failed to parse SABR payload JSON for scope ${scopeId}`)
    end if
    return payload
end function

'------------------------------------------------------------------------------
' Debug helper: log BaseURLs grouped by Period id to validate manifest rewrites.
'------------------------------------------------------------------------------
sub sabr_debugLogBaseUrls(manifest as string, logs = invalid as dynamic)
    if not isValid(logs) then return
    if manifest = invalid or Len(manifest) = 0 then return
    mpd = CreateObject("roXMLElement")
    parsed = false
    try
        parsed = mpd.Parse(manifest)
    catch e
        parsed = false
    end try
    if not parsed then return

    childElements = mpd.GetChildElements()
    for each child in childElements
        if LCase(child.GetName()) <> "period" then goto nextPeriod
        attrs = child.GetAttributes()
        periodId = sabr_toSafeString(attrs?.Lookup("id"))
        if periodId = "" then periodId = "root-period"
        baseUrls = []
        for each periodChild in child.GetChildElements()
            if LCase(periodChild.GetName()) = "baseurl"
                baseVal = sabr_toSafeString(periodChild.GetText())
                if baseVal <> "" then baseUrls.push(baseVal)
            end if
            ' Also scan adaptation/repr for BaseURL
            for each grandChild in periodChild.GetChildElements()
                if LCase(grandChild.GetName()) = "baseurl"
                    baseVal = sabr_toSafeString(grandChild.GetText())
                    if baseVal <> "" then baseUrls.push(baseVal)
                end if
                for each repChild in grandChild.GetChildElements()
                    if LCase(repChild.GetName()) = "baseurl"
                        baseVal = sabr_toSafeString(repChild.GetText())
                        if baseVal <> "" then baseUrls.push(baseVal)
                    end if
                end for
            end for
        end for
        if baseUrls.count() > 0
            for each entry in baseUrls
                val = entry
                if Len(val) > 200 then val = Left(val, 200) + "..."
                logs.printl(log_level_Type.INFO, `[SabrUtils] Period ${periodId} BaseURL: ${val}`)
            end for
        else
            logs.printl(log_level_Type.INFO, `[SabrUtils] Period ${periodId} has no BaseURL entries`)
        end if
        nextPeriod:
    end for
end sub

' Aliases kept for legacy SABR UMP helpers so callers need not change.

function sabr_ump_toInt(value as dynamic) as dynamic
    return sabr_toInt(value)
end function

function sabr_ump_toSafeString(value as dynamic) as string
    return sabr_toSafeString(value)
end function

function sabr_ump_joinWithPipe(values as object) as string
    return sabr_joinWithPipe(values)
end function

function sabr_ump_valueToLabel(value as dynamic) as string
    return sabr_valueToLabel(value)
end function

function sabr_ump_sanitizeForFilename(value as string) as string
    return sabr_sanitizeForFilename(value)
end function
